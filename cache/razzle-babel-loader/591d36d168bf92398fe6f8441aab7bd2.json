{"ast":null,"code":"import _objectSpread from \"/home/jakob/workspace/training-project/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport isUrl from 'is-url';\nimport imageExtensions from 'image-extensions';\nimport { blockTagDeserializer } from '@plone/volto-slate/editor/deserialize';\nimport { getBaseUrl } from '@plone/volto/helpers';\nimport { v4 as uuid } from 'uuid';\nimport { Transforms } from 'slate';\nimport { IMAGE } from '@plone/volto-slate/constants';\nexport const insertImage = function (editor, url) {\n  let {\n    typeImg = IMAGE\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const image = {\n    type: typeImg,\n    url,\n    children: [{\n      text: ''\n    }]\n  };\n  Transforms.insertNodes(editor, image);\n};\nexport const isImageUrl = url => {\n  if (!isUrl(url)) return false;\n  const ext = new URL(url).pathname.split('.').pop();\n  return imageExtensions.includes(ext);\n};\nexport const onImageLoad = (editor, reader) => () => {\n  const data = reader.result; // if (url) insertImage(editor, url);\n\n  const fields = data.match(/^data:(.*);(.*),(.*)$/);\n  const blockProps = editor.getBlockProps();\n  const {\n    block,\n    uploadContent,\n    pathname\n  } = blockProps; // TODO: we need a way to get the uploaded image URL\n  // This would be easier if we would have block transformers-based image\n  // blocks\n\n  const url = getBaseUrl(pathname);\n  const uploadId = uuid();\n  const uploadFileName = `clipboard-${uploadId}`;\n  const uploadTitle = `Clipboard image`;\n  const content = {\n    '@type': 'Image',\n    title: uploadTitle,\n    image: {\n      data: fields[3],\n      encoding: fields[2],\n      'content-type': fields[1],\n      filename: uploadFileName\n    }\n  };\n  uploadContent(url, content, block).then(data => {\n    const dlUrl = data.image.download;\n    insertImage(editor, dlUrl);\n  });\n};\nexport const withDeserializers = editor => {\n  var _editor$dataTransferH;\n\n  editor.htmlTagsToSlate = _objectSpread(_objectSpread({}, editor.htmlTagsToSlate), {}, {\n    // We don't want H1 tags when pasting, we rewrite them as H2\n    H1: blockTagDeserializer('h2')\n  });\n\n  const handleFiles = ((_editor$dataTransferH = editor.dataTransferHandlers) === null || _editor$dataTransferH === void 0 ? void 0 : _editor$dataTransferH.files) || (() => true);\n\n  editor.dataTransferHandlers = _objectSpread(_objectSpread({}, editor.dataTransferHandlers), {}, {\n    files: files => {\n      const unprocessed = [];\n\n      for (const file of files) {\n        const reader = new FileReader();\n        const [mime] = file.type.split('/');\n\n        if (mime === 'image') {\n          reader.addEventListener('load', onImageLoad(editor, reader));\n          reader.readAsDataURL(file);\n        } else {\n          unprocessed.push(file);\n        }\n      }\n\n      return handleFiles(unprocessed);\n    }\n  });\n  return editor;\n};","map":{"version":3,"names":["isUrl","imageExtensions","blockTagDeserializer","getBaseUrl","v4","uuid","Transforms","IMAGE","insertImage","editor","url","typeImg","image","type","children","text","insertNodes","isImageUrl","ext","URL","pathname","split","pop","includes","onImageLoad","reader","data","result","fields","match","blockProps","getBlockProps","block","uploadContent","uploadId","uploadFileName","uploadTitle","content","title","encoding","filename","then","dlUrl","download","withDeserializers","htmlTagsToSlate","H1","handleFiles","dataTransferHandlers","files","unprocessed","file","FileReader","mime","addEventListener","readAsDataURL","push"],"sources":["/home/jakob/workspace/training-project/node_modules/@plone/volto/packages/volto-slate/src/blocks/Text/extensions/withDeserializers.js"],"sourcesContent":["import isUrl from 'is-url';\nimport imageExtensions from 'image-extensions';\nimport { blockTagDeserializer } from '@plone/volto-slate/editor/deserialize';\nimport { getBaseUrl } from '@plone/volto/helpers';\nimport { v4 as uuid } from 'uuid';\nimport { Transforms } from 'slate';\n\nimport { IMAGE } from '@plone/volto-slate/constants';\n\nexport const insertImage = (editor, url, { typeImg = IMAGE } = {}) => {\n  const image = { type: typeImg, url, children: [{ text: '' }] };\n  Transforms.insertNodes(editor, image);\n};\n\nexport const isImageUrl = (url) => {\n  if (!isUrl(url)) return false;\n\n  const ext = new URL(url).pathname.split('.').pop();\n\n  return imageExtensions.includes(ext);\n};\n\nexport const onImageLoad = (editor, reader) => () => {\n  const data = reader.result;\n\n  // if (url) insertImage(editor, url);\n  const fields = data.match(/^data:(.*);(.*),(.*)$/);\n  const blockProps = editor.getBlockProps();\n  const { block, uploadContent, pathname } = blockProps;\n\n  // TODO: we need a way to get the uploaded image URL\n  // This would be easier if we would have block transformers-based image\n  // blocks\n  const url = getBaseUrl(pathname);\n  const uploadId = uuid();\n  const uploadFileName = `clipboard-${uploadId}`;\n  const uploadTitle = `Clipboard image`;\n  const content = {\n    '@type': 'Image',\n    title: uploadTitle,\n    image: {\n      data: fields[3],\n      encoding: fields[2],\n      'content-type': fields[1],\n      filename: uploadFileName,\n    },\n  };\n\n  uploadContent(url, content, block).then((data) => {\n    const dlUrl = data.image.download;\n    insertImage(editor, dlUrl);\n  });\n};\n\nexport const withDeserializers = (editor) => {\n  editor.htmlTagsToSlate = {\n    ...editor.htmlTagsToSlate,\n\n    // We don't want H1 tags when pasting, we rewrite them as H2\n    H1: blockTagDeserializer('h2'),\n  };\n\n  const handleFiles = editor.dataTransferHandlers?.files || (() => true);\n\n  editor.dataTransferHandlers = {\n    ...editor.dataTransferHandlers,\n    files: (files) => {\n      const unprocessed = [];\n      for (const file of files) {\n        const reader = new FileReader();\n        const [mime] = file.type.split('/');\n        if (mime === 'image') {\n          reader.addEventListener('load', onImageLoad(editor, reader));\n          reader.readAsDataURL(file);\n        } else {\n          unprocessed.push(file);\n        }\n      }\n\n      return handleFiles(unprocessed);\n    },\n  };\n\n  return editor;\n};\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module"}