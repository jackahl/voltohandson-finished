{"ast":null,"code":"import { Editor, Path, Transforms, Node } from 'slate';\nimport { isCursorInList, getCurrentListItem } from '@plone/volto-slate/utils';\nimport config from '@plone/volto/registry';\n/**\n * Move up a list with with `Ctrl+Up`. (The Up key is supposed here to be\n * pressed.)\n * @param {Editor} Editor\n * @param {KeyboardEvent} event\n */\n\nexport function moveListItemUp(_ref) {\n  let {\n    editor,\n    event\n  } = _ref;\n  // If Ctrl is not pressed or the cursor is not in a list, do nothing.\n  if (!(event.ctrlKey && isCursorInList(editor))) return; // Else prevent the default behavior of Slate, React and DOM and stop the\n  // propagation of this event.\n\n  const {\n    anchor\n  } = editor.selection;\n  const {\n    slate\n  } = config.settings;\n  event.preventDefault();\n  event.stopPropagation(); // Store the current list item's path.\n\n  const [, listItemPath] = getCurrentListItem(editor); // Don't allow in first line list item Check if the current list item is first\n  // in its parent\n\n  if ( // If the selection starts at the beginning of a root-level block node\n  anchor.path.slice(1).reduce((acc, n) => acc + n, 0) === 0 || // or the current list item is the first in the list that contains it\n  listItemPath[listItemPath.length - 1] === 0) {\n    // Mark the event as handled and do nothing.\n    return true;\n  } // Take the Node in the selection that is LI and is farthest-from-root.\n\n\n  const [match] = Editor.nodes(editor, {\n    match: n => n.type === slate.listItemType,\n    // Explanation of the three modes:\n    // * 'all' - take all the nodes from the root Editor node to the selected\n    //   leaf Text node\n    // * 'highest' - take the root Editor node (if there is a selection, in case\n    //   no `at` option is given)\n    // * 'lowest' - take the farthest-from-root selected leaf Text node\n    // (Replace the \"leaf Text node\" expressions in the above list with\n    // whatever matching function you use.)\n    mode: 'lowest'\n  }); // Get the Path of the above-found Node.\n\n  const [, at] = match; // Get the Path that represents the previous sibling node of the Path above.\n  // TODO: handle the exception that this can throw, when `at` has the last\n  // number in it a `0`. This case is possible because the condition above that\n  // uses the Array.prototype.reduce method checks only the sum but the last 2\n  // items can be [2, 0], their sum is 2 but the last item is 0, so the\n  // exception is thrown.\n\n  const to = Path.previous(at); // If the Path does not exist, mark the event as handled and do nothing.\n\n  if (!Node.has(editor, to)) return true; // Move the Node in the selection that is LI and is farthest-from-root to the\n  // existing Path just before its current location.\n\n  Transforms.moveNodes(editor, {\n    at,\n    to\n  }); // Mark the event as handled.\n\n  return true;\n}\n/**\n * Move down a list with with `Ctrl+Down`. (The Down key is supposed here to be\n * pressed.)\n * @param {Editor} Editor\n * @param {KeyboardEvent} event\n */\n\nexport function moveListItemDown(_ref2) {\n  let {\n    editor,\n    event\n  } = _ref2;\n  // If Ctrl is not pressed or the cursor is not in a list, do nothing.\n  if (!event.ctrlKey) return;\n  if (!isCursorInList(editor)) return false; // Else\n\n  const {\n    slate\n  } = config.settings; // Take the Node in the selection that is LI and is farthest-from-root.\n\n  const [match] = Editor.nodes(editor, {\n    // Explanation of the three modes:\n    // * 'all' - take all the nodes from the root Editor node to the selected\n    //   leaf Text node\n    // * 'highest' - take the root Editor node (if there is a selection, in case\n    //   no `at` option is given)\n    // * 'lowest' - take the farthest-from-root selected leaf Text node\n    // (Replace the \"leaf Text node\" expressions in the above list with\n    // whatever matching function you use.)\n    match: n => n.type === slate.listItemType,\n    reverse: true,\n    mode: 'lowest'\n  }); // Get the Path of the above-found Node.\n\n  const [, at] = match; // Get the Path that represents the next sibling node of the Path above.\n\n  const to = Path.next(at); // Prevent the default behavior of Slate, React and DOM and stop the\n  // propagation of this event.\n\n  event.preventDefault();\n  event.stopPropagation(); // If the Path does not exist, mark the event as handled and do nothing.\n\n  if (!Node.has(editor, to)) return true; // Move the Node in the selection that is LI and is farthest-from-root to the\n  // existing Path just after its current location, if there is a place for it\n  // at the same depth.\n\n  Transforms.moveNodes(editor, {\n    at,\n    to\n  }); // Mark the event as handled.\n\n  return true;\n}","map":{"version":3,"names":["Editor","Path","Transforms","Node","isCursorInList","getCurrentListItem","config","moveListItemUp","editor","event","ctrlKey","anchor","selection","slate","settings","preventDefault","stopPropagation","listItemPath","path","slice","reduce","acc","n","length","match","nodes","type","listItemType","mode","at","to","previous","has","moveNodes","moveListItemDown","reverse","next"],"sources":["/home/jakob/workspace/training-project/node_modules/@plone/volto/packages/volto-slate/src/blocks/Text/keyboard/moveListItems.js"],"sourcesContent":["import { Editor, Path, Transforms, Node } from 'slate';\nimport { isCursorInList, getCurrentListItem } from '@plone/volto-slate/utils';\nimport config from '@plone/volto/registry';\n\n/**\n * Move up a list with with `Ctrl+Up`. (The Up key is supposed here to be\n * pressed.)\n * @param {Editor} Editor\n * @param {KeyboardEvent} event\n */\nexport function moveListItemUp({ editor, event }) {\n  // If Ctrl is not pressed or the cursor is not in a list, do nothing.\n  if (!(event.ctrlKey && isCursorInList(editor))) return;\n\n  // Else prevent the default behavior of Slate, React and DOM and stop the\n  // propagation of this event.\n  const { anchor } = editor.selection;\n  const { slate } = config.settings;\n\n  event.preventDefault();\n  event.stopPropagation();\n\n  // Store the current list item's path.\n  const [, listItemPath] = getCurrentListItem(editor);\n\n  // Don't allow in first line list item Check if the current list item is first\n  // in its parent\n  if (\n    // If the selection starts at the beginning of a root-level block node\n    anchor.path.slice(1).reduce((acc, n) => acc + n, 0) === 0 ||\n    // or the current list item is the first in the list that contains it\n    listItemPath[listItemPath.length - 1] === 0\n  ) {\n    // Mark the event as handled and do nothing.\n    return true;\n  }\n\n  // Take the Node in the selection that is LI and is farthest-from-root.\n  const [match] = Editor.nodes(editor, {\n    match: (n) => n.type === slate.listItemType,\n    // Explanation of the three modes:\n    // * 'all' - take all the nodes from the root Editor node to the selected\n    //   leaf Text node\n    // * 'highest' - take the root Editor node (if there is a selection, in case\n    //   no `at` option is given)\n    // * 'lowest' - take the farthest-from-root selected leaf Text node\n    // (Replace the \"leaf Text node\" expressions in the above list with\n    // whatever matching function you use.)\n    mode: 'lowest',\n  });\n\n  // Get the Path of the above-found Node.\n  const [, at] = match;\n\n  // Get the Path that represents the previous sibling node of the Path above.\n  // TODO: handle the exception that this can throw, when `at` has the last\n  // number in it a `0`. This case is possible because the condition above that\n  // uses the Array.prototype.reduce method checks only the sum but the last 2\n  // items can be [2, 0], their sum is 2 but the last item is 0, so the\n  // exception is thrown.\n  const to = Path.previous(at);\n\n  // If the Path does not exist, mark the event as handled and do nothing.\n  if (!Node.has(editor, to)) return true;\n\n  // Move the Node in the selection that is LI and is farthest-from-root to the\n  // existing Path just before its current location.\n  Transforms.moveNodes(editor, { at, to });\n\n  // Mark the event as handled.\n  return true;\n}\n\n/**\n * Move down a list with with `Ctrl+Down`. (The Down key is supposed here to be\n * pressed.)\n * @param {Editor} Editor\n * @param {KeyboardEvent} event\n */\nexport function moveListItemDown({ editor, event }) {\n  // If Ctrl is not pressed or the cursor is not in a list, do nothing.\n  if (!event.ctrlKey) return;\n  if (!isCursorInList(editor)) return false;\n\n  // Else\n  const { slate } = config.settings;\n\n  // Take the Node in the selection that is LI and is farthest-from-root.\n  const [match] = Editor.nodes(editor, {\n    // Explanation of the three modes:\n    // * 'all' - take all the nodes from the root Editor node to the selected\n    //   leaf Text node\n    // * 'highest' - take the root Editor node (if there is a selection, in case\n    //   no `at` option is given)\n    // * 'lowest' - take the farthest-from-root selected leaf Text node\n    // (Replace the \"leaf Text node\" expressions in the above list with\n    // whatever matching function you use.)\n    match: (n) => n.type === slate.listItemType,\n    reverse: true,\n    mode: 'lowest',\n  });\n\n  // Get the Path of the above-found Node.\n  const [, at] = match;\n\n  // Get the Path that represents the next sibling node of the Path above.\n  const to = Path.next(at);\n\n  // Prevent the default behavior of Slate, React and DOM and stop the\n  // propagation of this event.\n  event.preventDefault();\n  event.stopPropagation();\n\n  // If the Path does not exist, mark the event as handled and do nothing.\n  if (!Node.has(editor, to)) return true;\n\n  // Move the Node in the selection that is LI and is farthest-from-root to the\n  // existing Path just after its current location, if there is a place for it\n  // at the same depth.\n  Transforms.moveNodes(editor, { at, to });\n\n  // Mark the event as handled.\n  return true;\n}\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module"}