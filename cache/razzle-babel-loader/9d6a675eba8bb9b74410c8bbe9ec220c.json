{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { jsx } from 'slate-hyperscript';\nimport { Text } from 'slate';\nimport { isWhitespace } from '@plone/volto-slate/utils';\nimport { TD, TH, COMMENT, ELEMENT_NODE, INLINE_ELEMENTS, TEXT_NODE } from '../constants';\n\nconst isInline = node => node && (node.nodeType === TEXT_NODE || INLINE_ELEMENTS.includes(node.nodeName));\n/**\n * Deserialize to an object or an Array.\n *\n * This returns a Slate Node or null.\n */\n\n\nexport const deserialize = (editor, el) => {\n  // console.log('deserialize el:', el);\n  const {\n    htmlTagsToSlate\n  } = editor; // console.log('des:', el.nodeType, el);\n\n  if (el.nodeType === COMMENT) {\n    return null;\n  } else if (el.nodeType === TEXT_NODE) {\n    // instead of === '\\n' we use isWhitespace for when deserializing tables\n    // from Calc and other similar cases\n    // console.log('maybe whitespace', {\n    //   text: `-${el.textContent}-`,\n    //   prev: el.previousSibling,\n    //   next: el.nextSibling,\n    //   isPrev: isInline(el.previousSibling),\n    //   isNext: isInline(el.nextSibling),\n    //   prevName: el.previousSibling && el.previousSibling.nodeName,\n    //   nextName: el.nextSibling && el.nextSibling.nodeName,\n    // });\n    if (isWhitespace(el.textContent)) {\n      // console.log({\n      //   text: `-${el.textContent}-`,\n      //   prev: el.previousSibling,\n      //   next: el.nextSibling,\n      //   isPrev: isInline(el.previousSibling),\n      //   isNext: isInline(el.nextSibling),\n      //   prevName: el.previousSibling && el.previousSibling.nodeName,\n      //   nextName: el.nextSibling && el.nextSibling.nodeName,\n      // });\n      // if it's empty text between 2 tags, it should be ignored\n      return isInline(el.previousSibling) || isInline(el.nextSibling) ? {\n        text: el.textContent\n      } // perceptually multiple whitespace render as a single space\n      : null;\n    }\n\n    return {\n      text: el.textContent.replace(/\\n$/g, ' ').replace(/\\n/g, ' ').replace(/\\t/g, '')\n    };\n  } else if (el.nodeType !== ELEMENT_NODE) {\n    return null;\n  } else if (el.nodeName === 'BR') {\n    // TODO: is handling <br> like this ok in all cases ?\n    return {\n      text: '\\n'\n    };\n  }\n\n  if (el.getAttribute('data-slate-data')) {\n    return typeDeserialize(editor, el);\n  }\n\n  const {\n    nodeName\n  } = el;\n\n  if (htmlTagsToSlate[nodeName]) {\n    return htmlTagsToSlate[nodeName](editor, el);\n  }\n\n  return deserializeChildren(el, editor); // fallback deserializer\n};\nexport const typeDeserialize = (editor, el) => {\n  const jsData = el.getAttribute('data-slate-data');\n  const {\n    type,\n    data\n  } = JSON.parse(jsData);\n  return jsx('element', {\n    type,\n    data\n  }, deserializeChildren(el, editor));\n};\nexport const deserializeChildren = (parent, editor) => Array.from(parent.childNodes).map(el => deserialize(editor, el)).flat();\nexport const blockTagDeserializer = tagname => (editor, el) => {\n  // if (tagname === 'h2') debugger;\n  let children = deserializeChildren(el, editor).filter(n => n !== null);\n\n  if ([TD, TH].includes(tagname) && children.length > 0 && typeof children[0] === 'string') {\n    // TODO: should here be handled the cases when there are more strings in\n    // `children` or when there are besides strings other types of nodes too?\n    const p = {\n      type: 'div',\n      children: [{\n        text: ''\n      }]\n    };\n    p.children[0].text = children[0];\n    children = [p];\n  } // normalizes block elements so that they're never empty\n  // Avoids a hard crash from the Slate editor\n\n\n  const hasValidChildren = children.length && children.find(c => !!c);\n\n  if (!hasValidChildren) {\n    children = [{\n      text: ''\n    }];\n  }\n\n  return jsx('element', {\n    type: tagname\n  }, children);\n};\nexport const bodyTagDeserializer = (editor, el) => {\n  return jsx('fragment', {}, deserializeChildren(el, editor));\n};\nexport const inlineTagDeserializer = attrs => (editor, el) => {\n  return deserializeChildren(el, editor).map(child => {\n    const res = Text.isText(child) || typeof child === 'string' ? jsx('text', attrs, child) : _objectSpread(_objectSpread({}, child), {}, {\n      attrs // pass the inline attrs as separate object\n\n    });\n    return res;\n  });\n};\nexport const spanTagDeserializer = (editor, el) => {\n  const style = el.getAttribute('style') || '';\n  let children = el.childNodes;\n\n  if ( // handle formatting from OpenOffice\n  children.length === 1 && children[0].nodeType === 3 && children[0].textContent === '\\n') {\n    return jsx('text', {}, ' ');\n  }\n\n  children = deserializeChildren(el, editor); // whitespace is replaced by deserialize() with null;\n\n  children = children.map(c => c === null ? ' ' : c); // TODO: handle sub/sup as <sub> and <sup>\n  // Handle Google Docs' <sub> formatting\n\n  if (style.replace(/\\s/g, '').indexOf('vertical-align:sub') > -1) {\n    const attrs = {\n      sub: true\n    };\n    return children.map(child => {\n      return jsx('text', attrs, child);\n    });\n  } // Handle Google Docs' <sup> formatting\n\n\n  if (style.replace(/\\s/g, '').indexOf('vertical-align:super') > -1) {\n    const attrs = {\n      sup: true\n    };\n    return children.map(child => {\n      return jsx('text', attrs, child);\n    });\n  }\n\n  const res = children.find(c => typeof c !== 'string') ? children : jsx('text', {}, children);\n  return res;\n};\nexport const bTagDeserializer = (editor, el) => {\n  // Google Docs does weird things with <b> tag\n  return (el.getAttribute('id') || '').indexOf('docs-internal-guid') > -1 ? deserializeChildren(el, editor) : jsx('element', {\n    type: 'b'\n  }, deserializeChildren(el, editor));\n};\nexport const codeTagDeserializer = (editor, el) => {\n  return jsx('element', {\n    type: 'code'\n  }, el.textContent);\n};\nexport const preTagDeserializer = (editor, el) => {\n  // Based on Slate example implementation. Replaces <pre> tags with <code>.\n  // Comment: I don't know how good of an idea is this. I'd rather have two\n  // separate formats: \"preserve whitespace\" and \"code\". This feels like a hack\n  const {\n    nodeName\n  } = el;\n  let parent = el;\n\n  if (el.childNodes[0] && el.childNodes[0].nodeName === 'CODE') {\n    parent = el.childNodes[0];\n    return codeTagDeserializer(editor, parent);\n  }\n\n  return blockTagDeserializer(nodeName)(editor, parent);\n};\nexport default deserialize;","map":{"version":3,"names":["jsx","Text","isWhitespace","TD","TH","COMMENT","ELEMENT_NODE","INLINE_ELEMENTS","TEXT_NODE","isInline","node","nodeType","includes","nodeName","deserialize","editor","el","htmlTagsToSlate","textContent","previousSibling","nextSibling","text","replace","getAttribute","typeDeserialize","deserializeChildren","jsData","type","data","JSON","parse","parent","Array","from","childNodes","map","flat","blockTagDeserializer","tagname","children","filter","n","length","p","hasValidChildren","find","c","bodyTagDeserializer","inlineTagDeserializer","attrs","child","res","isText","spanTagDeserializer","style","indexOf","sub","sup","bTagDeserializer","codeTagDeserializer","preTagDeserializer"],"sources":["/home/jakob/workspace/training-project/node_modules/@plone/volto/packages/volto-slate/src/editor/deserialize.js"],"sourcesContent":["import { jsx } from 'slate-hyperscript';\nimport { Text } from 'slate';\nimport { isWhitespace } from '@plone/volto-slate/utils';\nimport {\n  TD,\n  TH,\n  COMMENT,\n  ELEMENT_NODE,\n  INLINE_ELEMENTS,\n  TEXT_NODE,\n} from '../constants';\n\nconst isInline = (node) =>\n  node &&\n  (node.nodeType === TEXT_NODE || INLINE_ELEMENTS.includes(node.nodeName));\n\n/**\n * Deserialize to an object or an Array.\n *\n * This returns a Slate Node or null.\n */\nexport const deserialize = (editor, el) => {\n  // console.log('deserialize el:', el);\n  const { htmlTagsToSlate } = editor;\n\n  // console.log('des:', el.nodeType, el);\n  if (el.nodeType === COMMENT) {\n    return null;\n  } else if (el.nodeType === TEXT_NODE) {\n    // instead of === '\\n' we use isWhitespace for when deserializing tables\n    // from Calc and other similar cases\n\n    // console.log('maybe whitespace', {\n    //   text: `-${el.textContent}-`,\n    //   prev: el.previousSibling,\n    //   next: el.nextSibling,\n    //   isPrev: isInline(el.previousSibling),\n    //   isNext: isInline(el.nextSibling),\n    //   prevName: el.previousSibling && el.previousSibling.nodeName,\n    //   nextName: el.nextSibling && el.nextSibling.nodeName,\n    // });\n\n    if (isWhitespace(el.textContent)) {\n      // console.log({\n      //   text: `-${el.textContent}-`,\n      //   prev: el.previousSibling,\n      //   next: el.nextSibling,\n      //   isPrev: isInline(el.previousSibling),\n      //   isNext: isInline(el.nextSibling),\n      //   prevName: el.previousSibling && el.previousSibling.nodeName,\n      //   nextName: el.nextSibling && el.nextSibling.nodeName,\n      // });\n      // if it's empty text between 2 tags, it should be ignored\n      return isInline(el.previousSibling) || isInline(el.nextSibling)\n        ? { text: el.textContent } // perceptually multiple whitespace render as a single space\n        : null;\n    }\n    return {\n      text: el.textContent\n        .replace(/\\n$/g, ' ')\n        .replace(/\\n/g, ' ')\n        .replace(/\\t/g, ''),\n    };\n  } else if (el.nodeType !== ELEMENT_NODE) {\n    return null;\n  } else if (el.nodeName === 'BR') {\n    // TODO: is handling <br> like this ok in all cases ?\n    return { text: '\\n' };\n  }\n\n  if (el.getAttribute('data-slate-data')) {\n    return typeDeserialize(editor, el);\n  }\n\n  const { nodeName } = el;\n\n  if (htmlTagsToSlate[nodeName]) {\n    return htmlTagsToSlate[nodeName](editor, el);\n  }\n\n  return deserializeChildren(el, editor); // fallback deserializer\n};\n\nexport const typeDeserialize = (editor, el) => {\n  const jsData = el.getAttribute('data-slate-data');\n  const { type, data } = JSON.parse(jsData);\n  return jsx('element', { type, data }, deserializeChildren(el, editor));\n};\n\nexport const deserializeChildren = (parent, editor) =>\n  Array.from(parent.childNodes)\n    .map((el) => deserialize(editor, el))\n    .flat();\n\nexport const blockTagDeserializer = (tagname) => (editor, el) => {\n  // if (tagname === 'h2') debugger;\n  let children = deserializeChildren(el, editor).filter((n) => n !== null);\n\n  if (\n    [TD, TH].includes(tagname) &&\n    children.length > 0 &&\n    typeof children[0] === 'string'\n  ) {\n    // TODO: should here be handled the cases when there are more strings in\n    // `children` or when there are besides strings other types of nodes too?\n    const p = { type: 'div', children: [{ text: '' }] };\n    p.children[0].text = children[0];\n    children = [p];\n  }\n\n  // normalizes block elements so that they're never empty\n  // Avoids a hard crash from the Slate editor\n  const hasValidChildren = children.length && children.find((c) => !!c);\n  if (!hasValidChildren) {\n    children = [{ text: '' }];\n  }\n\n  return jsx('element', { type: tagname }, children);\n};\n\nexport const bodyTagDeserializer = (editor, el) => {\n  return jsx('fragment', {}, deserializeChildren(el, editor));\n};\n\nexport const inlineTagDeserializer = (attrs) => (editor, el) => {\n  return deserializeChildren(el, editor).map((child) => {\n    const res =\n      Text.isText(child) || typeof child === 'string'\n        ? jsx('text', attrs, child)\n        : {\n            ...child,\n            attrs, // pass the inline attrs as separate object\n          };\n    return res;\n  });\n};\n\nexport const spanTagDeserializer = (editor, el) => {\n  const style = el.getAttribute('style') || '';\n  let children = el.childNodes;\n  if (\n    // handle formatting from OpenOffice\n    children.length === 1 &&\n    children[0].nodeType === 3 &&\n    children[0].textContent === '\\n'\n  ) {\n    return jsx('text', {}, ' ');\n  }\n  children = deserializeChildren(el, editor);\n\n  // whitespace is replaced by deserialize() with null;\n  children = children.map((c) => (c === null ? ' ' : c));\n\n  // TODO: handle sub/sup as <sub> and <sup>\n  // Handle Google Docs' <sub> formatting\n  if (style.replace(/\\s/g, '').indexOf('vertical-align:sub') > -1) {\n    const attrs = { sub: true };\n    return children.map((child) => {\n      return jsx('text', attrs, child);\n    });\n  }\n\n  // Handle Google Docs' <sup> formatting\n  if (style.replace(/\\s/g, '').indexOf('vertical-align:super') > -1) {\n    const attrs = { sup: true };\n    return children.map((child) => {\n      return jsx('text', attrs, child);\n    });\n  }\n\n  const res = children.find((c) => typeof c !== 'string')\n    ? children\n    : jsx('text', {}, children);\n  return res;\n};\n\nexport const bTagDeserializer = (editor, el) => {\n  // Google Docs does weird things with <b> tag\n  return (el.getAttribute('id') || '').indexOf('docs-internal-guid') > -1\n    ? deserializeChildren(el, editor)\n    : jsx('element', { type: 'b' }, deserializeChildren(el, editor));\n};\n\nexport const codeTagDeserializer = (editor, el) => {\n  return jsx('element', { type: 'code' }, el.textContent);\n};\n\nexport const preTagDeserializer = (editor, el) => {\n  // Based on Slate example implementation. Replaces <pre> tags with <code>.\n  // Comment: I don't know how good of an idea is this. I'd rather have two\n  // separate formats: \"preserve whitespace\" and \"code\". This feels like a hack\n  const { nodeName } = el;\n  let parent = el;\n\n  if (el.childNodes[0] && el.childNodes[0].nodeName === 'CODE') {\n    parent = el.childNodes[0];\n    return codeTagDeserializer(editor, parent);\n  }\n\n  return blockTagDeserializer(nodeName)(editor, parent);\n};\n\nexport default deserialize;\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module"}