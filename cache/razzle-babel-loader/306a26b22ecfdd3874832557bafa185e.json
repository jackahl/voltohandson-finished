{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React from 'react';\nimport { Editor, Transforms, Range, Text } from 'slate';\nexport function isMarkActive(editor, format) {\n  // TODO: this implementation is not ok. LibreOffice Writer only shows\n  // mark button as active if the mark is applied to the entire selected range\n  // Here, it seems, the mark doesn't need to cover the entire selection,\n  // which is wrong\n  let marks;\n\n  try {\n    marks = Editor.marks(editor);\n  } catch (ex) {\n    // bug in Slate, recently appears only in Cypress context, more exactly when I press Enter inside a numbered list first item to produce a split (resulting two list items) (not sure if manually inside the Cypress browser but automatically it surely appears)\n    // if (\n    //   ex.message ===\n    //   'Cannot get the leaf node at path [0,0] because it refers to a non-leaf node: [object Object]' // also with [0,1]\n    // ) {\n    marks = null; // } else {\n    //   throw ex;\n    // }\n  }\n\n  return marks ? marks[format] === true : false;\n}\n\nfunction addMark(editor, key, value) {\n  const {\n    selection\n  } = editor;\n\n  if (selection) {\n    if (Range.isExpanded(selection)) {\n      Transforms.setNodes(editor, {\n        [key]: value\n      }, {\n        match: node => {\n          // console.log('node', node);\n          return Text.isText(node) || editor.isVoid(node);\n        },\n        split: true\n      });\n    } else {\n      const marks = _objectSpread(_objectSpread({}, Editor.marks(editor) || {}), {}, {\n        [key]: value\n      });\n\n      editor.marks = marks;\n      editor.onChange();\n    }\n  }\n}\n\nexport function toggleMark(editor, format) {\n  const isActive = isMarkActive(editor, format);\n\n  if (isActive) {\n    Editor.removeMark(editor, format);\n  } else {\n    // don't apply marks inside inlines (such as footnote) because\n    // that splits the footnote into multiple footnotes\n    addMark(editor, format, true); // if (isSelectionInline(editor)) {\n    //   addMark(editor, format, true);\n    // }\n  }\n}\n/*\n * Replaces inline text elements with a wrapper result:\n *\n * Leaves are wrapped and non-leaves are cloned. Empty leaves are removed.\n */\n\nexport function wrapInlineMarkupText(children, wrapper) {\n  if (typeof children === 'string') {\n    return children ? wrapper(children) : null;\n  } // TODO: find the deepest child that needs to be replaced.\n  // TODO: note: this might trigger warnings about keys\n\n\n  if (Array.isArray(children)) {\n    return children.map(child => {\n      if (typeof child === 'string' && child.length >= 1) {\n        return wrapper(children);\n      }\n\n      if (typeof child === 'string' && child.length === 0) {\n        return null;\n      }\n\n      return /*#__PURE__*/React.cloneElement(child, child.props, wrapInlineMarkupText(child.props.children, wrapper));\n    }).filter(child => !!child);\n  }\n\n  return /*#__PURE__*/React.cloneElement(children, children.props, wrapInlineMarkupText(children.props.children, wrapper));\n}","map":{"version":3,"names":["React","Editor","Transforms","Range","Text","isMarkActive","editor","format","marks","ex","addMark","key","value","selection","isExpanded","setNodes","match","node","isText","isVoid","split","onChange","toggleMark","isActive","removeMark","wrapInlineMarkupText","children","wrapper","Array","isArray","map","child","length","cloneElement","props","filter"],"sources":["/home/jakob/workspace/training-project/node_modules/@plone/volto/packages/volto-slate/src/utils/marks.js"],"sourcesContent":["import React from 'react';\nimport { Editor, Transforms, Range, Text } from 'slate';\n\nexport function isMarkActive(editor, format) {\n  // TODO: this implementation is not ok. LibreOffice Writer only shows\n  // mark button as active if the mark is applied to the entire selected range\n  // Here, it seems, the mark doesn't need to cover the entire selection,\n  // which is wrong\n  let marks;\n  try {\n    marks = Editor.marks(editor);\n  } catch (ex) {\n    // bug in Slate, recently appears only in Cypress context, more exactly when I press Enter inside a numbered list first item to produce a split (resulting two list items) (not sure if manually inside the Cypress browser but automatically it surely appears)\n    // if (\n    //   ex.message ===\n    //   'Cannot get the leaf node at path [0,0] because it refers to a non-leaf node: [object Object]' // also with [0,1]\n    // ) {\n    marks = null;\n    // } else {\n    //   throw ex;\n    // }\n  }\n  return marks ? marks[format] === true : false;\n}\n\nfunction addMark(editor, key, value) {\n  const { selection } = editor;\n\n  if (selection) {\n    if (Range.isExpanded(selection)) {\n      Transforms.setNodes(\n        editor,\n        { [key]: value },\n        {\n          match: (node) => {\n            // console.log('node', node);\n            return Text.isText(node) || editor.isVoid(node);\n          },\n          split: true,\n        },\n      );\n    } else {\n      const marks = {\n        ...(Editor.marks(editor) || {}),\n        [key]: value,\n      };\n\n      editor.marks = marks;\n      editor.onChange();\n    }\n  }\n}\n\nexport function toggleMark(editor, format) {\n  const isActive = isMarkActive(editor, format);\n\n  if (isActive) {\n    Editor.removeMark(editor, format);\n  } else {\n    // don't apply marks inside inlines (such as footnote) because\n    // that splits the footnote into multiple footnotes\n    addMark(editor, format, true);\n    // if (isSelectionInline(editor)) {\n    //   addMark(editor, format, true);\n    // }\n  }\n}\n\n/*\n * Replaces inline text elements with a wrapper result:\n *\n * Leaves are wrapped and non-leaves are cloned. Empty leaves are removed.\n */\nexport function wrapInlineMarkupText(children, wrapper) {\n  if (typeof children === 'string') {\n    return children ? wrapper(children) : null;\n  }\n\n  // TODO: find the deepest child that needs to be replaced.\n  // TODO: note: this might trigger warnings about keys\n  if (Array.isArray(children)) {\n    return children\n      .map((child) => {\n        if (typeof child === 'string' && child.length >= 1) {\n          return wrapper(children);\n        }\n        if (typeof child === 'string' && child.length === 0) {\n          return null;\n        }\n        return React.cloneElement(\n          child,\n          child.props,\n          wrapInlineMarkupText(child.props.children, wrapper),\n        );\n      })\n      .filter((child) => !!child);\n  }\n\n  return React.cloneElement(\n    children,\n    children.props,\n    wrapInlineMarkupText(children.props.children, wrapper),\n  );\n}\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module"}