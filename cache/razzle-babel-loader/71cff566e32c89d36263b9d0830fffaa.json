{"ast":null,"code":"import { v4 as uuid } from 'uuid';\nimport { Editor, Transforms } from 'slate';\nimport { TABLE, THEAD, TBODY, TFOOT, TD, TH, TR } from '@plone/volto-slate/constants';\n/**\n * @param {Array} rows The array of rows that almost completely defines a\n * `table`-typed block.\n * @returns {Array} A tuple `[id, block]` where `id` is the new block's ID and\n * the `block` is all the block's data.\n */\n\nexport function syncCreateTableBlock(rows) {\n  const id = uuid();\n  const block = {\n    '@type': 'table',\n    table: {\n      rows\n    }\n  };\n  return [id, block];\n}\n/**\n * @param {Editor} editor The Slate Editor from which to extract tables.\n * @param {PathRef} pathRef Has the current value a `Path` so that the search is\n * done just inside nodes in that `Path`.\n * @returns Extracts tables from a Slate `Editor` into an array of detached\n * `table` blocks.\n */\n\nexport const extractTables = (editor, pathRef) => {\n  const tableNodes = Array.from(Editor.nodes(editor, {\n    at: pathRef.current,\n    match: node => node.type === TABLE\n  }));\n  const tables = tableNodes.map(([node]) => extractVoltoTable(node));\n  Transforms.removeNodes(editor, {\n    at: pathRef.current,\n    match: node => node.type === TABLE\n  });\n  return tables.map(el => syncCreateTableBlock(el));\n};\n/**\n * @param {Node[]} fragment A Slate document fragment.\n * @returns {Array} An array of rows in the format requested by `table`\n * blocks.\n */\n\nfunction collectRowsFrom(fragment) {\n  let rows = [];\n  fragment.children.forEach(y => {\n    if (y.type === TR) {\n      let row = {\n        key: uuid(),\n        cells: []\n      };\n      y.children.forEach(z => {\n        let val = JSON.parse(JSON.stringify(z.children));\n\n        if (z.type === TD) {\n          row.cells.push({\n            key: uuid(),\n            type: 'data',\n            value: val\n          });\n        } else if (z.type === TH) {\n          row.cells.push({\n            key: uuid(),\n            type: 'header',\n            value: val\n          });\n        }\n      });\n      rows.push(row);\n    }\n  });\n  return rows;\n}\n/**\n * @param {HTMLElement} el The <table> element from which to extract rows.\n * @returns {Array} A rows array that contains rows in the format required by\n * `table` blocks.\n */\n\n\nfunction extractVoltoTable(el) {\n  let thead = [],\n      tfoot = [],\n      tbody = [];\n  el.children.forEach(fragment => {\n    if (fragment.type === THEAD) {\n      // not supported by View fully, so prepend this to tbody below\n      thead = collectRowsFrom(fragment);\n    } else if (fragment.type === TBODY) {\n      tbody = collectRowsFrom(fragment);\n    } else if (fragment.type === TFOOT) {\n      // not supported by View fully, so append this to tbody below\n      tfoot = collectRowsFrom(fragment);\n    }\n  });\n  const rows = [...thead, ...tbody, ...tfoot];\n  return rows;\n}","map":{"version":3,"names":["v4","uuid","Editor","Transforms","TABLE","THEAD","TBODY","TFOOT","TD","TH","TR","syncCreateTableBlock","rows","id","block","table","extractTables","editor","pathRef","tableNodes","Array","from","nodes","at","current","match","node","type","tables","map","extractVoltoTable","removeNodes","el","collectRowsFrom","fragment","children","forEach","y","row","key","cells","z","val","JSON","parse","stringify","push","value","thead","tfoot","tbody"],"sources":["/home/jakob/workspace/training-project/node_modules/@plone/volto/packages/volto-slate/src/blocks/Table/deconstruct.js"],"sourcesContent":["import { v4 as uuid } from 'uuid';\nimport { Editor, Transforms } from 'slate';\nimport {\n  TABLE,\n  THEAD,\n  TBODY,\n  TFOOT,\n  TD,\n  TH,\n  TR,\n} from '@plone/volto-slate/constants';\n\n/**\n * @param {Array} rows The array of rows that almost completely defines a\n * `table`-typed block.\n * @returns {Array} A tuple `[id, block]` where `id` is the new block's ID and\n * the `block` is all the block's data.\n */\nexport function syncCreateTableBlock(rows) {\n  const id = uuid();\n  const block = {\n    '@type': 'table',\n    table: {\n      rows,\n    },\n  };\n  return [id, block];\n}\n\n/**\n * @param {Editor} editor The Slate Editor from which to extract tables.\n * @param {PathRef} pathRef Has the current value a `Path` so that the search is\n * done just inside nodes in that `Path`.\n * @returns Extracts tables from a Slate `Editor` into an array of detached\n * `table` blocks.\n */\nexport const extractTables = (editor, pathRef) => {\n  const tableNodes = Array.from(\n    Editor.nodes(editor, {\n      at: pathRef.current,\n      match: (node) => node.type === TABLE,\n    }),\n  );\n  const tables = tableNodes.map(([node]) => extractVoltoTable(node));\n\n  Transforms.removeNodes(editor, {\n    at: pathRef.current,\n    match: (node) => node.type === TABLE,\n  });\n\n  return tables.map((el) => syncCreateTableBlock(el));\n};\n\n/**\n * @param {Node[]} fragment A Slate document fragment.\n * @returns {Array} An array of rows in the format requested by `table`\n * blocks.\n */\nfunction collectRowsFrom(fragment) {\n  let rows = [];\n  fragment.children.forEach((y) => {\n    if (y.type === TR) {\n      let row = { key: uuid(), cells: [] };\n\n      y.children.forEach((z) => {\n        let val = JSON.parse(JSON.stringify(z.children));\n        if (z.type === TD) {\n          row.cells.push({\n            key: uuid(),\n            type: 'data',\n            value: val,\n          });\n        } else if (z.type === TH) {\n          row.cells.push({\n            key: uuid(),\n            type: 'header',\n            value: val,\n          });\n        }\n      });\n\n      rows.push(row);\n    }\n  });\n  return rows;\n}\n\n/**\n * @param {HTMLElement} el The <table> element from which to extract rows.\n * @returns {Array} A rows array that contains rows in the format required by\n * `table` blocks.\n */\nfunction extractVoltoTable(el) {\n  let thead = [],\n    tfoot = [],\n    tbody = [];\n\n  el.children.forEach((fragment) => {\n    if (fragment.type === THEAD) {\n      // not supported by View fully, so prepend this to tbody below\n      thead = collectRowsFrom(fragment);\n    } else if (fragment.type === TBODY) {\n      tbody = collectRowsFrom(fragment);\n    } else if (fragment.type === TFOOT) {\n      // not supported by View fully, so append this to tbody below\n      tfoot = collectRowsFrom(fragment);\n    }\n  });\n\n  const rows = [...thead, ...tbody, ...tfoot];\n\n  return rows;\n}\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module"}