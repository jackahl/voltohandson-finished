{"ast":null,"code":"import { Editor, Transforms, Node } from 'slate'; // Range,\n\n/**\n * @description Creates or updates an existing $elementType. It also takes care\n * of the saved selection and uses PathRef.\n *\n * @param {Editor} editor The Slate editor for the context\n * @param {object} data Relevant data for this element\n *\n * @returns {boolean} true if an element was possibly inserted, false otherwise\n * (currently we do not check here if the element was already applied to the\n * editor)\n */\n\nexport const _insertElement = elementType => (editor, data) => {\n  if (editor.getSavedSelection()) {\n    const selection = editor.selection || editor.getSavedSelection();\n    const rangeRef = Editor.rangeRef(editor, selection);\n    const res = Array.from(Editor.nodes(editor, {\n      match: n => n.type === elementType,\n      mode: 'highest',\n      at: selection\n    }));\n\n    if (res.length) {\n      const [, path] = res[0];\n      Transforms.setNodes(editor, {\n        data\n      }, {\n        at: path ? path : null,\n        match: path ? n => n.type === elementType : null\n      });\n    } else {\n      Transforms.wrapNodes(editor, {\n        type: elementType,\n        data\n      }, {\n        split: true,\n        at: selection,\n        match: node => {\n          return Node.string(node).length !== 0;\n        }\n      } //,\n      );\n    }\n\n    const sel = JSON.parse(JSON.stringify(rangeRef.current));\n    Transforms.select(editor, sel);\n    editor.setSavedSelection(sel);\n    return true;\n  }\n\n  return false;\n};\n/**\n * Will unwrap a node that has as type the one received or one from an array\n * @param {string|Object[]} elementType - this can be a string or an array of strings\n * @returns {Object|null} - current node\n */\n\nexport const _unwrapElement = elementType => editor => {\n  const selection = editor.selection || editor.getSavedSelection();\n  const ref = Editor.rangeRef(editor, selection);\n  Transforms.select(editor, selection);\n  Transforms.unwrapNodes(editor, {\n    match: n => Array.isArray(elementType) ? elementType.includes(n.type) : n.type === elementType,\n    at: selection\n  });\n  const current = ref.current;\n  ref.unref();\n  return current;\n};\nexport const _isActiveElement = elementType => editor => {\n  const selection = editor.selection || editor.getSavedSelection();\n  let found;\n\n  try {\n    found = Array.from(Editor.nodes(editor, {\n      match: n => n.type === elementType,\n      at: selection\n    }) || []);\n  } catch (e) {\n    // eslint-disable-next-line\n    // console.warn('Error in finding active element', e);\n    return false;\n  }\n\n  if (found.length) return true;\n\n  if (selection) {\n    const {\n      path\n    } = selection.anchor;\n    const isAtStart = selection.anchor.offset === 0 && selection.focus.offset === 0;\n\n    if (isAtStart) {\n      try {\n        found = Editor.previous(editor, {\n          at: path // match: (n) => n.type === MENTION,\n\n        });\n      } catch (ex) {\n        found = [];\n      }\n\n      if (found && found[0] && found[0].type === elementType) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n/**\n * Will look for a node that has as type the one received or one from an array\n * @param {string|Object[]} elementType - this can be a string or an array of strings\n * @returns {Object|null} - found node\n */\n\nexport const _getActiveElement = elementType => function (editor) {\n  let direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'any';\n  const selection = editor.selection || editor.getSavedSelection();\n  let found = [];\n\n  try {\n    found = Array.from(Editor.nodes(editor, {\n      match: n => Array.isArray(elementType) ? elementType.includes(n.type) : n.type === elementType,\n      at: selection\n    }));\n  } catch (e) {\n    return null;\n  }\n\n  if (found.length) return found[0];\n  if (!selection) return null;\n\n  if (direction === 'any' || direction === 'backward') {\n    const {\n      path\n    } = selection.anchor;\n    const isAtStart = selection.anchor.offset === 0 && selection.focus.offset === 0;\n\n    if (isAtStart) {\n      let found;\n\n      try {\n        found = Editor.previous(editor, {\n          at: path\n        });\n      } catch (ex) {\n        // eslint-disable-next-line no-console\n        console.warn('Unable to find previous node', editor, path);\n        return;\n      }\n\n      if (found && found[0] && found[0].type === elementType) {\n        if (Array.isArray(elementType) && elementType.includes(found[0].type) || found[0].type === elementType) {\n          return found;\n        }\n      } else {\n        return null;\n      }\n    }\n  }\n\n  if (direction === 'any' || direction === 'forward') {\n    const {\n      path\n    } = selection.anchor;\n    const isAtStart = selection.anchor.offset === 0 && selection.focus.offset === 0;\n\n    if (isAtStart) {\n      let found;\n\n      try {\n        found = Editor.next(editor, {\n          at: path\n        });\n      } catch (e) {\n        // eslint-disable-next-line\n        console.warn('Unable to find next node', editor, path);\n        return;\n      }\n\n      if (found && found[0] && found[0].type === elementType) {\n        if (Array.isArray(elementType) && elementType.includes(found[0].type) || found[0].type === elementType) {\n          return found;\n        }\n      } else {\n        return null;\n      }\n    }\n  }\n\n  return null;\n};","map":{"version":3,"names":["Editor","Transforms","Node","_insertElement","elementType","editor","data","getSavedSelection","selection","rangeRef","res","Array","from","nodes","match","n","type","mode","at","length","path","setNodes","wrapNodes","split","node","string","sel","JSON","parse","stringify","current","select","setSavedSelection","_unwrapElement","ref","unwrapNodes","isArray","includes","unref","_isActiveElement","found","e","anchor","isAtStart","offset","focus","previous","ex","_getActiveElement","direction","console","warn","next"],"sources":["/home/jakob/workspace/training-project/node_modules/@plone/volto/packages/volto-slate/src/elementEditor/utils.js"],"sourcesContent":["import { Editor, Transforms, Node } from 'slate'; // Range,\n\n/**\n * @description Creates or updates an existing $elementType. It also takes care\n * of the saved selection and uses PathRef.\n *\n * @param {Editor} editor The Slate editor for the context\n * @param {object} data Relevant data for this element\n *\n * @returns {boolean} true if an element was possibly inserted, false otherwise\n * (currently we do not check here if the element was already applied to the\n * editor)\n */\nexport const _insertElement = (elementType) => (editor, data) => {\n  if (editor.getSavedSelection()) {\n    const selection = editor.selection || editor.getSavedSelection();\n\n    const rangeRef = Editor.rangeRef(editor, selection);\n\n    const res = Array.from(\n      Editor.nodes(editor, {\n        match: (n) => n.type === elementType,\n        mode: 'highest',\n        at: selection,\n      }),\n    );\n\n    if (res.length) {\n      const [, path] = res[0];\n      Transforms.setNodes(\n        editor,\n        { data },\n        {\n          at: path ? path : null,\n          match: path ? (n) => n.type === elementType : null,\n        },\n      );\n    } else {\n      Transforms.wrapNodes(\n        editor,\n        { type: elementType, data },\n        {\n          split: true,\n          at: selection,\n          match: (node) => {\n            return Node.string(node).length !== 0;\n          },\n        }, //,\n      );\n    }\n\n    const sel = JSON.parse(JSON.stringify(rangeRef.current));\n    Transforms.select(editor, sel);\n    editor.setSavedSelection(sel);\n\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Will unwrap a node that has as type the one received or one from an array\n * @param {string|Object[]} elementType - this can be a string or an array of strings\n * @returns {Object|null} - current node\n */\nexport const _unwrapElement = (elementType) => (editor) => {\n  const selection = editor.selection || editor.getSavedSelection();\n  const ref = Editor.rangeRef(editor, selection);\n\n  Transforms.select(editor, selection);\n  Transforms.unwrapNodes(editor, {\n    match: (n) =>\n      Array.isArray(elementType)\n        ? elementType.includes(n.type)\n        : n.type === elementType,\n    at: selection,\n  });\n\n  const current = ref.current;\n  ref.unref();\n\n  return current;\n};\n\nexport const _isActiveElement = (elementType) => (editor) => {\n  const selection = editor.selection || editor.getSavedSelection();\n  let found;\n  try {\n    found = Array.from(\n      Editor.nodes(editor, {\n        match: (n) => n.type === elementType,\n        at: selection,\n      }) || [],\n    );\n  } catch (e) {\n    // eslint-disable-next-line\n    // console.warn('Error in finding active element', e);\n    return false;\n  }\n  if (found.length) return true;\n\n  if (selection) {\n    const { path } = selection.anchor;\n    const isAtStart =\n      selection.anchor.offset === 0 && selection.focus.offset === 0;\n\n    if (isAtStart) {\n      try {\n        found = Editor.previous(editor, {\n          at: path,\n          // match: (n) => n.type === MENTION,\n        });\n      } catch (ex) {\n        found = [];\n      }\n      if (found && found[0] && found[0].type === elementType) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\n/**\n * Will look for a node that has as type the one received or one from an array\n * @param {string|Object[]} elementType - this can be a string or an array of strings\n * @returns {Object|null} - found node\n */\nexport const _getActiveElement = (elementType) => (\n  editor,\n  direction = 'any',\n) => {\n  const selection = editor.selection || editor.getSavedSelection();\n  let found = [];\n\n  try {\n    found = Array.from(\n      Editor.nodes(editor, {\n        match: (n) =>\n          Array.isArray(elementType)\n            ? elementType.includes(n.type)\n            : n.type === elementType,\n        at: selection,\n      }),\n    );\n  } catch (e) {\n    return null;\n  }\n\n  if (found.length) return found[0];\n\n  if (!selection) return null;\n\n  if (direction === 'any' || direction === 'backward') {\n    const { path } = selection.anchor;\n    const isAtStart =\n      selection.anchor.offset === 0 && selection.focus.offset === 0;\n\n    if (isAtStart) {\n      let found;\n      try {\n        found = Editor.previous(editor, {\n          at: path,\n        });\n      } catch (ex) {\n        // eslint-disable-next-line no-console\n        console.warn('Unable to find previous node', editor, path);\n        return;\n      }\n      if (found && found[0] && found[0].type === elementType) {\n        if (\n          (Array.isArray(elementType) && elementType.includes(found[0].type)) ||\n          found[0].type === elementType\n        ) {\n          return found;\n        }\n      } else {\n        return null;\n      }\n    }\n  }\n\n  if (direction === 'any' || direction === 'forward') {\n    const { path } = selection.anchor;\n    const isAtStart =\n      selection.anchor.offset === 0 && selection.focus.offset === 0;\n\n    if (isAtStart) {\n      let found;\n      try {\n        found = Editor.next(editor, {\n          at: path,\n        });\n      } catch (e) {\n        // eslint-disable-next-line\n        console.warn('Unable to find next node', editor, path);\n        return;\n      }\n      if (found && found[0] && found[0].type === elementType) {\n        if (\n          (Array.isArray(elementType) && elementType.includes(found[0].type)) ||\n          found[0].type === elementType\n        ) {\n          return found;\n        }\n      } else {\n        return null;\n      }\n    }\n  }\n\n  return null;\n};\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module"}