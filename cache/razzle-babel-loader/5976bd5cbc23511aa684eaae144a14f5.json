{"ast":null,"code":"import _find from \"lodash/find\";\nimport _endsWith from \"lodash/endsWith\";\nimport _keys from \"lodash/keys\";\nimport _map from \"lodash/map\";\nimport _pickBy from \"lodash/pickBy\";\nimport _mapKeys from \"lodash/mapKeys\";\nimport _omitBy from \"lodash/omitBy\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport config from '@plone/volto/registry';\n/**\n * Nest content.\n * @function nestContent\n * @param {Object} props Properties.\n * @return {string} Field name of the block\n */\n\nexport function nestContent(props) {\n  if (!props['@static_behaviors']) {\n    return props;\n  }\n\n  let nestedProps = props;\n\n  _map(props['@static_behaviors'], behavior => {\n    const values = _mapKeys(_pickBy(nestedProps, (value, key) => key.indexOf(behavior) !== -1), (value, key) => key.replace(`${behavior}.`, ''));\n\n    nestedProps = _omitBy(nestedProps, (value, key) => key.indexOf(behavior) !== -1);\n    nestedProps = _objectSpread(_objectSpread({}, nestedProps), {}, {\n      [behavior]: values\n    });\n  });\n\n  return nestedProps;\n}\n/**\n * Get layout field.\n * @function getLayoutFieldname\n * @param {Object} props Properties.\n * @return {string} Field name of the layout\n */\n\nexport function getLayoutFieldname(props) {\n  return _find(_keys(props), key => _endsWith(key, 'content_layout')) || 'layout';\n}\n/**\n * Get content icon.\n * @description Configurable in config\n * @function getContentIcon\n * @param {string} type Content type\n * @param {boolean} isFolderish\n * @returns {Object} Icon component\n */\n\nexport function getContentIcon(type, isFolderish) {\n  const {\n    settings\n  } = config;\n  const {\n    contentIcons\n  } = settings;\n  if (type in contentIcons) return contentIcons[type];\n  return isFolderish ? contentIcons.Folder : contentIcons.File;\n}\n/**\n * Get the language independent fields presents in a schema.\n * @description Configurable in config\n * @function getLanguageIndependentFields\n * @param {string} schema content type JSON Schema serialization\n * @returns {array} List of language independent fields\n */\n\nexport function getLanguageIndependentFields(schema) {\n  const {\n    properties\n  } = schema;\n  return Object.keys(properties).filter(field => {\n    var _properties$field$mul;\n\n    return Object.keys(properties[field]).includes('multilingual_options') && ((_properties$field$mul = properties[field]['multilingual_options']) === null || _properties$field$mul === void 0 ? void 0 : _properties$field$mul['language_independent']);\n  });\n}","map":{"version":3,"names":["config","nestContent","props","nestedProps","behavior","values","value","key","indexOf","replace","getLayoutFieldname","getContentIcon","type","isFolderish","settings","contentIcons","Folder","File","getLanguageIndependentFields","schema","properties","Object","keys","filter","field","includes"],"sources":["/home/jakob/workspace/training-project/node_modules/@plone/volto/src/helpers/Content/Content.js"],"sourcesContent":["/**\n * Content helper.\n * @module helpers/Content\n */\n\nimport { omitBy, mapKeys, pickBy, map, keys, endsWith, find } from 'lodash';\nimport config from '@plone/volto/registry';\n\n/**\n * Nest content.\n * @function nestContent\n * @param {Object} props Properties.\n * @return {string} Field name of the block\n */\nexport function nestContent(props) {\n  if (!props['@static_behaviors']) {\n    return props;\n  }\n\n  let nestedProps = props;\n\n  map(props['@static_behaviors'], (behavior) => {\n    const values = mapKeys(\n      pickBy(nestedProps, (value, key) => key.indexOf(behavior) !== -1),\n      (value, key) => key.replace(`${behavior}.`, ''),\n    );\n    nestedProps = omitBy(\n      nestedProps,\n      (value, key) => key.indexOf(behavior) !== -1,\n    );\n    nestedProps = {\n      ...nestedProps,\n      [behavior]: values,\n    };\n  });\n  return nestedProps;\n}\n\n/**\n * Get layout field.\n * @function getLayoutFieldname\n * @param {Object} props Properties.\n * @return {string} Field name of the layout\n */\nexport function getLayoutFieldname(props) {\n  return (\n    find(keys(props), (key) => endsWith(key, 'content_layout')) || 'layout'\n  );\n}\n\n/**\n * Get content icon.\n * @description Configurable in config\n * @function getContentIcon\n * @param {string} type Content type\n * @param {boolean} isFolderish\n * @returns {Object} Icon component\n */\nexport function getContentIcon(type, isFolderish) {\n  const { settings } = config;\n  const { contentIcons } = settings;\n\n  if (type in contentIcons) return contentIcons[type];\n  return isFolderish ? contentIcons.Folder : contentIcons.File;\n}\n\n/**\n * Get the language independent fields presents in a schema.\n * @description Configurable in config\n * @function getLanguageIndependentFields\n * @param {string} schema content type JSON Schema serialization\n * @returns {array} List of language independent fields\n */\nexport function getLanguageIndependentFields(schema) {\n  const { properties } = schema;\n  return Object.keys(properties).filter(\n    (field) =>\n      Object.keys(properties[field]).includes('multilingual_options') &&\n      properties[field]['multilingual_options']?.['language_independent'],\n  );\n}\n"],"mappings":";;;;;;;;;;;;;;AAMA,OAAOA,MAAP,MAAmB,uBAAnB;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,WAAT,CAAqBC,KAArB,EAA4B;EACjC,IAAI,CAACA,KAAK,CAAC,mBAAD,CAAV,EAAiC;IAC/B,OAAOA,KAAP;EACD;;EAED,IAAIC,WAAW,GAAGD,KAAlB;;EAEA,KAAIA,KAAK,CAAC,mBAAD,CAAT,EAAiCE,QAAD,IAAc;IAC5C,MAAMC,MAAM,GAAG,SACb,QAAOF,WAAP,EAAoB,CAACG,KAAD,EAAQC,GAAR,KAAgBA,GAAG,CAACC,OAAJ,CAAYJ,QAAZ,MAA0B,CAAC,CAA/D,CADa,EAEb,CAACE,KAAD,EAAQC,GAAR,KAAgBA,GAAG,CAACE,OAAJ,CAAa,GAAEL,QAAS,GAAxB,EAA4B,EAA5B,CAFH,CAAf;;IAIAD,WAAW,GAAG,QACZA,WADY,EAEZ,CAACG,KAAD,EAAQC,GAAR,KAAgBA,GAAG,CAACC,OAAJ,CAAYJ,QAAZ,MAA0B,CAAC,CAF/B,CAAd;IAIAD,WAAW,mCACNA,WADM;MAET,CAACC,QAAD,GAAYC;IAFH,EAAX;EAID,CAbD;;EAcA,OAAOF,WAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASO,kBAAT,CAA4BR,KAA5B,EAAmC;EACxC,OACE,MAAK,MAAKA,KAAL,CAAL,EAAmBK,GAAD,IAAS,UAASA,GAAT,EAAc,gBAAd,CAA3B,KAA+D,QADjE;AAGD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASI,cAAT,CAAwBC,IAAxB,EAA8BC,WAA9B,EAA2C;EAChD,MAAM;IAAEC;EAAF,IAAed,MAArB;EACA,MAAM;IAAEe;EAAF,IAAmBD,QAAzB;EAEA,IAAIF,IAAI,IAAIG,YAAZ,EAA0B,OAAOA,YAAY,CAACH,IAAD,CAAnB;EAC1B,OAAOC,WAAW,GAAGE,YAAY,CAACC,MAAhB,GAAyBD,YAAY,CAACE,IAAxD;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,4BAAT,CAAsCC,MAAtC,EAA8C;EACnD,MAAM;IAAEC;EAAF,IAAiBD,MAAvB;EACA,OAAOE,MAAM,CAACC,IAAP,CAAYF,UAAZ,EAAwBG,MAAxB,CACJC,KAAD;IAAA;;IAAA,OACEH,MAAM,CAACC,IAAP,CAAYF,UAAU,CAACI,KAAD,CAAtB,EAA+BC,QAA/B,CAAwC,sBAAxC,+BACAL,UAAU,CAACI,KAAD,CAAV,CAAkB,sBAAlB,CADA,0DACA,sBAA4C,sBAA5C,CADA,CADF;EAAA,CADK,CAAP;AAKD"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module"}