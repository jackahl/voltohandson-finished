{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// The default behavior is to allow images to be copy/pasted inside the editor\n// The TextBlockEdit extensions will come and then split the images into\n// separate dedicated Volto image blocks.\nimport { IMAGE } from '@plone/volto-slate/constants';\nimport { jsx } from 'slate-hyperscript';\nexport const deserializeImageTag = (editor, el) => {\n  const attrs = {\n    type: IMAGE\n  }; // TODO: not all of these attributes should be stored in the DB\n\n  for (const name of el.getAttributeNames()) {\n    attrs[name] = el.getAttribute(name);\n  } // TODO: recognize more unsupported protocols\n\n\n  if (typeof attrs.src === 'undefined' || attrs.src.startsWith('file:///')) {\n    return null;\n  }\n\n  attrs.url = attrs.src;\n  delete attrs.src;\n  return [jsx('element', attrs, [{\n    text: ''\n  }])];\n};\n/**\n * Allows for pasting images from clipboard.\n * Not yet: dragging and dropping images, selecting them through a file system dialog.\n * @param typeImg\n */\n\nexport const withImage = editor => {\n  const {\n    isVoid,\n    isInline\n  } = editor;\n\n  editor.isVoid = element => {\n    return element.type === IMAGE ? true : isVoid(element);\n  }; // If it's not marked as inline, Slate will strip the {type:'img\"} nodes when\n  // it finds them next to {text: ''} nodes\n\n\n  editor.isInline = element => {\n    return element && element.type === IMAGE ? true : isInline(element);\n  };\n\n  editor.htmlTagsToSlate = _objectSpread(_objectSpread({}, editor.htmlTagsToSlate), {}, {\n    IMG: deserializeImageTag\n  });\n  return editor;\n};","map":{"version":3,"names":["IMAGE","jsx","deserializeImageTag","editor","el","attrs","type","name","getAttributeNames","getAttribute","src","startsWith","url","text","withImage","isVoid","isInline","element","htmlTagsToSlate","IMG"],"sources":["/home/jakob/workspace/training-project/node_modules/@plone/volto/packages/volto-slate/src/editor/plugins/Image/extensions.js"],"sourcesContent":["// The default behavior is to allow images to be copy/pasted inside the editor\n// The TextBlockEdit extensions will come and then split the images into\n// separate dedicated Volto image blocks.\n\nimport { IMAGE } from '@plone/volto-slate/constants';\nimport { jsx } from 'slate-hyperscript';\n\nexport const deserializeImageTag = (editor, el) => {\n  const attrs = { type: IMAGE };\n\n  // TODO: not all of these attributes should be stored in the DB\n  for (const name of el.getAttributeNames()) {\n    attrs[name] = el.getAttribute(name);\n  }\n\n  // TODO: recognize more unsupported protocols\n  if (typeof attrs.src === 'undefined' || attrs.src.startsWith('file:///')) {\n    return null;\n  }\n\n  attrs.url = attrs.src;\n  delete attrs.src;\n\n  return [jsx('element', attrs, [{ text: '' }])];\n};\n\n/**\n * Allows for pasting images from clipboard.\n * Not yet: dragging and dropping images, selecting them through a file system dialog.\n * @param typeImg\n */\nexport const withImage = (editor) => {\n  const { isVoid, isInline } = editor;\n\n  editor.isVoid = (element) => {\n    return element.type === IMAGE ? true : isVoid(element);\n  };\n\n  // If it's not marked as inline, Slate will strip the {type:'img\"} nodes when\n  // it finds them next to {text: ''} nodes\n  editor.isInline = (element) => {\n    return element && element.type === IMAGE ? true : isInline(element);\n  };\n\n  editor.htmlTagsToSlate = {\n    ...editor.htmlTagsToSlate,\n    IMG: deserializeImageTag,\n  };\n\n  return editor;\n};\n"],"mappings":";;;;;;AAAA;AACA;AACA;AAEA,SAASA,KAAT,QAAsB,8BAAtB;AACA,SAASC,GAAT,QAAoB,mBAApB;AAEA,OAAO,MAAMC,mBAAmB,GAAG,CAACC,MAAD,EAASC,EAAT,KAAgB;EACjD,MAAMC,KAAK,GAAG;IAAEC,IAAI,EAAEN;EAAR,CAAd,CADiD,CAGjD;;EACA,KAAK,MAAMO,IAAX,IAAmBH,EAAE,CAACI,iBAAH,EAAnB,EAA2C;IACzCH,KAAK,CAACE,IAAD,CAAL,GAAcH,EAAE,CAACK,YAAH,CAAgBF,IAAhB,CAAd;EACD,CANgD,CAQjD;;;EACA,IAAI,OAAOF,KAAK,CAACK,GAAb,KAAqB,WAArB,IAAoCL,KAAK,CAACK,GAAN,CAAUC,UAAV,CAAqB,UAArB,CAAxC,EAA0E;IACxE,OAAO,IAAP;EACD;;EAEDN,KAAK,CAACO,GAAN,GAAYP,KAAK,CAACK,GAAlB;EACA,OAAOL,KAAK,CAACK,GAAb;EAEA,OAAO,CAACT,GAAG,CAAC,SAAD,EAAYI,KAAZ,EAAmB,CAAC;IAAEQ,IAAI,EAAE;EAAR,CAAD,CAAnB,CAAJ,CAAP;AACD,CAjBM;AAmBP;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,SAAS,GAAIX,MAAD,IAAY;EACnC,MAAM;IAAEY,MAAF;IAAUC;EAAV,IAAuBb,MAA7B;;EAEAA,MAAM,CAACY,MAAP,GAAiBE,OAAD,IAAa;IAC3B,OAAOA,OAAO,CAACX,IAAR,KAAiBN,KAAjB,GAAyB,IAAzB,GAAgCe,MAAM,CAACE,OAAD,CAA7C;EACD,CAFD,CAHmC,CAOnC;EACA;;;EACAd,MAAM,CAACa,QAAP,GAAmBC,OAAD,IAAa;IAC7B,OAAOA,OAAO,IAAIA,OAAO,CAACX,IAAR,KAAiBN,KAA5B,GAAoC,IAApC,GAA2CgB,QAAQ,CAACC,OAAD,CAA1D;EACD,CAFD;;EAIAd,MAAM,CAACe,eAAP,mCACKf,MAAM,CAACe,eADZ;IAEEC,GAAG,EAAEjB;EAFP;EAKA,OAAOC,MAAP;AACD,CAnBM"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module"}