{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Vocabularies reducer.\n * @module reducers/vocabularies/vocabularies\n */\nimport { GET_VOCABULARY, GET_VOCABULARY_TOKEN_TITLE } from '@plone/volto/constants/ActionTypes';\nconst initialState = {};\n/**\n * Vocabularies reducer.\n * @function vocabularies\n * @param {Object} state Current state.\n * @param {Object} action Action to be handled.\n * @returns {Object} New state.\n */\n\nexport default function vocabularies(state = initialState, action = {}) {\n  var _vocabState$subreques, _vocabState$action$su, _vocabState$action$su2;\n\n  const vocabState = state[action.vocabulary] || {};\n  const subrequestState = action.subrequest ? ((_vocabState$subreques = vocabState.subrequests) === null || _vocabState$subreques === void 0 ? void 0 : _vocabState$subreques[action.subrequest]) || {} : {};\n\n  switch (action.type) {\n    case `${GET_VOCABULARY}_PENDING`:\n    case `${GET_VOCABULARY_TOKEN_TITLE}_PENDING`:\n      return action.subrequest ? _objectSpread(_objectSpread({}, state), {}, {\n        [action.vocabulary]: _objectSpread(_objectSpread({}, vocabState), {}, {\n          subrequests: _objectSpread(_objectSpread({}, vocabState.subrequests), {}, {\n            [action.subrequest]: _objectSpread(_objectSpread({}, subrequestState || {\n              data: null\n            }), {}, {\n              loaded: (vocabState === null || vocabState === void 0 ? void 0 : (_vocabState$action$su = vocabState[action.subrequest]) === null || _vocabState$action$su === void 0 ? void 0 : _vocabState$action$su.loaded) || false,\n              loading: !!(((vocabState === null || vocabState === void 0 ? void 0 : (_vocabState$action$su2 = vocabState[action.subrequest]) === null || _vocabState$action$su2 === void 0 ? void 0 : _vocabState$action$su2.loading) || 0) + 1),\n              error: null\n            })\n          })\n        })\n      }) : _objectSpread(_objectSpread({}, state), {}, {\n        [action.vocabulary]: _objectSpread(_objectSpread({}, vocabState), {}, {\n          error: null,\n          loaded: vocabState.loaded || false,\n          loading: !!((vocabState.loading || 0) + 1)\n        })\n      });\n\n    case `${GET_VOCABULARY}_SUCCESS`:\n      return action.subrequest ? _objectSpread(_objectSpread({}, state), {}, {\n        [action.vocabulary]: _objectSpread(_objectSpread({}, vocabState), {}, {\n          subrequests: _objectSpread(_objectSpread({}, vocabState.subrequests), {}, {\n            [action.subrequest]: _objectSpread(_objectSpread({}, subrequestState), {}, {\n              error: null,\n              loaded: true,\n              loading: !!(subrequestState.loading - 1),\n              items: [...action.result.items.map(item => ({\n                label: item.title,\n                value: item.token\n              }))],\n              batching: action.result.batching,\n              itemsTotal: action.result.items_total\n            })\n          })\n        })\n      }) : _objectSpread(_objectSpread({}, state), {}, {\n        [action.vocabulary]: _objectSpread(_objectSpread({}, vocabState), {}, {\n          error: null,\n          loaded: true,\n          loading: !!(vocabState.loading - 1),\n          items: [...action.result.items.map(item => ({\n            label: item.title,\n            value: item.token\n          }))],\n          batching: action.result.batching,\n          itemsTotal: action.result.items_total\n        })\n      });\n\n    case `${GET_VOCABULARY}_FAIL`:\n    case `${GET_VOCABULARY_TOKEN_TITLE}_FAIL`:\n      return action.subrequest ? _objectSpread(_objectSpread({}, state), {}, {\n        [action.vocabulary]: {\n          subrequests: _objectSpread(_objectSpread({}, vocabState.subrequests), {}, {\n            [action.subrequest]: {\n              error: action.error,\n              loaded: false,\n              loading: !!(subrequestState.loading - 1)\n            }\n          })\n        }\n      }) : _objectSpread(_objectSpread({}, state), {}, {\n        [action.vocabulary]: {\n          error: action.error,\n          loaded: false,\n          loading: !!(vocabState.loading - 1)\n        }\n      });\n\n    case `${GET_VOCABULARY_TOKEN_TITLE}_SUCCESS`:\n      return action.subrequest ? _objectSpread(_objectSpread({}, state), {}, {\n        [action.vocabulary]: _objectSpread(_objectSpread({}, vocabState), {}, {\n          subrequests: _objectSpread(_objectSpread({}, vocabState.subrequests), {}, {\n            [action.subrequest]: _objectSpread(_objectSpread(_objectSpread({}, subrequestState), {}, {\n              error: null,\n              loaded: true,\n              loading: !!(subrequestState.loading - 1)\n            }, action.token && {\n              [action.token]: action.result.items[0].title\n            }), action.tokens && {\n              items: [...action.result.items.map(item => ({\n                label: item.title,\n                value: item.token\n              }))]\n            })\n          })\n        })\n      }) : _objectSpread(_objectSpread({}, state), {}, {\n        [action.vocabulary]: _objectSpread(_objectSpread({}, vocabState), {}, {\n          error: null,\n          loaded: true,\n          loading: !!(vocabState.loading - 1),\n          [action.token]: action.result.items[0].title\n        })\n      });\n\n    default:\n      return state;\n  }\n}","map":{"version":3,"names":["GET_VOCABULARY","GET_VOCABULARY_TOKEN_TITLE","initialState","vocabularies","state","action","vocabState","vocabulary","subrequestState","subrequest","subrequests","type","data","loaded","loading","error","items","result","map","item","label","title","value","token","batching","itemsTotal","items_total","tokens"],"sources":["/home/jakob/workspace/training-project/node_modules/@plone/volto/src/reducers/vocabularies/vocabularies.js"],"sourcesContent":["/**\n * Vocabularies reducer.\n * @module reducers/vocabularies/vocabularies\n */\n\nimport {\n  GET_VOCABULARY,\n  GET_VOCABULARY_TOKEN_TITLE,\n} from '@plone/volto/constants/ActionTypes';\n\nconst initialState = {};\n\n/**\n * Vocabularies reducer.\n * @function vocabularies\n * @param {Object} state Current state.\n * @param {Object} action Action to be handled.\n * @returns {Object} New state.\n */\nexport default function vocabularies(state = initialState, action = {}) {\n  const vocabState = state[action.vocabulary] || {};\n  const subrequestState = action.subrequest\n    ? vocabState.subrequests?.[action.subrequest] || {}\n    : {};\n  switch (action.type) {\n    case `${GET_VOCABULARY}_PENDING`:\n    case `${GET_VOCABULARY_TOKEN_TITLE}_PENDING`:\n      return action.subrequest\n        ? {\n            ...state,\n            [action.vocabulary]: {\n              ...vocabState,\n              subrequests: {\n                ...vocabState.subrequests,\n                [action.subrequest]: {\n                  // We preserve here the previous items array to prevent the component\n                  // to rerender due to prop changes while the PENDING state is active,\n                  // this little trick allow us to use how react-select do things\n                  // internally. This has a very low consequences since in the SUCCESS\n                  // state the items are overwritten anyways.\n                  ...(subrequestState || {\n                    data: null,\n                  }),\n                  loaded: vocabState?.[action.subrequest]?.loaded || false,\n                  loading: !!(\n                    (vocabState?.[action.subrequest]?.loading || 0) + 1\n                  ),\n                  error: null,\n                },\n              },\n            },\n          }\n        : {\n            ...state,\n            [action.vocabulary]: {\n              // We preserve here the previous items array to prevent the component\n              // to rerender due to prop changes while the PENDING state is active,\n              // this little trick allow us to use how react-select do things\n              // internally. This has a very low consequences since in the SUCCESS\n              // state the items are overwritten anyways.\n              ...vocabState,\n              error: null,\n              loaded: vocabState.loaded || false,\n              loading: !!((vocabState.loading || 0) + 1),\n            },\n          };\n    case `${GET_VOCABULARY}_SUCCESS`:\n      return action.subrequest\n        ? {\n            ...state,\n            [action.vocabulary]: {\n              ...vocabState,\n              subrequests: {\n                ...vocabState.subrequests,\n                [action.subrequest]: {\n                  ...subrequestState,\n                  error: null,\n                  loaded: true,\n                  loading: !!(subrequestState.loading - 1),\n                  items: [\n                    ...action.result.items.map((item) => ({\n                      label: item.title,\n                      value: item.token,\n                    })),\n                  ],\n                  batching: action.result.batching,\n                  itemsTotal: action.result.items_total,\n                },\n              },\n            },\n          }\n        : {\n            ...state,\n            [action.vocabulary]: {\n              ...vocabState,\n              error: null,\n              loaded: true,\n              loading: !!(vocabState.loading - 1),\n              items: [\n                ...action.result.items.map((item) => ({\n                  label: item.title,\n                  value: item.token,\n                })),\n              ],\n              batching: action.result.batching,\n              itemsTotal: action.result.items_total,\n            },\n          };\n    case `${GET_VOCABULARY}_FAIL`:\n    case `${GET_VOCABULARY_TOKEN_TITLE}_FAIL`:\n      return action.subrequest\n        ? {\n            ...state,\n            [action.vocabulary]: {\n              subrequests: {\n                ...vocabState.subrequests,\n                [action.subrequest]: {\n                  error: action.error,\n                  loaded: false,\n                  loading: !!(subrequestState.loading - 1),\n                },\n              },\n            },\n          }\n        : {\n            ...state,\n            [action.vocabulary]: {\n              error: action.error,\n              loaded: false,\n              loading: !!(vocabState.loading - 1),\n            },\n          };\n    case `${GET_VOCABULARY_TOKEN_TITLE}_SUCCESS`:\n      return action.subrequest\n        ? {\n            ...state,\n            [action.vocabulary]: {\n              ...vocabState,\n              subrequests: {\n                ...vocabState.subrequests,\n                [action.subrequest]: {\n                  ...subrequestState,\n                  error: null,\n                  loaded: true,\n                  loading: !!(subrequestState.loading - 1),\n                  ...(action.token && {\n                    [action.token]: action.result.items[0].title,\n                  }),\n                  ...(action.tokens && {\n                    items: [\n                      ...action.result.items.map((item) => ({\n                        label: item.title,\n                        value: item.token,\n                      })),\n                    ],\n                  }),\n                },\n              },\n            },\n          }\n        : {\n            ...state,\n            [action.vocabulary]: {\n              ...vocabState,\n              error: null,\n              loaded: true,\n              loading: !!(vocabState.loading - 1),\n              [action.token]: action.result.items[0].title,\n            },\n          };\n    default:\n      return state;\n  }\n}\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module"}