{"ast":null,"code":"import _map from \"lodash/map\";\nimport _castArray from \"lodash/castArray\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { Editor, Path, Point, Range, Transforms } from 'slate';\n/**\n * Get range from {@link getPointBefore} to the end point of `at`.\n */\n\nexport const getRangeBefore = (editor, at, options) => {\n  const anchor = getPointBefore(editor, at, options);\n  if (!anchor) return;\n  const focus = Editor.point(editor, at, {\n    edge: 'end'\n  });\n  return {\n    anchor,\n    focus\n  };\n};\n/**\n * Autoformat in the middle of a block\n */\n\nexport const autoformatInlineBlock = (editor, {\n  type,\n  markup,\n  preFormat,\n  format\n}) => {\n  const markupRange = getRangeBefore(editor, editor.selection, {\n    matchString: markup,\n    skipInvalid: true\n  });\n\n  if (markupRange) {\n    autoformatBlock(editor, type, markupRange, {\n      preFormat: () => {\n        editor.insertBreak();\n\n        if (preFormat) {\n          preFormat(editor);\n        }\n      },\n      format\n    });\n    return true;\n  }\n};\n/**\n * {@link Editor.before} with additional options.\n * TODO: support for sequence of any characters.\n */\n\nexport const getPointBefore = (editor, at, options) => {\n  var _options$matchString;\n\n  if (!options || !options.match && !options.matchString) {\n    return Editor.before(editor, at, options);\n  }\n\n  let beforeAt = at;\n  let previousBeforePoint = Editor.point(editor, at, {\n    edge: 'end'\n  });\n  const stackLength = (((_options$matchString = options.matchString) === null || _options$matchString === void 0 ? void 0 : _options$matchString.length) || 0) + 1;\n  const stack = Array(stackLength);\n  const unitOffset = !options.unit || options.unit === 'offset';\n  let count = 0;\n\n  while (true) {\n    var _options$match;\n\n    const beforePoint = Editor.before(editor, beforeAt, options); // not found\n\n    if (!beforePoint) return; // different path\n\n    if (!options.multiPaths && !Path.equals(beforePoint.path, previousBeforePoint.path)) {\n      return;\n    }\n\n    const beforeString = Editor.string(editor, {\n      anchor: beforePoint,\n      focus: previousBeforePoint\n    });\n\n    const matchString = _castArray(options.matchString);\n\n    let beforeStringToMatch = beforeString;\n\n    if (unitOffset && stackLength) {\n      stack.unshift({\n        point: beforePoint,\n        text: beforeString\n      });\n      stack.pop();\n      beforeStringToMatch = _map(stack.slice(0, -1), 'text').join('');\n    }\n\n    if (matchString.includes(beforeStringToMatch) || (_options$match = options.match) !== null && _options$match !== void 0 && _options$match.call(options, {\n      beforeString: beforeStringToMatch,\n      beforePoint,\n      at\n    })) {\n      if (options.afterMatch) {\n        if (stackLength && unitOffset) {\n          var _stack;\n\n          return (_stack = stack[stack.length - 1]) === null || _stack === void 0 ? void 0 : _stack.point;\n        }\n\n        return previousBeforePoint;\n      }\n\n      return beforePoint;\n    }\n\n    previousBeforePoint = beforePoint;\n    beforeAt = beforePoint;\n    count += 1;\n\n    if (!options.skipInvalid) {\n      if (!matchString || count > matchString.length) return;\n    }\n  }\n};\nexport const autoformatInline = (editor, {\n  type,\n  between,\n  markup,\n  ignoreTrim\n}) => {\n  const selection = editor.selection;\n  const startMarkup = between ? between[0] : markup;\n  const endMarkup = between ? between[1] : '';\n  let endMarkupPointBefore = selection.anchor;\n\n  if (endMarkup) {\n    endMarkupPointBefore = getPointBefore(editor, selection, {\n      matchString: endMarkup\n    });\n    if (!endMarkupPointBefore) return false;\n  }\n\n  const startMarkupPointAfter = getPointBefore(editor, endMarkupPointBefore, {\n    matchString: startMarkup,\n    skipInvalid: true,\n    afterMatch: true\n  });\n  if (!startMarkupPointAfter) return false; // found\n\n  const markupRange = {\n    anchor: startMarkupPointAfter,\n    focus: endMarkupPointBefore\n  };\n\n  if (!ignoreTrim) {\n    const markupText = getText(editor, markupRange);\n    if (markupText.trim() !== markupText) return false;\n  } // delete end markup\n\n\n  if (endMarkup) {\n    endMarkupPointBefore = getPointBefore(editor, selection, {\n      matchString: endMarkup\n    });\n    Transforms.delete(editor, {\n      at: {\n        anchor: endMarkupPointBefore,\n        focus: selection.anchor\n      }\n    });\n  } // add mark to the text between the markups\n\n\n  Transforms.select(editor, markupRange);\n  editor.addMark(type, true);\n  Transforms.collapse(editor, {\n    edge: 'end'\n  });\n  editor.removeMark(type); // delete start markup\n\n  const startMarkupPointBefore = getPointBefore(editor, selection, {\n    matchString: startMarkup,\n    skipInvalid: true\n  });\n  Transforms.delete(editor, {\n    at: {\n      anchor: startMarkupPointBefore,\n      focus: startMarkupPointAfter\n    }\n  });\n  return true;\n};\nexport const autoformatBlock = (editor, type, at, {\n  preFormat,\n  format\n}) => {\n  Transforms.delete(editor, {\n    at\n  });\n\n  if (preFormat) {\n    preFormat(editor);\n  }\n\n  if (!format) {\n    Transforms.setNodes(editor, {\n      type\n    }, {\n      match: n => Editor.isBlock(editor, n)\n    });\n  } else {\n    format(editor);\n  }\n};\n/**\n * See {@link Range.isCollapsed}.\n * Return false if `range` is not defined.\n */\n\nexport const isCollapsed = range => !!range && Range.isCollapsed(range);\n/**\n * See {@link Editor.string}.\n * If `at` is not defined, return an empty string.\n */\n\nexport const getText = (editor, at) => {\n  var _ref;\n\n  return (_ref = at && Editor.string(editor, at)) !== null && _ref !== void 0 ? _ref : '';\n};\n/**\n * Get the bloc {\n * k above a location (default: selection).\n * If not found, return the editor entry.\n */\n\nexport const getBlockAbove = (editor, options = {}) => Editor.above(editor, _objectSpread({\n  match: n => Editor.isBlock(editor, n)\n}, options)) || [editor, []];\n/**\n * Get the point from a location (default: selection).\n * If the location is a range, get the anchor point.\n * If the location is a path, get the point at this path with offset 0.\n * If `focus` is true, get the focus point.\n */\n\nexport const getPointFromLocation = (editor, {\n  at = editor.selection,\n  focus\n} = {}) => {\n  let point;\n  if (Range.isRange(at)) point = !focus ? at.anchor : at.focus;\n  if (Point.isPoint(at)) point = at;\n  if (Path.isPath(at)) point = {\n    path: at,\n    offset: 0\n  };\n  return point;\n};\n/**\n * Get the range from the start of the block above a location (default: selection) to the location.\n */\n\nexport const getRangeFromBlockStart = (editor, options = {}) => {\n  const [, path] = getBlockAbove(editor, options);\n  const start = Editor.start(editor, path);\n  const focus = getPointFromLocation(editor, options);\n  if (!focus) return;\n  return {\n    anchor: start,\n    focus\n  };\n};\n/**\n * Enables support for autoformatting actions.\n * Once a markup rule is validated, it does not check the following rules.\n */\n\nexport const withAutoformat = ({\n  rules\n}) => editor => {\n  const {\n    insertText\n  } = editor;\n\n  editor.insertText = text => {\n    if (!isCollapsed(editor.selection)) return insertText(text);\n\n    for (const {\n      trigger = ' ',\n      type,\n      markup,\n      preFormat,\n      format,\n      mode,\n      between,\n      ignoreTrim,\n      insertTrigger\n    } of rules) {\n      const triggers = _castArray(trigger); // Check trigger\n\n\n      if (!triggers.includes(text)) continue;\n\n      const markups = _castArray(markup);\n\n      const rangeFromBlockStart = getRangeFromBlockStart(editor);\n      const textFromBlockStart = getText(editor, rangeFromBlockStart);\n\n      const valid = () => insertTrigger && insertText(text);\n\n      if (markups.includes(textFromBlockStart)) {\n        // Start of the block\n        autoformatBlock(editor, type, rangeFromBlockStart, {\n          preFormat,\n          format\n        });\n        return valid();\n      }\n\n      if (mode === 'inline-block') {\n        if (autoformatInlineBlock(editor, {\n          preFormat,\n          markup,\n          format,\n          type\n        })) {\n          return valid();\n        }\n      }\n\n      if (mode === 'inline') {\n        if (autoformatInline(editor, {\n          type,\n          between,\n          ignoreTrim,\n          markup: Array.isArray(markup) ? markup[0] : markup\n        })) {\n          return valid();\n        }\n      }\n    }\n\n    insertText(text);\n  };\n\n  return editor;\n};","map":{"version":3,"names":["Editor","Path","Point","Range","Transforms","getRangeBefore","editor","at","options","anchor","getPointBefore","focus","point","edge","autoformatInlineBlock","type","markup","preFormat","format","markupRange","selection","matchString","skipInvalid","autoformatBlock","insertBreak","match","before","beforeAt","previousBeforePoint","stackLength","length","stack","Array","unitOffset","unit","count","beforePoint","multiPaths","equals","path","beforeString","string","beforeStringToMatch","unshift","text","pop","slice","join","includes","afterMatch","autoformatInline","between","ignoreTrim","startMarkup","endMarkup","endMarkupPointBefore","startMarkupPointAfter","markupText","getText","trim","delete","select","addMark","collapse","removeMark","startMarkupPointBefore","setNodes","n","isBlock","isCollapsed","range","getBlockAbove","above","getPointFromLocation","isRange","isPoint","isPath","offset","getRangeFromBlockStart","start","withAutoformat","rules","insertText","trigger","mode","insertTrigger","triggers","markups","rangeFromBlockStart","textFromBlockStart","valid","isArray"],"sources":["/home/jakob/workspace/training-project/node_modules/@plone/volto/packages/volto-slate/src/editor/plugins/Markdown/extensions.js"],"sourcesContent":["import { castArray, map } from 'lodash';\nimport { Editor, Path, Point, Range, Transforms } from 'slate';\n\n/**\n * Get range from {@link getPointBefore} to the end point of `at`.\n */\nexport const getRangeBefore = (editor, at, options) => {\n  const anchor = getPointBefore(editor, at, options);\n  if (!anchor) return;\n\n  const focus = Editor.point(editor, at, { edge: 'end' });\n\n  return {\n    anchor,\n    focus,\n  };\n};\n\n/**\n * Autoformat in the middle of a block\n */\nexport const autoformatInlineBlock = (\n  editor,\n  { type, markup, preFormat, format },\n) => {\n  const markupRange = getRangeBefore(editor, editor.selection, {\n    matchString: markup,\n    skipInvalid: true,\n  });\n\n  if (markupRange) {\n    autoformatBlock(editor, type, markupRange, {\n      preFormat: () => {\n        editor.insertBreak();\n        if (preFormat) {\n          preFormat(editor);\n        }\n      },\n      format,\n    });\n\n    return true;\n  }\n};\n\n/**\n * {@link Editor.before} with additional options.\n * TODO: support for sequence of any characters.\n */\nexport const getPointBefore = (editor, at, options) => {\n  if (!options || (!options.match && !options.matchString)) {\n    return Editor.before(editor, at, options);\n  }\n\n  let beforeAt = at;\n  let previousBeforePoint = Editor.point(editor, at, { edge: 'end' });\n\n  const stackLength = (options.matchString?.length || 0) + 1;\n  const stack = Array(stackLength);\n\n  const unitOffset = !options.unit || options.unit === 'offset';\n\n  let count = 0;\n  while (true) {\n    const beforePoint = Editor.before(editor, beforeAt, options);\n\n    // not found\n    if (!beforePoint) return;\n\n    // different path\n    if (\n      !options.multiPaths &&\n      !Path.equals(beforePoint.path, previousBeforePoint.path)\n    ) {\n      return;\n    }\n\n    const beforeString = Editor.string(editor, {\n      anchor: beforePoint,\n      focus: previousBeforePoint,\n    });\n\n    const matchString = castArray(options.matchString);\n\n    let beforeStringToMatch = beforeString;\n\n    if (unitOffset && stackLength) {\n      stack.unshift({\n        point: beforePoint,\n        text: beforeString,\n      });\n      stack.pop();\n\n      beforeStringToMatch = map(stack.slice(0, -1), 'text').join('');\n    }\n\n    if (\n      matchString.includes(beforeStringToMatch) ||\n      options.match?.({ beforeString: beforeStringToMatch, beforePoint, at })\n    ) {\n      if (options.afterMatch) {\n        if (stackLength && unitOffset) {\n          return stack[stack.length - 1]?.point;\n        }\n        return previousBeforePoint;\n      }\n      return beforePoint;\n    }\n\n    previousBeforePoint = beforePoint;\n    beforeAt = beforePoint;\n\n    count += 1;\n\n    if (!options.skipInvalid) {\n      if (!matchString || count > matchString.length) return;\n    }\n  }\n};\n\nexport const autoformatInline = (\n  editor,\n  { type, between, markup, ignoreTrim },\n) => {\n  const selection = editor.selection;\n\n  const startMarkup = between ? between[0] : markup;\n  const endMarkup = between ? between[1] : '';\n\n  let endMarkupPointBefore = selection.anchor;\n  if (endMarkup) {\n    endMarkupPointBefore = getPointBefore(editor, selection, {\n      matchString: endMarkup,\n    });\n    if (!endMarkupPointBefore) return false;\n  }\n\n  const startMarkupPointAfter = getPointBefore(editor, endMarkupPointBefore, {\n    matchString: startMarkup,\n    skipInvalid: true,\n    afterMatch: true,\n  });\n\n  if (!startMarkupPointAfter) return false;\n\n  // found\n\n  const markupRange = {\n    anchor: startMarkupPointAfter,\n    focus: endMarkupPointBefore,\n  };\n\n  if (!ignoreTrim) {\n    const markupText = getText(editor, markupRange);\n    if (markupText.trim() !== markupText) return false;\n  }\n\n  // delete end markup\n  if (endMarkup) {\n    endMarkupPointBefore = getPointBefore(editor, selection, {\n      matchString: endMarkup,\n    });\n    Transforms.delete(editor, {\n      at: {\n        anchor: endMarkupPointBefore,\n        focus: selection.anchor,\n      },\n    });\n  }\n\n  // add mark to the text between the markups\n  Transforms.select(editor, markupRange);\n  editor.addMark(type, true);\n  Transforms.collapse(editor, { edge: 'end' });\n  editor.removeMark(type);\n\n  // delete start markup\n  const startMarkupPointBefore = getPointBefore(editor, selection, {\n    matchString: startMarkup,\n    skipInvalid: true,\n  });\n  Transforms.delete(editor, {\n    at: {\n      anchor: startMarkupPointBefore,\n      focus: startMarkupPointAfter,\n    },\n  });\n\n  return true;\n};\n\nexport const autoformatBlock = (editor, type, at, { preFormat, format }) => {\n  Transforms.delete(editor, { at });\n\n  if (preFormat) {\n    preFormat(editor);\n  }\n\n  if (!format) {\n    Transforms.setNodes(\n      editor,\n      { type },\n      { match: (n) => Editor.isBlock(editor, n) },\n    );\n  } else {\n    format(editor);\n  }\n};\n\n/**\n * See {@link Range.isCollapsed}.\n * Return false if `range` is not defined.\n */\nexport const isCollapsed = (range) => !!range && Range.isCollapsed(range);\n\n/**\n * See {@link Editor.string}.\n * If `at` is not defined, return an empty string.\n */\nexport const getText = (editor, at) => (at && Editor.string(editor, at)) ?? '';\n\n/**\n * Get the bloc {\n * k above a location (default: selection).\n * If not found, return the editor entry.\n */\nexport const getBlockAbove = (editor, options = {}) =>\n  Editor.above(editor, {\n    match: (n) => Editor.isBlock(editor, n),\n    ...options,\n  }) || [editor, []];\n\n/**\n * Get the point from a location (default: selection).\n * If the location is a range, get the anchor point.\n * If the location is a path, get the point at this path with offset 0.\n * If `focus` is true, get the focus point.\n */\nexport const getPointFromLocation = (\n  editor,\n  { at = editor.selection, focus } = {},\n) => {\n  let point;\n  if (Range.isRange(at)) point = !focus ? at.anchor : at.focus;\n  if (Point.isPoint(at)) point = at;\n  if (Path.isPath(at)) point = { path: at, offset: 0 };\n\n  return point;\n};\n\n/**\n * Get the range from the start of the block above a location (default: selection) to the location.\n */\nexport const getRangeFromBlockStart = (editor, options = {}) => {\n  const [, path] = getBlockAbove(editor, options);\n\n  const start = Editor.start(editor, path);\n\n  const focus = getPointFromLocation(editor, options);\n\n  if (!focus) return;\n\n  return { anchor: start, focus };\n};\n\n/**\n * Enables support for autoformatting actions.\n * Once a markup rule is validated, it does not check the following rules.\n */\nexport const withAutoformat = ({ rules }) => (editor) => {\n  const { insertText } = editor;\n\n  editor.insertText = (text) => {\n    if (!isCollapsed(editor.selection)) return insertText(text);\n\n    for (const {\n      trigger = ' ',\n      type,\n      markup,\n      preFormat,\n      format,\n      mode,\n      between,\n      ignoreTrim,\n      insertTrigger,\n    } of rules) {\n      const triggers = castArray(trigger);\n\n      // Check trigger\n      if (!triggers.includes(text)) continue;\n\n      const markups = castArray(markup);\n\n      const rangeFromBlockStart = getRangeFromBlockStart(editor);\n      const textFromBlockStart = getText(editor, rangeFromBlockStart);\n\n      const valid = () => insertTrigger && insertText(text);\n\n      if (markups.includes(textFromBlockStart)) {\n        // Start of the block\n        autoformatBlock(editor, type, rangeFromBlockStart, {\n          preFormat,\n          format,\n        });\n        return valid();\n      }\n\n      if (mode === 'inline-block') {\n        if (\n          autoformatInlineBlock(editor, { preFormat, markup, format, type })\n        ) {\n          return valid();\n        }\n      }\n\n      if (mode === 'inline') {\n        if (\n          autoformatInline(editor, {\n            type,\n            between,\n            ignoreTrim,\n            markup: Array.isArray(markup) ? markup[0] : markup,\n          })\n        ) {\n          return valid();\n        }\n      }\n    }\n\n    insertText(text);\n  };\n\n  return editor;\n};\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module"}