{"ast":null,"code":"import _objectSpread from \"/home/jakob/workspace/training-project/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _objectWithoutProperties from \"/home/jakob/workspace/training-project/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties\";\nconst _excluded = [\"location\", \"routes\", \"filter\"];\nimport { matchRoutes } from 'react-router-config';\nimport { mapSeries, isPromise } from './utils';\nimport { endGlobalLoad } from '@plone/volto/actions/asyncConnect/asyncConnect';\nexport function filterComponents(branch) {\n  return branch.reduce((result, _ref) => {\n    let {\n      route,\n      match\n    } = _ref;\n\n    if (route.component && route.component.reduxAsyncConnect) {\n      result.push([route.component, {\n        route,\n        match\n      }]);\n    }\n\n    return result;\n  }, []);\n}\nexport function loadAsyncConnect(_ref2) {\n  let {\n    location,\n    routes = [],\n    filter = () => true\n  } = _ref2,\n      rest = _objectWithoutProperties(_ref2, _excluded);\n\n  const layered = filterComponents(matchRoutes(routes, location.pathname));\n\n  if (layered.length === 0) {\n    return Promise.resolve();\n  } // this allows us to have nested promises, that rely on each other's completion\n  // cycle\n\n\n  return mapSeries(layered, _ref3 => {\n    let [component, routeParams] = _ref3;\n\n    if (component == null) {\n      return Promise.resolve();\n    } // Collect the results of each component\n\n\n    const results = [];\n    const asyncItems = component.reduxAsyncConnect;\n    const asyncItemsArr = [...component.reduxAsyncConnect]; // get array of results\n\n    asyncItems.forEach(item => {\n      if (filter(item, component)) {\n        // handle Volto's voltoLoadAsyncProps\n        if (item.key === 'voltoLoadAsyncProps') {\n          results.push(item);\n          const asyncPropsItems = item.promise(_objectSpread(_objectSpread(_objectSpread({}, rest), routeParams), {}, {\n            location,\n            routes\n          }));\n          asyncItemsArr.push(...asyncPropsItems);\n          asyncPropsItems.forEach(asyncPropItem => {\n            let innerPromiseOrResult = asyncPropItem && asyncPropItem.promise || asyncPropItem;\n\n            if (isPromise(innerPromiseOrResult)) {\n              innerPromiseOrResult = innerPromiseOrResult.catch(error => ({\n                error\n              }));\n            }\n\n            results.push(innerPromiseOrResult);\n          });\n          return;\n        } // handles default case of classic asyncConnect\n\n\n        let promiseOrResult = item.promise(_objectSpread(_objectSpread(_objectSpread({}, rest), routeParams), {}, {\n          location,\n          routes\n        }));\n\n        if (isPromise(promiseOrResult)) {\n          promiseOrResult = promiseOrResult.catch(error => ({\n            error\n          }));\n        }\n\n        results.push(promiseOrResult);\n      }\n    }); // map results to keys for prop injection\n\n    const resolver = finalResults => {\n      return Object.assign({}, finalResults.map((result, idx) => {\n        const {\n          key\n        } = asyncItemsArr[idx];\n        return key ? {\n          [key]: result\n        } : null;\n      }));\n    };\n\n    return Promise.all(results).then(resolver);\n  });\n}\nexport function loadOnServer(args) {\n  return loadAsyncConnect(args).then(() => {\n    args.store.dispatch(endGlobalLoad());\n  });\n}","map":{"version":3,"names":["matchRoutes","mapSeries","isPromise","endGlobalLoad","filterComponents","branch","reduce","result","route","match","component","reduxAsyncConnect","push","loadAsyncConnect","location","routes","filter","rest","layered","pathname","length","Promise","resolve","routeParams","results","asyncItems","asyncItemsArr","forEach","item","key","asyncPropsItems","promise","asyncPropItem","innerPromiseOrResult","catch","error","promiseOrResult","resolver","finalResults","Object","assign","map","idx","all","then","loadOnServer","args","store","dispatch"],"sources":["/home/jakob/workspace/training-project/node_modules/@plone/volto/src/helpers/AsyncConnect/ssr.js"],"sourcesContent":["import { matchRoutes } from 'react-router-config';\nimport { mapSeries, isPromise } from './utils';\nimport { endGlobalLoad } from '@plone/volto/actions/asyncConnect/asyncConnect';\n\nexport function filterComponents(branch) {\n  return branch.reduce((result, { route, match }) => {\n    if (route.component && route.component.reduxAsyncConnect) {\n      result.push([route.component, { route, match }]);\n    }\n\n    return result;\n  }, []);\n}\n\nexport function loadAsyncConnect({\n  location,\n  routes = [],\n  filter = () => true,\n  ...rest\n}) {\n  const layered = filterComponents(matchRoutes(routes, location.pathname));\n\n  if (layered.length === 0) {\n    return Promise.resolve();\n  }\n\n  // this allows us to have nested promises, that rely on each other's completion\n  // cycle\n  return mapSeries(layered, ([component, routeParams]) => {\n    if (component == null) {\n      return Promise.resolve();\n    }\n\n    // Collect the results of each component\n    const results = [];\n    const asyncItems = component.reduxAsyncConnect;\n    const asyncItemsArr = [...component.reduxAsyncConnect];\n\n    // get array of results\n    asyncItems.forEach((item) => {\n      if (filter(item, component)) {\n        // handle Volto's voltoLoadAsyncProps\n        if (item.key === 'voltoLoadAsyncProps') {\n          results.push(item);\n          const asyncPropsItems = item.promise({\n            ...rest,\n            ...routeParams,\n            location,\n            routes,\n          });\n          asyncItemsArr.push(...asyncPropsItems);\n\n          asyncPropsItems.forEach((asyncPropItem) => {\n            let innerPromiseOrResult =\n              (asyncPropItem && asyncPropItem.promise) || asyncPropItem;\n\n            if (isPromise(innerPromiseOrResult)) {\n              innerPromiseOrResult = innerPromiseOrResult.catch((error) => ({\n                error,\n              }));\n            }\n            results.push(innerPromiseOrResult);\n          });\n          return;\n        }\n\n        // handles default case of classic asyncConnect\n        let promiseOrResult = item.promise({\n          ...rest,\n          ...routeParams,\n          location,\n          routes,\n        });\n\n        if (isPromise(promiseOrResult)) {\n          promiseOrResult = promiseOrResult.catch((error) => ({ error }));\n        }\n\n        results.push(promiseOrResult);\n      }\n    });\n\n    // map results to keys for prop injection\n    const resolver = (finalResults) => {\n      return Object.assign(\n        {},\n        finalResults.map((result, idx) => {\n          const { key } = asyncItemsArr[idx];\n          return key ? { [key]: result } : null;\n        }),\n      );\n    };\n\n    return Promise.all(results).then(resolver);\n  });\n}\n\nexport function loadOnServer(args) {\n  return loadAsyncConnect(args).then(() => {\n    args.store.dispatch(endGlobalLoad());\n  });\n}\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module"}