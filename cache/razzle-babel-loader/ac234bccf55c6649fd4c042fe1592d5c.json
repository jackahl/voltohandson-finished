{"ast":null,"code":"import _objectSpread from \"/home/jakob/workspace/training-project/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport { isCmsUi } from '@plone/volto/helpers';\nconst LOCATION_CHANGE = '@@router/LOCATION_CHANGE';\nconst PROTECT_START = '@@loadProtector/START';\nconst PROTECT_END = '@@loadProtector/END';\nconst PROTECT_SKIPPED = '@@loadProtector/SKIPPED';\nconst GET_CONTENT_PENDING = 'GET_CONTENT_PENDING';\nconst GET_CONTENT_SUCCESS = 'GET_CONTENT_SUCCESS';\nconst GET_CONTENT_FAIL = 'GET_CONTENT_FAIL';\nconst RESET_CONTENT = 'RESET_CONTENT'; // ---\n// The load protector middlewares have multiple purposes.\n//\n// 1. Maintained a delayed location that can be used to trigger an UI\n// change (such as scroll to top) after all content for the page has been\n// loaded.\n//\n// 2. When moving from a non content route to a content route, issue\n// a data reset before the content load operation. - However do not do\n// such a reset when navigating between two content routes.\n// ---\n\nexport const protectLoadStart = _ref => {\n  let {\n    dispatch,\n    getState\n  } = _ref;\n  return next => action => {\n    if (typeof action === 'function') {\n      return next(action);\n    }\n\n    switch (action.type) {\n      case LOCATION_CHANGE:\n        const {\n          location\n        } = action.payload;\n        const {\n          pathname: path\n        } = location;\n        const currentPath = getState().router.location.pathname;\n        const result = next(action);\n\n        if (isCmsUi(path)) {\n          // Next path: isCmsUI, Non Content. There is no\n          // loading here, so skip counting altogether.\n          // Will update the delayed location constantly.\n          dispatch({\n            type: PROTECT_SKIPPED,\n            location\n          });\n        } else {\n          dispatch({\n            type: PROTECT_START,\n            location,\n            // Only reset before the fetch, if we depart from\n            // a not isCmsUi, Content pass. However, reset will\n            // not occur if moving between two content paths,\n            // only the postponed location will be booked.\n            resetBeforeFetch: isCmsUi(currentPath)\n          });\n        }\n\n        return result;\n\n      default:\n        return next(action);\n    }\n  };\n}; // Note that there is a bit of heuristics here. We assume that every action\n// like this is beginning/ending an action. If this logic fails then the counting\n// will be off, resulting either a premature or an indefinitely missing state change.\n\nconst isRequestAction = action => action.type.endsWith('_PENDING');\n\nconst isResponseAction = action => action.type.endsWith('_SUCCESS') || action.type.endsWith('_FAIL'); // Action map defines an action to be emitted before the key action\n\n\nconst mapActions = {\n  [GET_CONTENT_PENDING]: RESET_CONTENT\n};\nexport const protectLoadEnd = _ref2 => {\n  let {\n    dispatch,\n    getState\n  } = _ref2;\n  return next => action => {\n    if (typeof action === 'function') {\n      return next(action);\n    }\n\n    const {\n      isCounting,\n      resetBeforeFetch,\n      requestCount\n    } = getState().loadProtector;\n\n    if (resetBeforeFetch) {\n      const type = mapActions[action.type];\n\n      if (type) {\n        dispatch({\n          type\n        });\n      }\n    }\n\n    if (isCounting && requestCount === 1 && isResponseAction(action)) {\n      setTimeout(() => dispatch({\n        type: PROTECT_END\n      }), 0);\n    }\n\n    return next(action);\n  };\n};\nexport function loadProtector() {\n  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  switch (action.type) {\n    case PROTECT_START:\n      return _objectSpread(_objectSpread({}, state), {}, {\n        requestCount: 0,\n        isCounting: true,\n        resetBeforeFetch: action.resetBeforeFetch,\n        postponedLocation: action.location\n      });\n\n    case PROTECT_END:\n      return _objectSpread(_objectSpread({}, state), {}, {\n        requestCount: 0,\n        isCounting: false,\n        resetBeforeFetch: false\n      });\n\n    case PROTECT_SKIPPED:\n      return _objectSpread(_objectSpread({}, state), {}, {\n        requestCount: 0,\n        isCounting: false,\n        resetBeforeFetch: false,\n        postponedLocation: null,\n        location: action.location\n      });\n\n    case GET_CONTENT_SUCCESS:\n    case GET_CONTENT_FAIL:\n      if (state.isCounting) {\n        return _objectSpread(_objectSpread({}, state), {}, {\n          requestCount: state.requestCount - 1,\n          postponedLocation: null,\n          location: state.postponedLocation\n        });\n      } else {\n        return state;\n      }\n\n    case RESET_CONTENT:\n      if (state.resetBeforeFetch) {\n        return _objectSpread(_objectSpread({}, state), {}, {\n          resetBeforeFetch: false\n        });\n      } else {\n        return state;\n      }\n\n    default:\n      const {\n        isCounting,\n        requestCount\n      } = state;\n\n      if (isCounting && isRequestAction(action)) {\n        return _objectSpread(_objectSpread({}, state), {}, {\n          requestCount: requestCount + 1\n        });\n      } else if (isCounting && isResponseAction(action)) {\n        return _objectSpread(_objectSpread({}, state), {}, {\n          requestCount: requestCount - 1\n        });\n      } else {\n        return state;\n      }\n\n  }\n}","map":{"version":3,"names":["isCmsUi","LOCATION_CHANGE","PROTECT_START","PROTECT_END","PROTECT_SKIPPED","GET_CONTENT_PENDING","GET_CONTENT_SUCCESS","GET_CONTENT_FAIL","RESET_CONTENT","protectLoadStart","dispatch","getState","next","action","type","location","payload","pathname","path","currentPath","router","result","resetBeforeFetch","isRequestAction","endsWith","isResponseAction","mapActions","protectLoadEnd","isCounting","requestCount","loadProtector","setTimeout","state","postponedLocation"],"sources":["/home/jakob/workspace/training-project/node_modules/@plone/volto/src/middleware/storeProtectLoadUtils.js"],"sourcesContent":["import { isCmsUi } from '@plone/volto/helpers';\n\nconst LOCATION_CHANGE = '@@router/LOCATION_CHANGE';\nconst PROTECT_START = '@@loadProtector/START';\nconst PROTECT_END = '@@loadProtector/END';\nconst PROTECT_SKIPPED = '@@loadProtector/SKIPPED';\nconst GET_CONTENT_PENDING = 'GET_CONTENT_PENDING';\nconst GET_CONTENT_SUCCESS = 'GET_CONTENT_SUCCESS';\nconst GET_CONTENT_FAIL = 'GET_CONTENT_FAIL';\nconst RESET_CONTENT = 'RESET_CONTENT';\n\n// ---\n// The load protector middlewares have multiple purposes.\n//\n// 1. Maintained a delayed location that can be used to trigger an UI\n// change (such as scroll to top) after all content for the page has been\n// loaded.\n//\n// 2. When moving from a non content route to a content route, issue\n// a data reset before the content load operation. - However do not do\n// such a reset when navigating between two content routes.\n// ---\n\nexport const protectLoadStart = ({ dispatch, getState }) => (next) => (\n  action,\n) => {\n  if (typeof action === 'function') {\n    return next(action);\n  }\n  switch (action.type) {\n    case LOCATION_CHANGE:\n      const { location } = action.payload;\n      const { pathname: path } = location;\n      const currentPath = getState().router.location.pathname;\n      const result = next(action);\n      if (isCmsUi(path)) {\n        // Next path: isCmsUI, Non Content. There is no\n        // loading here, so skip counting altogether.\n        // Will update the delayed location constantly.\n        dispatch({\n          type: PROTECT_SKIPPED,\n          location,\n        });\n      } else {\n        dispatch({\n          type: PROTECT_START,\n          location,\n          // Only reset before the fetch, if we depart from\n          // a not isCmsUi, Content pass. However, reset will\n          // not occur if moving between two content paths,\n          // only the postponed location will be booked.\n          resetBeforeFetch: isCmsUi(currentPath),\n        });\n      }\n      return result;\n    default:\n      return next(action);\n  }\n};\n\n// Note that there is a bit of heuristics here. We assume that every action\n// like this is beginning/ending an action. If this logic fails then the counting\n// will be off, resulting either a premature or an indefinitely missing state change.\nconst isRequestAction = (action) => action.type.endsWith('_PENDING');\nconst isResponseAction = (action) =>\n  action.type.endsWith('_SUCCESS') || action.type.endsWith('_FAIL');\n\n// Action map defines an action to be emitted before the key action\nconst mapActions = {\n  [GET_CONTENT_PENDING]: RESET_CONTENT,\n};\n\nexport const protectLoadEnd = ({ dispatch, getState }) => (next) => (\n  action,\n) => {\n  if (typeof action === 'function') {\n    return next(action);\n  }\n  const {\n    isCounting,\n    resetBeforeFetch,\n    requestCount,\n  } = getState().loadProtector;\n  if (resetBeforeFetch) {\n    const type = mapActions[action.type];\n    if (type) {\n      dispatch({ type });\n    }\n  }\n  if (isCounting && requestCount === 1 && isResponseAction(action)) {\n    setTimeout(\n      () =>\n        dispatch({\n          type: PROTECT_END,\n        }),\n      0,\n    );\n  }\n  return next(action);\n};\n\nexport function loadProtector(state = {}, action = {}) {\n  switch (action.type) {\n    case PROTECT_START:\n      return {\n        ...state,\n        requestCount: 0,\n        isCounting: true,\n        resetBeforeFetch: action.resetBeforeFetch,\n        postponedLocation: action.location,\n      };\n    case PROTECT_END:\n      return {\n        ...state,\n        requestCount: 0,\n        isCounting: false,\n        resetBeforeFetch: false,\n      };\n    case PROTECT_SKIPPED:\n      return {\n        ...state,\n        requestCount: 0,\n        isCounting: false,\n        resetBeforeFetch: false,\n        postponedLocation: null,\n        location: action.location,\n      };\n    case GET_CONTENT_SUCCESS:\n    case GET_CONTENT_FAIL:\n      if (state.isCounting) {\n        return {\n          ...state,\n          requestCount: state.requestCount - 1,\n          postponedLocation: null,\n          location: state.postponedLocation,\n        };\n      } else {\n        return state;\n      }\n    case RESET_CONTENT:\n      if (state.resetBeforeFetch) {\n        return {\n          ...state,\n          resetBeforeFetch: false,\n        };\n      } else {\n        return state;\n      }\n    default:\n      const { isCounting, requestCount } = state;\n      if (isCounting && isRequestAction(action)) {\n        return {\n          ...state,\n          requestCount: requestCount + 1,\n        };\n      } else if (isCounting && isResponseAction(action)) {\n        return {\n          ...state,\n          requestCount: requestCount - 1,\n        };\n      } else {\n        return state;\n      }\n  }\n}\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module"}