{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { Editor, Text, Transforms } from 'slate';\nimport { deserialize } from '@plone/volto-slate/editor/deserialize';\nimport { createBlock, createDefaultBlock, MIMETypeName, normalizeExternalData } from '@plone/volto-slate/utils';\nimport { isBlockActive } from '../../utils/blocks';\nexport const insertData = editor => {\n  editor.dataTransferHandlers = _objectSpread(_objectSpread({}, editor.dataTransferHandlers), {}, {\n    'application/x-slate-fragment': (dt, fullMime) => {\n      const decoded = decodeURIComponent(window.atob(dt));\n      const parsed = JSON.parse(decoded);\n      editor.beforeInsertFragment && editor.beforeInsertFragment(parsed);\n      editor.insertFragment(parsed);\n      return true;\n    },\n    'text/html': (dt, fullMime) => {\n      const parsed = new DOMParser().parseFromString(dt, 'text/html');\n      const body = parsed.getElementsByTagName('google-sheets-html-origin').length > 0 ? parsed.querySelector('google-sheets-html-origin > table') : parsed.body;\n      let fragment;\n      const val = deserialize(editor, body);\n      fragment = Array.isArray(val) ? val : [val]; // external normalization\n\n      fragment = normalizeExternalData(editor, fragment);\n      editor.insertFragment(fragment);\n      return true;\n    },\n    'text/plain': (dt, fullMime) => {\n      const text = dt;\n      if (!text) return;\n      const paras = text.split('\\n'); // If just 1 line insert text\n\n      if (paras.length === 1) {\n        Transforms.insertText(editor, paras[0]);\n        return true;\n      } // Check if inside a list\n\n\n      const fragment = isBlockActive(editor, 'ul') || isBlockActive(editor, 'ol') ? paras.map(p => createBlock('li', [{\n        text: p\n      }])) : paras.map(p => createDefaultBlock([{\n        text: p\n      }])); // check if fragment is p with text and insert as fragment if so\n\n      const fragmentContainsText = f => {\n        var trigger = false;\n\n        if (f && f[0]) {\n          f.forEach(frag => {\n            if (frag.type === 'p') {\n              if (frag.children) {\n                frag.children.forEach(child => {\n                  if (child.text) {\n                    trigger = true;\n                  }\n                });\n              }\n            }\n          });\n        }\n\n        return trigger;\n      }; // When there's already text in the editor, insert a fragment, not nodes\n\n\n      const containsText = fragmentContainsText(fragment);\n\n      if (fragment && containsText) {\n        Transforms.insertFragment(editor, fragment);\n      }\n\n      if (Editor.string(editor, [])) {\n        if (Array.isArray(fragment) && fragment.findIndex(b => Editor.isInline(b) || Text.isText(b)) > -1) {\n          // console.log('insert fragment', fragment);\n          // TODO: we want normalization also when dealing with fragments\n          Transforms.insertFragment(editor, fragment);\n          return true;\n        }\n      }\n\n      const nodes = normalizeExternalData(editor, fragment);\n\n      if (!containsText) {\n        Transforms.insertNodes(editor, nodes);\n      }\n\n      return true;\n    }\n  }); // TODO: use the rtf data to get the embedded images.\n  // const text = data.getData('text/rtf');\n\n  const {\n    insertData\n  } = editor; // TODO: move this to extensions/insertData\n  // TODO: update and improve comments & docs related to\n  // `dataTransferFormatsOrder` and `dataTransferHandlers` features\n\n  editor.insertData = data => {\n    if (editor.beforeInsertData) {\n      editor.beforeInsertData(data);\n    } // debugger;\n\n\n    for (let i = 0; i < editor.dataTransferFormatsOrder.length; ++i) {\n      const dt = editor.dataTransferFormatsOrder[i];\n\n      if (dt === 'files') {\n        const {\n          files\n        } = data;\n\n        if (files && files.length > 0) {\n          // or handled here\n          return editor.dataTransferHandlers['files'](files);\n        }\n\n        continue;\n      }\n\n      const satisfyingFormats = data.types.filter(y => new MIMETypeName(dt).matches(new MIMETypeName(y)));\n\n      for (let j = 0; j < satisfyingFormats.length; ++j) {\n        const y = satisfyingFormats[j];\n\n        if (editor.dataTransferHandlers[dt](data.getData(y), y)) {\n          // handled here\n          return true;\n        }\n      }\n    } // not handled until this point\n\n\n    return insertData(data);\n  };\n\n  return editor;\n};","map":{"version":3,"names":["Editor","Text","Transforms","deserialize","createBlock","createDefaultBlock","MIMETypeName","normalizeExternalData","isBlockActive","insertData","editor","dataTransferHandlers","dt","fullMime","decoded","decodeURIComponent","window","atob","parsed","JSON","parse","beforeInsertFragment","insertFragment","DOMParser","parseFromString","body","getElementsByTagName","length","querySelector","fragment","val","Array","isArray","text","paras","split","insertText","map","p","fragmentContainsText","f","trigger","forEach","frag","type","children","child","containsText","string","findIndex","b","isInline","isText","nodes","insertNodes","data","beforeInsertData","i","dataTransferFormatsOrder","files","satisfyingFormats","types","filter","y","matches","j","getData"],"sources":["/home/jakob/workspace/training-project/node_modules/@plone/volto/packages/volto-slate/src/editor/extensions/insertData.js"],"sourcesContent":["import { Editor, Text, Transforms } from 'slate';\nimport { deserialize } from '@plone/volto-slate/editor/deserialize';\nimport {\n  createBlock,\n  createDefaultBlock,\n  MIMETypeName,\n  normalizeExternalData,\n} from '@plone/volto-slate/utils';\nimport { isBlockActive } from '../../utils/blocks';\n\nexport const insertData = (editor) => {\n  editor.dataTransferHandlers = {\n    ...editor.dataTransferHandlers,\n    'application/x-slate-fragment': (dt, fullMime) => {\n      const decoded = decodeURIComponent(window.atob(dt));\n      const parsed = JSON.parse(decoded);\n      editor.beforeInsertFragment && editor.beforeInsertFragment(parsed);\n      editor.insertFragment(parsed);\n\n      return true;\n    },\n    'text/html': (dt, fullMime) => {\n      const parsed = new DOMParser().parseFromString(dt, 'text/html');\n\n      const body =\n        parsed.getElementsByTagName('google-sheets-html-origin').length > 0\n          ? parsed.querySelector('google-sheets-html-origin > table')\n          : parsed.body;\n\n      let fragment;\n\n      const val = deserialize(editor, body);\n      fragment = Array.isArray(val) ? val : [val];\n\n      // external normalization\n      fragment = normalizeExternalData(editor, fragment);\n\n      editor.insertFragment(fragment);\n\n      return true;\n    },\n    'text/plain': (dt, fullMime) => {\n      const text = dt;\n      if (!text) return;\n\n      const paras = text.split('\\n');\n\n      // If just 1 line insert text\n      if (paras.length === 1) {\n        Transforms.insertText(editor, paras[0]);\n        return true;\n      }\n\n      // Check if inside a list\n      const fragment =\n        isBlockActive(editor, 'ul') || isBlockActive(editor, 'ol')\n          ? paras.map((p) => createBlock('li', [{ text: p }]))\n          : paras.map((p) => createDefaultBlock([{ text: p }]));\n\n      // check if fragment is p with text and insert as fragment if so\n      const fragmentContainsText = (f) => {\n        var trigger = false;\n        if (f && f[0]) {\n          f.forEach((frag) => {\n            if (frag.type === 'p') {\n              if (frag.children) {\n                frag.children.forEach((child) => {\n                  if (child.text) {\n                    trigger = true;\n                  }\n                });\n              }\n            }\n          });\n        }\n        return trigger;\n      };\n\n      // When there's already text in the editor, insert a fragment, not nodes\n      const containsText = fragmentContainsText(fragment);\n      if (fragment && containsText) {\n        Transforms.insertFragment(editor, fragment);\n      }\n\n      if (Editor.string(editor, [])) {\n        if (\n          Array.isArray(fragment) &&\n          fragment.findIndex((b) => Editor.isInline(b) || Text.isText(b)) > -1\n        ) {\n          // console.log('insert fragment', fragment);\n          // TODO: we want normalization also when dealing with fragments\n          Transforms.insertFragment(editor, fragment);\n          return true;\n        }\n      }\n\n      const nodes = normalizeExternalData(editor, fragment);\n      if (!containsText) {\n        Transforms.insertNodes(editor, nodes);\n      }\n\n      return true;\n    },\n  };\n\n  // TODO: use the rtf data to get the embedded images.\n  // const text = data.getData('text/rtf');\n\n  const { insertData } = editor;\n\n  // TODO: move this to extensions/insertData\n  // TODO: update and improve comments & docs related to\n  // `dataTransferFormatsOrder` and `dataTransferHandlers` features\n  editor.insertData = (data) => {\n    if (editor.beforeInsertData) {\n      editor.beforeInsertData(data);\n    }\n\n    // debugger;\n    for (let i = 0; i < editor.dataTransferFormatsOrder.length; ++i) {\n      const dt = editor.dataTransferFormatsOrder[i];\n      if (dt === 'files') {\n        const { files } = data;\n        if (files && files.length > 0) {\n          // or handled here\n          return editor.dataTransferHandlers['files'](files);\n        }\n        continue;\n      }\n      const satisfyingFormats = data.types.filter((y) =>\n        new MIMETypeName(dt).matches(new MIMETypeName(y)),\n      );\n      for (let j = 0; j < satisfyingFormats.length; ++j) {\n        const y = satisfyingFormats[j];\n        if (editor.dataTransferHandlers[dt](data.getData(y), y)) {\n          // handled here\n          return true;\n        }\n      }\n    }\n    // not handled until this point\n    return insertData(data);\n  };\n\n  return editor;\n};\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module"}