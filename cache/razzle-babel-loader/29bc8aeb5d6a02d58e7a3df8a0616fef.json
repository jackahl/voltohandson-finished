{"ast":null,"code":"import { Editor } from 'slate';\n/**\n * @param {Point} point The point to verify.\n * @returns {boolean} Whether it refers to a (leaf) Text node in the closest-to-root level it can be.\n */\n\nexport const isPointAtRoot = point => point.path.length === 2;\n/**\n * @summary Returns true if the specified range has any of its edges at the\n * closest-to-root level a Point can be (a Point can only reffer to Text\n * nodes).\n * @description It does not assure the caller about whether the contents of the\n * range are at block level, but it does assure that one of the edges of the\n * given range is at closest-to-root level it can be. A range can cover inner\n * node children though. If through \"inner node child\" we also understand the\n * closest-to-root level Leaf nodes can be (taking into account this: Editor\n * - level 0, blocks - level 1, blocks and leaves - level 2, it is level 2)\n *   then the cursor specified by the given range can include inner node\n *   childs and the return value can be true at the same time. Practically the\n *   cursor is always at block level since nothing exists outside blocks in\n *   Slate and is always in Text nodes since a Point can only reffer to an\n *   offset in a Text node.\n * @param {Range} range Must be a valid `Range`, not `null` or `undefined`.\n * @returns {boolean}\n */\n\nexport const isRangeAtRoot = range => {\n  return isPointAtRoot(range.anchor) || isPointAtRoot(range.focus);\n};\n/**\n * The block in a valid Slate document according to our schema can be here\n * either a Slate block that touches the root or a Slate inline (the other\n * possibility, a leaf Text node is excluded because we are taking the\n * parent of the selection).\n *\n * @param {Editor} editor\n * @param {Range} range\n *\n * @returns {boolean} true if the range (usually the selection) can be split\n * into two editors (usually Volto Slate Text blocks)\n */\n\nexport const rangeIsInSplittableNode = (editor, range) => {\n  const [block] = Editor.parent(editor, range);\n  return range && (isRangeAtRoot(range) || editor.isInline(block));\n};","map":{"version":3,"names":["Editor","isPointAtRoot","point","path","length","isRangeAtRoot","range","anchor","focus","rangeIsInSplittableNode","editor","block","parent","isInline"],"sources":["/home/jakob/workspace/training-project/node_modules/@plone/volto/packages/volto-slate/src/utils/internals.js"],"sourcesContent":["import { Editor } from 'slate';\n\n/**\n * @param {Point} point The point to verify.\n * @returns {boolean} Whether it refers to a (leaf) Text node in the closest-to-root level it can be.\n */\nexport const isPointAtRoot = (point) => point.path.length === 2;\n\n/**\n * @summary Returns true if the specified range has any of its edges at the\n * closest-to-root level a Point can be (a Point can only reffer to Text\n * nodes).\n * @description It does not assure the caller about whether the contents of the\n * range are at block level, but it does assure that one of the edges of the\n * given range is at closest-to-root level it can be. A range can cover inner\n * node children though. If through \"inner node child\" we also understand the\n * closest-to-root level Leaf nodes can be (taking into account this: Editor\n * - level 0, blocks - level 1, blocks and leaves - level 2, it is level 2)\n *   then the cursor specified by the given range can include inner node\n *   childs and the return value can be true at the same time. Practically the\n *   cursor is always at block level since nothing exists outside blocks in\n *   Slate and is always in Text nodes since a Point can only reffer to an\n *   offset in a Text node.\n * @param {Range} range Must be a valid `Range`, not `null` or `undefined`.\n * @returns {boolean}\n */\nexport const isRangeAtRoot = (range) => {\n  return isPointAtRoot(range.anchor) || isPointAtRoot(range.focus);\n};\n\n/**\n * The block in a valid Slate document according to our schema can be here\n * either a Slate block that touches the root or a Slate inline (the other\n * possibility, a leaf Text node is excluded because we are taking the\n * parent of the selection).\n *\n * @param {Editor} editor\n * @param {Range} range\n *\n * @returns {boolean} true if the range (usually the selection) can be split\n * into two editors (usually Volto Slate Text blocks)\n */\nexport const rangeIsInSplittableNode = (editor, range) => {\n  const [block] = Editor.parent(editor, range);\n  return range && (isRangeAtRoot(range) || editor.isInline(block));\n};\n"],"mappings":"AAAA,SAASA,MAAT,QAAuB,OAAvB;AAEA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,aAAa,GAAIC,KAAD,IAAWA,KAAK,CAACC,IAAN,CAAWC,MAAX,KAAsB,CAAvD;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,aAAa,GAAIC,KAAD,IAAW;EACtC,OAAOL,aAAa,CAACK,KAAK,CAACC,MAAP,CAAb,IAA+BN,aAAa,CAACK,KAAK,CAACE,KAAP,CAAnD;AACD,CAFM;AAIP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,uBAAuB,GAAG,CAACC,MAAD,EAASJ,KAAT,KAAmB;EACxD,MAAM,CAACK,KAAD,IAAUX,MAAM,CAACY,MAAP,CAAcF,MAAd,EAAsBJ,KAAtB,CAAhB;EACA,OAAOA,KAAK,KAAKD,aAAa,CAACC,KAAD,CAAb,IAAwBI,MAAM,CAACG,QAAP,CAAgBF,KAAhB,CAA7B,CAAZ;AACD,CAHM"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module"}