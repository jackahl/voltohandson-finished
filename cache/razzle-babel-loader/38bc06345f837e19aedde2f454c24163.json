{"ast":null,"code":"import _toPairs from \"lodash/toPairs\";\nimport _keys from \"lodash/keys\";\nimport _isObject from \"lodash/isObject\";\nimport _find from \"lodash/find\";\nimport _endsWith from \"lodash/endsWith\";\nimport _without from \"lodash/without\";\nimport _omit from \"lodash/omit\";\nconst _excluded = [\"data\", \"intl\"];\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport move from 'lodash-move';\nimport { v4 as uuid } from 'uuid';\nimport config from '@plone/volto/registry';\nimport { applySchemaEnhancer } from '@plone/volto/helpers';\n/**\n * Get blocks field.\n * @function getBlocksFieldname\n * @param {Object} props Properties.\n * @return {string} Field name of the blocks\n */\n\nexport function getBlocksFieldname(props) {\n  return _find(_keys(props), key => key !== 'volto.blocks' && _endsWith(key, 'blocks')) || null;\n}\n/**\n * Get blocks layout field.\n * @function getBlocksLayoutFieldname\n * @param {Object} props Properties.\n * @return {string} Field name of the blocks layout\n */\n\nexport function getBlocksLayoutFieldname(props) {\n  return _find(_keys(props), key => key !== 'volto.blocks' && _endsWith(key, 'blocks_layout')) || null;\n}\n/**\n * Has blocks data.\n * @function hasBlocksData\n * @param {Object} props Properties.\n * @return {boolean} True if it has blocks data.\n */\n\nexport function hasBlocksData(props) {\n  return _find(_keys(props), key => key !== 'volto.blocks' && _endsWith(key, 'blocks')) !== undefined;\n}\n/**\n * Pluggable method to test if a block has a set value (any non-empty value)\n * @function blockHasValue\n * @param {Object} data Block data\n * @return {boolean} True if block has a non-empty value\n */\n\nexport function blockHasValue(data) {\n  var _blocks$blocksConfig$;\n\n  const {\n    blocks\n  } = config;\n  const blockType = data['@type'];\n  const check = (_blocks$blocksConfig$ = blocks.blocksConfig[blockType]) === null || _blocks$blocksConfig$ === void 0 ? void 0 : _blocks$blocksConfig$.blockHasValue;\n\n  if (!check) {\n    return true;\n  }\n\n  return check(data);\n}\n/**\n * Get block pairs of [id, block] from content properties\n * @function getBlocks\n * @param {Object} properties\n * @return {Array} a list of block [id, value] pairs, in order from layout\n */\n\nexport const getBlocks = properties => {\n  var _properties$blocksLay, _properties$blocksLay2;\n\n  const blocksFieldName = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n  return ((_properties$blocksLay = properties[blocksLayoutFieldname]) === null || _properties$blocksLay === void 0 ? void 0 : (_properties$blocksLay2 = _properties$blocksLay.items) === null || _properties$blocksLay2 === void 0 ? void 0 : _properties$blocksLay2.map(n => [n, properties[blocksFieldName][n]])) || [];\n};\n/**\n * Move block to different location index within blocks_layout\n * @function moveBlock\n * @param {Object} formData Form data\n * @param {number} source index within form blocks_layout items\n * @param {number} destination index within form blocks_layout items\n * @return {Object} New form data\n */\n\nexport function moveBlock(formData, source, destination) {\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  return _objectSpread(_objectSpread({}, formData), {}, {\n    [blocksLayoutFieldname]: {\n      items: move(formData[blocksLayoutFieldname].items, source, destination)\n    }\n  });\n}\n/**\n * Delete block by id\n * @function deleteBlock\n * @param {Object} formData Form data\n * @param {string} blockId Block uid\n * @return {Object} New form data\n */\n\nexport function deleteBlock(formData, blockId) {\n  const blocksFieldname = getBlocksFieldname(formData);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n\n  let newFormData = _objectSpread(_objectSpread({}, formData), {}, {\n    [blocksLayoutFieldname]: {\n      items: _without(formData[blocksLayoutFieldname].items, blockId)\n    },\n    [blocksFieldname]: _omit(formData[blocksFieldname], [blockId])\n  });\n\n  if (newFormData[blocksLayoutFieldname].items.length === 0) {\n    newFormData = addBlock(newFormData, config.settings.defaultBlockType, 0);\n  }\n\n  return newFormData;\n}\n/**\n * Add block\n * @function addBlock\n * @param {Object} formData Form data\n * @param {string} type Block type\n * @param {number} index Destination index\n * @return {Array} New block id, New form data\n */\n\nexport function addBlock(formData, type, index) {\n  const {\n    settings\n  } = config;\n  const id = uuid();\n  const idTrailingBlock = uuid();\n  const blocksFieldname = getBlocksFieldname(formData);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  const totalItems = formData[blocksLayoutFieldname].items.length;\n  const insert = index === -1 ? totalItems : index;\n  return [id, _objectSpread(_objectSpread({}, formData), {}, {\n    [blocksLayoutFieldname]: {\n      items: [...formData[blocksLayoutFieldname].items.slice(0, insert), id, ...(type !== settings.defaultBlockType ? [idTrailingBlock] : []), ...formData[blocksLayoutFieldname].items.slice(insert)]\n    },\n    [blocksFieldname]: _objectSpread(_objectSpread({}, formData[blocksFieldname]), {}, {\n      [id]: {\n        '@type': type\n      }\n    }, type !== settings.defaultBlockType && {\n      [idTrailingBlock]: {\n        '@type': settings.defaultBlockType\n      }\n    }),\n    selected: id\n  })];\n}\n/**\n * Mutate block\n * @function mutateBlock\n * @param {Object} formData Form data\n * @param {string} id Block uid to mutate\n * @param {number} value Block's new value\n * @return {Object} New form data\n */\n\nexport function mutateBlock(formData, id, value) {\n  const {\n    settings\n  } = config;\n  const blocksFieldname = getBlocksFieldname(formData);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  const index = formData[blocksLayoutFieldname].items.indexOf(id) + 1; // Test if block at index is already a placeholder (trailing) block\n\n  const trailId = formData[blocksLayoutFieldname].items[index];\n\n  if (trailId) {\n    const block = formData[blocksFieldname][trailId];\n\n    if (!blockHasValue(block)) {\n      return _objectSpread(_objectSpread({}, formData), {}, {\n        [blocksFieldname]: _objectSpread(_objectSpread({}, formData[blocksFieldname]), {}, {\n          [id]: value || null\n        })\n      });\n    }\n  }\n\n  const idTrailingBlock = uuid();\n  return _objectSpread(_objectSpread({}, formData), {}, {\n    [blocksFieldname]: _objectSpread(_objectSpread({}, formData[blocksFieldname]), {}, {\n      [id]: value || null,\n      [idTrailingBlock]: {\n        '@type': settings.defaultBlockType\n      }\n    }),\n    [blocksLayoutFieldname]: {\n      items: [...formData[blocksLayoutFieldname].items.slice(0, index), idTrailingBlock, ...formData[blocksLayoutFieldname].items.slice(index)]\n    }\n  });\n}\n/**\n * Insert new block before another block\n * @function insertBlock\n * @param {Object} formData Form data\n * @param {string} id Insert new block before the block with this id\n * @param {number} value New block's value\n * @return {Array} New block id, New form data\n */\n\nexport function insertBlock(formData, id, value, current = {}) {\n  const blocksFieldname = getBlocksFieldname(formData);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  const index = formData[blocksLayoutFieldname].items.indexOf(id);\n  const newBlockId = uuid();\n  return [newBlockId, _objectSpread(_objectSpread({}, formData), {}, {\n    [blocksFieldname]: _objectSpread(_objectSpread({}, formData[blocksFieldname]), {}, {\n      [newBlockId]: value || null,\n      [id]: _objectSpread(_objectSpread({}, formData[blocksFieldname][id]), current)\n    }),\n    [blocksLayoutFieldname]: {\n      items: [...formData[blocksLayoutFieldname].items.slice(0, index), newBlockId, ...formData[blocksLayoutFieldname].items.slice(index)]\n    }\n  })];\n}\n/**\n * Change block\n * @function changeBlock\n * @param {Object} formData Form data\n * @param {string} id Block uid to change\n * @param {number} value Block's new value\n * @return {Object} New form data\n */\n\nexport function changeBlock(formData, id, value) {\n  const blocksFieldname = getBlocksFieldname(formData);\n  return _objectSpread(_objectSpread({}, formData), {}, {\n    [blocksFieldname]: _objectSpread(_objectSpread({}, formData[blocksFieldname]), {}, {\n      [id]: value || null\n    })\n  });\n}\n/**\n * Get the next block UID within form\n * @function nextBlockId\n * @param {Object} formData Form data\n * @param {string} currentBlock Block uid\n * @return {string} Next block uid\n */\n\nexport function nextBlockId(formData, currentBlock) {\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  const currentIndex = formData[blocksLayoutFieldname].items.indexOf(currentBlock);\n\n  if (currentIndex === formData[blocksLayoutFieldname].items.length - 1) {\n    // We are already at the bottom block don't do anything\n    return null;\n  }\n\n  const newIndex = currentIndex + 1;\n  return formData[blocksLayoutFieldname].items[newIndex];\n}\n/**\n * Get the previous block UID within form\n * @function previousBlockId\n * @param {Object} formData Form data\n * @param {string} currentBlock Block uid\n * @return {string} Previous block uid\n */\n\nexport function previousBlockId(formData, currentBlock) {\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  const currentIndex = formData[blocksLayoutFieldname].items.indexOf(currentBlock);\n\n  if (currentIndex === 0) {\n    // We are already at the top block don't do anything\n    return null;\n  }\n\n  const newindex = currentIndex - 1;\n  return formData[blocksLayoutFieldname].items[newindex];\n}\n/**\n * Generate empty block form\n * @function emptyBlocksForm\n * @param {Object} formData Form data\n * @return {Object} Empty blocks form with one defaultBlockType block\n */\n\nexport function emptyBlocksForm() {\n  const {\n    settings\n  } = config;\n  const id = uuid();\n  return {\n    blocks: {\n      [id]: {\n        '@type': settings.defaultBlockType\n      }\n    },\n    blocks_layout: {\n      items: [id]\n    }\n  };\n}\n/**\n * Recursively discover blocks in data and call the provided callback\n * @function visitBlocks\n * @param {Object} content A content data structure (an object with blocks and blocks_layout)\n * @param {Function} callback A function to call on each discovered block\n */\n\nexport function visitBlocks(content, callback) {\n  const queue = getBlocks(content);\n\n  while (queue.length > 0) {\n    const [id, blockdata] = queue.shift();\n    callback([id, blockdata]); // assumes that a block value is like: {blocks, blocks_layout} or\n    // { data: {blocks, blocks_layout}}\n\n    if (Object.keys(blockdata || {}).indexOf('blocks') > -1) {\n      queue.push(...getBlocks(blockdata));\n    }\n\n    if (Object.keys((blockdata === null || blockdata === void 0 ? void 0 : blockdata.data) || {}).indexOf('blocks') > -1) {\n      queue.push(...getBlocks(blockdata.data));\n    }\n  }\n}\n/**\n * Initializes data with the default values coming from schema\n */\n\nexport function applySchemaDefaults({\n  data = {},\n  schema\n}) {\n  const derivedData = _objectSpread(_objectSpread({}, Object.keys(schema.properties).reduce((accumulator, currentField) => {\n    return schema.properties[currentField].default ? _objectSpread(_objectSpread({}, accumulator), {}, {\n      [currentField]: schema.properties[currentField].default\n    }) : accumulator;\n  }, {})), data);\n\n  return derivedData;\n}\n/**\n * Apply the block's default (as defined in schema) to the block data.\n *\n * @function applyBlockDefaults\n * @param {Object} params An object with data, intl and anything else\n * @return {Object} Derived data, with the defaults extracted from the schema\n */\n\nexport function applyBlockDefaults(_ref, blocksConfig) {\n  let {\n    data,\n    intl\n  } = _ref,\n      rest = _objectWithoutProperties(_ref, _excluded);\n\n  const block_type = data['@type'];\n  const {\n    blockSchema\n  } = (blocksConfig || config.blocks.blocksConfig)[block_type] || {};\n  if (!blockSchema) return data;\n  let schema = typeof blockSchema === 'function' ? blockSchema(_objectSpread({\n    data,\n    intl\n  }, rest)) : blockSchema;\n  schema = applySchemaEnhancer({\n    schema,\n    formData: data,\n    intl\n  });\n  return applySchemaDefaults({\n    data,\n    schema\n  });\n}\nexport const buildStyleClassNamesFromData = styles => {\n  // styles has the form\n  // const styles = {\n  // color: 'red',\n  // backgroundColor: '#AABBCC',\n  // }\n  // Returns: ['has--color--red', 'has--backgroundColor--AABBCC']\n  let styleArray = [];\n\n  const pairedStyles = _toPairs(styles);\n\n  pairedStyles.forEach(item => {\n    if (_isObject(item[1])) {\n      const flattenedNestedStyles = _toPairs(item[1]).map(nested => [item[0], ...nested]);\n\n      flattenedNestedStyles.forEach(sub => styleArray.push(sub));\n    } else {\n      styleArray.push(item);\n    }\n  });\n  return styleArray.map(item => {\n    const classname = item.map(item => {\n      const str_item = item ? item.toString() : '';\n      return str_item && str_item.startsWith('#') ? str_item.replace('#', '') : str_item;\n    });\n    return `has--${classname[0]}--${classname[1]}${classname[2] ? `--${classname[2]}` : ''}`;\n  });\n};","map":{"version":3,"names":["move","v4","uuid","config","applySchemaEnhancer","getBlocksFieldname","props","key","getBlocksLayoutFieldname","hasBlocksData","undefined","blockHasValue","data","blocks","blockType","check","blocksConfig","getBlocks","properties","blocksFieldName","blocksLayoutFieldname","items","map","n","moveBlock","formData","source","destination","deleteBlock","blockId","blocksFieldname","newFormData","length","addBlock","settings","defaultBlockType","type","index","id","idTrailingBlock","totalItems","insert","slice","selected","mutateBlock","value","indexOf","trailId","block","insertBlock","current","newBlockId","changeBlock","nextBlockId","currentBlock","currentIndex","newIndex","previousBlockId","newindex","emptyBlocksForm","blocks_layout","visitBlocks","content","callback","queue","blockdata","shift","Object","keys","push","applySchemaDefaults","schema","derivedData","reduce","accumulator","currentField","default","applyBlockDefaults","intl","rest","block_type","blockSchema","buildStyleClassNamesFromData","styles","styleArray","pairedStyles","forEach","item","flattenedNestedStyles","nested","sub","classname","str_item","toString","startsWith","replace"],"sources":["/home/jakob/workspace/training-project/node_modules/@plone/volto/src/helpers/Blocks/Blocks.js"],"sourcesContent":["/**\n * Blocks helper.\n * @module helpers/Blocks\n */\n\nimport { omit, without, endsWith, find, isObject, keys, toPairs } from 'lodash';\nimport move from 'lodash-move';\nimport { v4 as uuid } from 'uuid';\nimport config from '@plone/volto/registry';\nimport { applySchemaEnhancer } from '@plone/volto/helpers';\n\n/**\n * Get blocks field.\n * @function getBlocksFieldname\n * @param {Object} props Properties.\n * @return {string} Field name of the blocks\n */\nexport function getBlocksFieldname(props) {\n  return (\n    find(\n      keys(props),\n      (key) => key !== 'volto.blocks' && endsWith(key, 'blocks'),\n    ) || null\n  );\n}\n\n/**\n * Get blocks layout field.\n * @function getBlocksLayoutFieldname\n * @param {Object} props Properties.\n * @return {string} Field name of the blocks layout\n */\nexport function getBlocksLayoutFieldname(props) {\n  return (\n    find(\n      keys(props),\n      (key) => key !== 'volto.blocks' && endsWith(key, 'blocks_layout'),\n    ) || null\n  );\n}\n\n/**\n * Has blocks data.\n * @function hasBlocksData\n * @param {Object} props Properties.\n * @return {boolean} True if it has blocks data.\n */\nexport function hasBlocksData(props) {\n  return (\n    find(\n      keys(props),\n      (key) => key !== 'volto.blocks' && endsWith(key, 'blocks'),\n    ) !== undefined\n  );\n}\n\n/**\n * Pluggable method to test if a block has a set value (any non-empty value)\n * @function blockHasValue\n * @param {Object} data Block data\n * @return {boolean} True if block has a non-empty value\n */\nexport function blockHasValue(data) {\n  const { blocks } = config;\n  const blockType = data['@type'];\n  const check = blocks.blocksConfig[blockType]?.blockHasValue;\n  if (!check) {\n    return true;\n  }\n  return check(data);\n}\n\n/**\n * Get block pairs of [id, block] from content properties\n * @function getBlocks\n * @param {Object} properties\n * @return {Array} a list of block [id, value] pairs, in order from layout\n */\nexport const getBlocks = (properties) => {\n  const blocksFieldName = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n  return (\n    properties[blocksLayoutFieldname]?.items?.map((n) => [\n      n,\n      properties[blocksFieldName][n],\n    ]) || []\n  );\n};\n\n/**\n * Move block to different location index within blocks_layout\n * @function moveBlock\n * @param {Object} formData Form data\n * @param {number} source index within form blocks_layout items\n * @param {number} destination index within form blocks_layout items\n * @return {Object} New form data\n */\nexport function moveBlock(formData, source, destination) {\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  return {\n    ...formData,\n    [blocksLayoutFieldname]: {\n      items: move(formData[blocksLayoutFieldname].items, source, destination),\n    },\n  };\n}\n\n/**\n * Delete block by id\n * @function deleteBlock\n * @param {Object} formData Form data\n * @param {string} blockId Block uid\n * @return {Object} New form data\n */\nexport function deleteBlock(formData, blockId) {\n  const blocksFieldname = getBlocksFieldname(formData);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n\n  let newFormData = {\n    ...formData,\n    [blocksLayoutFieldname]: {\n      items: without(formData[blocksLayoutFieldname].items, blockId),\n    },\n    [blocksFieldname]: omit(formData[blocksFieldname], [blockId]),\n  };\n\n  if (newFormData[blocksLayoutFieldname].items.length === 0) {\n    newFormData = addBlock(newFormData, config.settings.defaultBlockType, 0);\n  }\n\n  return newFormData;\n}\n\n/**\n * Add block\n * @function addBlock\n * @param {Object} formData Form data\n * @param {string} type Block type\n * @param {number} index Destination index\n * @return {Array} New block id, New form data\n */\nexport function addBlock(formData, type, index) {\n  const { settings } = config;\n  const id = uuid();\n  const idTrailingBlock = uuid();\n  const blocksFieldname = getBlocksFieldname(formData);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  const totalItems = formData[blocksLayoutFieldname].items.length;\n  const insert = index === -1 ? totalItems : index;\n\n  return [\n    id,\n    {\n      ...formData,\n      [blocksLayoutFieldname]: {\n        items: [\n          ...formData[blocksLayoutFieldname].items.slice(0, insert),\n          id,\n          ...(type !== settings.defaultBlockType ? [idTrailingBlock] : []),\n          ...formData[blocksLayoutFieldname].items.slice(insert),\n        ],\n      },\n      [blocksFieldname]: {\n        ...formData[blocksFieldname],\n        [id]: {\n          '@type': type,\n        },\n        ...(type !== settings.defaultBlockType && {\n          [idTrailingBlock]: {\n            '@type': settings.defaultBlockType,\n          },\n        }),\n      },\n      selected: id,\n    },\n  ];\n}\n\n/**\n * Mutate block\n * @function mutateBlock\n * @param {Object} formData Form data\n * @param {string} id Block uid to mutate\n * @param {number} value Block's new value\n * @return {Object} New form data\n */\nexport function mutateBlock(formData, id, value) {\n  const { settings } = config;\n  const blocksFieldname = getBlocksFieldname(formData);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  const index = formData[blocksLayoutFieldname].items.indexOf(id) + 1;\n\n  // Test if block at index is already a placeholder (trailing) block\n  const trailId = formData[blocksLayoutFieldname].items[index];\n  if (trailId) {\n    const block = formData[blocksFieldname][trailId];\n    if (!blockHasValue(block)) {\n      return {\n        ...formData,\n        [blocksFieldname]: {\n          ...formData[blocksFieldname],\n          [id]: value || null,\n        },\n      };\n    }\n  }\n\n  const idTrailingBlock = uuid();\n  return {\n    ...formData,\n    [blocksFieldname]: {\n      ...formData[blocksFieldname],\n      [id]: value || null,\n      [idTrailingBlock]: {\n        '@type': settings.defaultBlockType,\n      },\n    },\n    [blocksLayoutFieldname]: {\n      items: [\n        ...formData[blocksLayoutFieldname].items.slice(0, index),\n        idTrailingBlock,\n        ...formData[blocksLayoutFieldname].items.slice(index),\n      ],\n    },\n  };\n}\n\n/**\n * Insert new block before another block\n * @function insertBlock\n * @param {Object} formData Form data\n * @param {string} id Insert new block before the block with this id\n * @param {number} value New block's value\n * @return {Array} New block id, New form data\n */\nexport function insertBlock(formData, id, value, current = {}) {\n  const blocksFieldname = getBlocksFieldname(formData);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  const index = formData[blocksLayoutFieldname].items.indexOf(id);\n\n  const newBlockId = uuid();\n  return [\n    newBlockId,\n    {\n      ...formData,\n      [blocksFieldname]: {\n        ...formData[blocksFieldname],\n        [newBlockId]: value || null,\n        [id]: {\n          ...formData[blocksFieldname][id],\n          ...current,\n        },\n      },\n      [blocksLayoutFieldname]: {\n        items: [\n          ...formData[blocksLayoutFieldname].items.slice(0, index),\n          newBlockId,\n          ...formData[blocksLayoutFieldname].items.slice(index),\n        ],\n      },\n    },\n  ];\n}\n\n/**\n * Change block\n * @function changeBlock\n * @param {Object} formData Form data\n * @param {string} id Block uid to change\n * @param {number} value Block's new value\n * @return {Object} New form data\n */\nexport function changeBlock(formData, id, value) {\n  const blocksFieldname = getBlocksFieldname(formData);\n  return {\n    ...formData,\n    [blocksFieldname]: {\n      ...formData[blocksFieldname],\n      [id]: value || null,\n    },\n  };\n}\n\n/**\n * Get the next block UID within form\n * @function nextBlockId\n * @param {Object} formData Form data\n * @param {string} currentBlock Block uid\n * @return {string} Next block uid\n */\nexport function nextBlockId(formData, currentBlock) {\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  const currentIndex = formData[blocksLayoutFieldname].items.indexOf(\n    currentBlock,\n  );\n\n  if (currentIndex === formData[blocksLayoutFieldname].items.length - 1) {\n    // We are already at the bottom block don't do anything\n    return null;\n  }\n\n  const newIndex = currentIndex + 1;\n  return formData[blocksLayoutFieldname].items[newIndex];\n}\n\n/**\n * Get the previous block UID within form\n * @function previousBlockId\n * @param {Object} formData Form data\n * @param {string} currentBlock Block uid\n * @return {string} Previous block uid\n */\nexport function previousBlockId(formData, currentBlock) {\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  const currentIndex = formData[blocksLayoutFieldname].items.indexOf(\n    currentBlock,\n  );\n\n  if (currentIndex === 0) {\n    // We are already at the top block don't do anything\n    return null;\n  }\n  const newindex = currentIndex - 1;\n  return formData[blocksLayoutFieldname].items[newindex];\n}\n\n/**\n * Generate empty block form\n * @function emptyBlocksForm\n * @param {Object} formData Form data\n * @return {Object} Empty blocks form with one defaultBlockType block\n */\nexport function emptyBlocksForm() {\n  const { settings } = config;\n  const id = uuid();\n  return {\n    blocks: {\n      [id]: {\n        '@type': settings.defaultBlockType,\n      },\n    },\n    blocks_layout: { items: [id] },\n  };\n}\n\n/**\n * Recursively discover blocks in data and call the provided callback\n * @function visitBlocks\n * @param {Object} content A content data structure (an object with blocks and blocks_layout)\n * @param {Function} callback A function to call on each discovered block\n */\nexport function visitBlocks(content, callback) {\n  const queue = getBlocks(content);\n  while (queue.length > 0) {\n    const [id, blockdata] = queue.shift();\n    callback([id, blockdata]);\n\n    // assumes that a block value is like: {blocks, blocks_layout} or\n    // { data: {blocks, blocks_layout}}\n    if (Object.keys(blockdata || {}).indexOf('blocks') > -1) {\n      queue.push(...getBlocks(blockdata));\n    }\n    if (Object.keys(blockdata?.data || {}).indexOf('blocks') > -1) {\n      queue.push(...getBlocks(blockdata.data));\n    }\n  }\n}\n\n/**\n * Initializes data with the default values coming from schema\n */\nexport function applySchemaDefaults({ data = {}, schema }) {\n  const derivedData = {\n    ...Object.keys(schema.properties).reduce((accumulator, currentField) => {\n      return schema.properties[currentField].default\n        ? {\n            ...accumulator,\n            [currentField]: schema.properties[currentField].default,\n          }\n        : accumulator;\n    }, {}),\n    ...data,\n  };\n  return derivedData;\n}\n\n/**\n * Apply the block's default (as defined in schema) to the block data.\n *\n * @function applyBlockDefaults\n * @param {Object} params An object with data, intl and anything else\n * @return {Object} Derived data, with the defaults extracted from the schema\n */\nexport function applyBlockDefaults({ data, intl, ...rest }, blocksConfig) {\n  const block_type = data['@type'];\n  const { blockSchema } =\n    (blocksConfig || config.blocks.blocksConfig)[block_type] || {};\n  if (!blockSchema) return data;\n\n  let schema =\n    typeof blockSchema === 'function'\n      ? blockSchema({ data, intl, ...rest })\n      : blockSchema;\n  schema = applySchemaEnhancer({ schema, formData: data, intl });\n\n  return applySchemaDefaults({ data, schema });\n}\n\nexport const buildStyleClassNamesFromData = (styles) => {\n  // styles has the form\n  // const styles = {\n  // color: 'red',\n  // backgroundColor: '#AABBCC',\n  // }\n  // Returns: ['has--color--red', 'has--backgroundColor--AABBCC']\n  let styleArray = [];\n  const pairedStyles = toPairs(styles);\n  pairedStyles.forEach((item) => {\n    if (isObject(item[1])) {\n      const flattenedNestedStyles = toPairs(item[1]).map((nested) => [\n        item[0],\n        ...nested,\n      ]);\n      flattenedNestedStyles.forEach((sub) => styleArray.push(sub));\n    } else {\n      styleArray.push(item);\n    }\n  });\n  return styleArray.map((item) => {\n    const classname = item.map((item) => {\n      const str_item = item ? item.toString() : '';\n      return str_item && str_item.startsWith('#')\n        ? str_item.replace('#', '')\n        : str_item;\n    });\n    return `has--${classname[0]}--${classname[1]}${\n      classname[2] ? `--${classname[2]}` : ''\n    }`;\n  });\n};\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module"}