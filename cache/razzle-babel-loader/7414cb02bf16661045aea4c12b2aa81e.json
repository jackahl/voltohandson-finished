{"ast":null,"code":"const _excluded = [\"reduxConnectStore\"],\n      _excluded2 = [\"context\"];\nvar _jsxFileName = \"/home/jakob/workspace/training-project/node_modules/@plone/volto/src/helpers/AsyncConnect/AsyncConnect.jsx\";\nvar __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* eslint-disable react/forbid-prop-types,react/no-unused-prop-types,react/require-default-props */\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { Route } from 'react-router';\nimport { renderRoutes } from 'react-router-config';\nimport { ReactReduxContext } from 'react-redux';\nimport { loadAsyncConnect } from './ssr';\nimport { getMutableState } from './utils';\nexport class AsyncConnect extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      previousLocation: this.isLoaded() ? null : props.location\n    };\n    this.mounted = false;\n    this.loadDataCounter = 0;\n  }\n\n  componentDidMount() {\n    this.mounted = true;\n    const dataLoaded = this.isLoaded(); // we dont need it if we already made it on server-side\n\n    if (!dataLoaded) {\n      this.loadAsyncData(this.props);\n    }\n  }\n\n  UNSAFE_componentWillReceiveProps(nextProps) {\n    // eslint-disable-line camelcase\n    const {\n      location,\n      reloadOnPropsChange\n    } = this.props;\n    const navigated = location !== nextProps.location; // Allow a user supplied function to determine if an async reload is necessary\n\n    if (navigated && reloadOnPropsChange(this.props, nextProps)) {\n      this.loadAsyncData(nextProps);\n    }\n  }\n\n  componentWillUnmount() {\n    this.mounted = false;\n  }\n\n  isLoaded() {\n    const {\n      reduxConnectStore\n    } = this.props;\n    return getMutableState(reduxConnectStore.getState()).reduxAsyncConnect.loaded;\n  }\n\n  loadAsyncData(_ref) {\n    let {\n      reduxConnectStore\n    } = _ref,\n        otherProps = _objectWithoutProperties(_ref, _excluded);\n\n    const {\n      location,\n      beginGlobalLoad,\n      endGlobalLoad\n    } = this.props;\n    const loadResult = loadAsyncConnect(_objectSpread(_objectSpread({}, otherProps), {}, {\n      store: reduxConnectStore\n    }));\n    this.setState({\n      previousLocation: location\n    }); // TODO: think of a better solution to a problem?\n\n    this.loadDataCounter += 1;\n    beginGlobalLoad();\n    return (loadDataCounterOriginal => loadResult.then(() => {\n      // We need to change propsToShow only if loadAsyncData that called this promise\n      // is the last invocation of loadAsyncData method. Otherwise we can face a situation\n      // when user is changing route several times and we finally show him route that has\n      // loaded props last time and not the last called route\n      if (this.loadDataCounter === loadDataCounterOriginal && this.mounted !== false) {\n        this.setState({\n          previousLocation: null\n        });\n      } // TODO: investigate race conditions\n      // do we need to call this if it's not last invocation?\n\n\n      endGlobalLoad();\n    }))(this.loadDataCounter);\n  }\n\n  render() {\n    const {\n      previousLocation\n    } = this.state;\n    const {\n      location,\n      render\n    } = this.props;\n    return __jsx(Route, {\n      location: previousLocation || location,\n      render: () => render(this.props),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 89,\n        columnNumber: 7\n      }\n    });\n  }\n\n}\nAsyncConnect.propTypes = {\n  render: PropTypes.func,\n  beginGlobalLoad: PropTypes.func.isRequired,\n  endGlobalLoad: PropTypes.func.isRequired,\n  reloadOnPropsChange: PropTypes.func,\n  routes: PropTypes.array.isRequired,\n  location: PropTypes.object.isRequired,\n  match: PropTypes.object.isRequired,\n  helpers: PropTypes.any,\n  reduxConnectStore: PropTypes.object.isRequired\n};\nAsyncConnect.defaultProps = {\n  helpers: {},\n\n  reloadOnPropsChange() {\n    return true;\n  },\n\n  render({\n    routes\n  }) {\n    return renderRoutes(routes);\n  }\n\n};\nexport const AsyncConnectWithContext = _ref2 => {\n  let {\n    context\n  } = _ref2,\n      otherProps = _objectWithoutProperties(_ref2, _excluded2);\n\n  const Context = context || ReactReduxContext;\n\n  if (Context == null) {\n    throw new Error('Please upgrade to react-redux v6');\n  }\n\n  return __jsx(Context.Consumer, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 127,\n      columnNumber: 5\n    }\n  }, ({\n    store: reduxConnectStore\n  }) => __jsx(AsyncConnect, _extends({\n    reduxConnectStore: reduxConnectStore\n  }, otherProps, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 129,\n      columnNumber: 9\n    }\n  })));\n};\nAsyncConnectWithContext.propTypes = {\n  context: PropTypes.object\n};","map":{"version":3,"names":["React","Component","PropTypes","Route","renderRoutes","ReactReduxContext","loadAsyncConnect","getMutableState","AsyncConnect","constructor","props","state","previousLocation","isLoaded","location","mounted","loadDataCounter","componentDidMount","dataLoaded","loadAsyncData","UNSAFE_componentWillReceiveProps","nextProps","reloadOnPropsChange","navigated","componentWillUnmount","reduxConnectStore","getState","reduxAsyncConnect","loaded","otherProps","beginGlobalLoad","endGlobalLoad","loadResult","store","setState","loadDataCounterOriginal","then","render","propTypes","func","isRequired","routes","array","object","match","helpers","any","defaultProps","AsyncConnectWithContext","context","Context","Error"],"sources":["/home/jakob/workspace/training-project/node_modules/@plone/volto/src/helpers/AsyncConnect/AsyncConnect.jsx"],"sourcesContent":["/* eslint-disable react/forbid-prop-types,react/no-unused-prop-types,react/require-default-props */\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { Route } from 'react-router';\nimport { renderRoutes } from 'react-router-config';\nimport { ReactReduxContext } from 'react-redux';\nimport { loadAsyncConnect } from './ssr';\nimport { getMutableState } from './utils';\n\nexport class AsyncConnect extends Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      previousLocation: this.isLoaded() ? null : props.location,\n    };\n\n    this.mounted = false;\n    this.loadDataCounter = 0;\n  }\n\n  componentDidMount() {\n    this.mounted = true;\n    const dataLoaded = this.isLoaded();\n\n    // we dont need it if we already made it on server-side\n    if (!dataLoaded) {\n      this.loadAsyncData(this.props);\n    }\n  }\n\n  UNSAFE_componentWillReceiveProps(nextProps) {\n    // eslint-disable-line camelcase\n    const { location, reloadOnPropsChange } = this.props;\n    const navigated = location !== nextProps.location;\n\n    // Allow a user supplied function to determine if an async reload is necessary\n    if (navigated && reloadOnPropsChange(this.props, nextProps)) {\n      this.loadAsyncData(nextProps);\n    }\n  }\n\n  componentWillUnmount() {\n    this.mounted = false;\n  }\n\n  isLoaded() {\n    const { reduxConnectStore } = this.props;\n    return getMutableState(reduxConnectStore.getState()).reduxAsyncConnect\n      .loaded;\n  }\n\n  loadAsyncData({ reduxConnectStore, ...otherProps }) {\n    const { location, beginGlobalLoad, endGlobalLoad } = this.props;\n    const loadResult = loadAsyncConnect({\n      ...otherProps,\n      store: reduxConnectStore,\n    });\n\n    this.setState({ previousLocation: location });\n\n    // TODO: think of a better solution to a problem?\n    this.loadDataCounter += 1;\n    beginGlobalLoad();\n    return ((loadDataCounterOriginal) =>\n      loadResult.then(() => {\n        // We need to change propsToShow only if loadAsyncData that called this promise\n        // is the last invocation of loadAsyncData method. Otherwise we can face a situation\n        // when user is changing route several times and we finally show him route that has\n        // loaded props last time and not the last called route\n        if (\n          this.loadDataCounter === loadDataCounterOriginal &&\n          this.mounted !== false\n        ) {\n          this.setState({ previousLocation: null });\n        }\n\n        // TODO: investigate race conditions\n        // do we need to call this if it's not last invocation?\n        endGlobalLoad();\n      }))(this.loadDataCounter);\n  }\n\n  render() {\n    const { previousLocation } = this.state;\n    const { location, render } = this.props;\n\n    return (\n      <Route\n        location={previousLocation || location}\n        render={() => render(this.props)}\n      />\n    );\n  }\n}\n\nAsyncConnect.propTypes = {\n  render: PropTypes.func,\n  beginGlobalLoad: PropTypes.func.isRequired,\n  endGlobalLoad: PropTypes.func.isRequired,\n  reloadOnPropsChange: PropTypes.func,\n  routes: PropTypes.array.isRequired,\n  location: PropTypes.object.isRequired,\n  match: PropTypes.object.isRequired,\n  helpers: PropTypes.any,\n  reduxConnectStore: PropTypes.object.isRequired,\n};\n\nAsyncConnect.defaultProps = {\n  helpers: {},\n  reloadOnPropsChange() {\n    return true;\n  },\n  render({ routes }) {\n    return renderRoutes(routes);\n  },\n};\n\nexport const AsyncConnectWithContext = ({ context, ...otherProps }) => {\n  const Context = context || ReactReduxContext;\n\n  if (Context == null) {\n    throw new Error('Please upgrade to react-redux v6');\n  }\n\n  return (\n    <Context.Consumer>\n      {({ store: reduxConnectStore }) => (\n        <AsyncConnect reduxConnectStore={reduxConnectStore} {...otherProps} />\n      )}\n    </Context.Consumer>\n  );\n};\n\nAsyncConnectWithContext.propTypes = {\n  context: PropTypes.object,\n};\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module"}