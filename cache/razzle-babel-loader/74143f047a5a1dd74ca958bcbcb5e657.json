{"ast":null,"code":"const _excluded = [\"connectDropTarget\", \"connectDragSource\", \"connectDragPreview\"];\nvar _jsxFileName = \"/home/jakob/workspace/training-project/node_modules/@plone/volto/src/components/manage/Form/Field.jsx\";\nvar __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Field component.\n * @module components/manage/Form/Field\n */\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { injectIntl } from 'react-intl';\nimport config from '@plone/volto/registry';\nimport { injectLazyLibs } from '@plone/volto/helpers/Loadable/Loadable';\nconst MODE_HIDDEN = 'hidden'; //hidden mode. If mode is hidden, field is not rendered\n\n/**\n * Get default widget\n * @method getViewDefault\n * @returns {string} Widget component.\n */\n\nconst getWidgetDefault = () => config.widgets.default;\n/**\n * Get widget by field's `id` attribute\n * @method getWidgetById\n * @param {string} id Id\n * @returns {string} Widget component.\n */\n\n\nconst getWidgetByFieldId = id => config.widgets.id[id] || null;\n/**\n * Get widget by factory attribute\n * @method getWidgetByFactory\n * @param {string} id Id\n * @returns {string} Widget component.\n */\n\n\nconst getWidgetByFactory = factory => {\n  var _config$widgets$facto;\n\n  return ((_config$widgets$facto = config.widgets.factory) === null || _config$widgets$facto === void 0 ? void 0 : _config$widgets$facto[factory]) || null;\n};\n/**\n * Get widget by field's `widget` attribute\n * @method getWidgetByName\n * @param {string} widget Widget\n * @returns {string} Widget component.\n */\n\n\nconst getWidgetByName = widget => typeof widget === 'string' ? config.widgets.widget[widget] || getWidgetDefault() : null;\n/**\n * Get widget by tagged values\n * @param {object} widgetOptions\n * @returns {string} Widget component.\n *\n\ndirectives.widget(\n    'fieldname',\n    frontendOptions={\n        \"widget\": 'specialwidget',\n        \"version\": 'extra'\n    })\n\n */\n\n\nconst getWidgetFromTaggedValues = widgetOptions => {\n  var _widgetOptions$fronte;\n\n  return typeof (widgetOptions === null || widgetOptions === void 0 ? void 0 : (_widgetOptions$fronte = widgetOptions.frontendOptions) === null || _widgetOptions$fronte === void 0 ? void 0 : _widgetOptions$fronte.widget) === 'string' ? config.widgets.widget[widgetOptions.frontendOptions.widget] : null;\n};\n/**\n * Get widget props from tagged values\n * @param {object} widgetOptions\n * @returns {string} Widget component.\n *\n\ndirectives.widget(\n    \"fieldname\",\n    frontendOptions={\n        \"widget\": \"specialwidget\",\n        \"widgetProps\": {\"prop1\": \"specialprop\"}\n    })\n\n */\n\n\nconst getWidgetPropsFromTaggedValues = widgetOptions => {\n  var _widgetOptions$fronte2;\n\n  return typeof (widgetOptions === null || widgetOptions === void 0 ? void 0 : (_widgetOptions$fronte2 = widgetOptions.frontendOptions) === null || _widgetOptions$fronte2 === void 0 ? void 0 : _widgetOptions$fronte2.widgetProps) === 'object' ? widgetOptions.frontendOptions.widgetProps : null;\n};\n/**\n * Get widget by field's `vocabulary` attribute\n * @method getWidgetByVocabulary\n * @param {string} vocabulary Widget\n * @returns {string} Widget component.\n */\n\n\nconst getWidgetByVocabulary = vocabulary => vocabulary && vocabulary['@id'] ? config.widgets.vocabulary[vocabulary['@id'].replace(/^.*\\/@vocabularies\\//, '')] : null;\n/**\n * Get widget by field's hints `vocabulary` attribute in widgetOptions\n * @method getWidgetByVocabularyFromHint\n * @param {string} props Widget props\n * @returns {string} Widget component.\n */\n\n\nconst getWidgetByVocabularyFromHint = props => props.widgetOptions && props.widgetOptions.vocabulary ? config.widgets.vocabulary[props.widgetOptions.vocabulary['@id'].replace(/^.*\\/@vocabularies\\//, '')] : null;\n/**\n * Get widget by field's `choices` attribute\n * @method getWidgetByChoices\n * @param {string} choices Widget\n * @returns {string} Widget component.\n */\n\n\nconst getWidgetByChoices = props => {\n  if (props.choices) {\n    return config.widgets.choices;\n  }\n\n  if (props.vocabulary) {\n    // If vocabulary exists, then it means it's a choice field in disguise with\n    // no widget specified that probably contains a string then we force it\n    // to be a select widget instead\n    return config.widgets.choices;\n  }\n\n  return null;\n};\n/**\n * Get widget by field's `type` attribute\n * @method getWidgetByType\n * @param {string} type Type\n * @returns {string} Widget component.\n */\n\n\nconst getWidgetByType = type => config.widgets.type[type] || null;\n/**\n * Field component class.\n * @function Field\n * @param {Object} props Properties.\n * @returns {string} Markup of the component.\n */\n\n\nconst UnconnectedField = (props, {\n  intl\n}) => {\n  const Widget = getWidgetByFieldId(props.id) || getWidgetFromTaggedValues(props.widgetOptions) || getWidgetByName(props.widget) || getWidgetByChoices(props) || getWidgetByVocabulary(props.vocabulary) || getWidgetByVocabularyFromHint(props) || getWidgetByFactory(props.factory) || getWidgetByType(props.type) || getWidgetDefault();\n\n  if (props.mode === MODE_HIDDEN) {\n    return null;\n  } // Adding the widget props from tagged values (if any)\n\n\n  const widgetProps = _objectSpread(_objectSpread({}, props), getWidgetPropsFromTaggedValues(props.widgetOptions));\n\n  if (props.onOrder) {\n    const {\n      DropTarget,\n      DragSource\n    } = props.reactDnd;\n    const WrappedWidget = DropTarget('field', {\n      hover(properties, monitor) {\n        const dragOrder = monitor.getItem().order;\n        const hoverOrder = properties.order;\n\n        if (dragOrder === hoverOrder) {\n          return;\n        }\n\n        properties.onOrder(dragOrder, hoverOrder - dragOrder);\n        monitor.getItem().order = hoverOrder;\n      }\n\n    }, connect => ({\n      connectDropTarget: connect.dropTarget()\n    }))(DragSource('field', {\n      beginDrag(properties) {\n        return {\n          id: properties.label,\n          order: properties.order\n        };\n      }\n\n    }, (connect, monitor) => ({\n      connectDragSource: connect.dragSource(),\n      connectDragPreview: connect.dragPreview(),\n      isDragging: monitor.isDragging()\n    }))(_ref => {\n      let {\n        connectDropTarget,\n        connectDragSource,\n        connectDragPreview\n      } = _ref,\n          rest = _objectWithoutProperties(_ref, _excluded);\n\n      return connectDropTarget(connectDragSource(connectDragPreview(__jsx(\"div\", {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 218,\n          columnNumber: 17\n        }\n      }, __jsx(Widget, _extends({}, rest, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 219,\n          columnNumber: 19\n        }\n      }))))));\n    }));\n    return __jsx(WrappedWidget, _extends({}, widgetProps, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 226,\n        columnNumber: 12\n      }\n    }));\n  }\n\n  return __jsx(Widget, _extends({}, widgetProps, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 228,\n      columnNumber: 10\n    }\n  }));\n};\n\nconst DndConnectedField = injectLazyLibs(['reactDnd'])(UnconnectedField);\n\nconst Field = props => props.onOrder ? __jsx(DndConnectedField, _extends({}, props, {\n  __self: this,\n  __source: {\n    fileName: _jsxFileName,\n    lineNumber: 235,\n    columnNumber: 5\n  }\n})) : __jsx(UnconnectedField, _extends({}, props, {\n  __self: this,\n  __source: {\n    fileName: _jsxFileName,\n    lineNumber: 237,\n    columnNumber: 5\n  }\n}));\n/**\n * Property types.\n * @property {Object} propTypes Property types.\n * @static\n */\n\n\nField.propTypes = {\n  widget: PropTypes.string,\n  vocabulary: PropTypes.shape({\n    '@id': PropTypes.string\n  }),\n  choices: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.string)),\n  type: PropTypes.string,\n  id: PropTypes.string.isRequired,\n  focus: PropTypes.bool,\n  onOrder: PropTypes.func\n};\n/**\n * Default properties.\n * @property {Object} defaultProps Default properties.\n * @static\n */\n\nField.defaultProps = {\n  widget: null,\n  vocabulary: null,\n  choices: null,\n  type: 'string',\n  focus: false,\n  onOrder: null\n};\nexport default injectIntl(Field);","map":{"version":3,"names":["React","PropTypes","injectIntl","config","injectLazyLibs","MODE_HIDDEN","getWidgetDefault","widgets","default","getWidgetByFieldId","id","getWidgetByFactory","factory","getWidgetByName","widget","getWidgetFromTaggedValues","widgetOptions","frontendOptions","getWidgetPropsFromTaggedValues","widgetProps","getWidgetByVocabulary","vocabulary","replace","getWidgetByVocabularyFromHint","props","getWidgetByChoices","choices","getWidgetByType","type","UnconnectedField","intl","Widget","mode","onOrder","DropTarget","DragSource","reactDnd","WrappedWidget","hover","properties","monitor","dragOrder","getItem","order","hoverOrder","connect","connectDropTarget","dropTarget","beginDrag","label","connectDragSource","dragSource","connectDragPreview","dragPreview","isDragging","rest","DndConnectedField","Field","propTypes","string","shape","arrayOf","isRequired","focus","bool","func","defaultProps"],"sources":["/home/jakob/workspace/training-project/node_modules/@plone/volto/src/components/manage/Form/Field.jsx"],"sourcesContent":["/**\n * Field component.\n * @module components/manage/Form/Field\n */\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { injectIntl } from 'react-intl';\nimport config from '@plone/volto/registry';\nimport { injectLazyLibs } from '@plone/volto/helpers/Loadable/Loadable';\n\nconst MODE_HIDDEN = 'hidden'; //hidden mode. If mode is hidden, field is not rendered\n/**\n * Get default widget\n * @method getViewDefault\n * @returns {string} Widget component.\n */\nconst getWidgetDefault = () => config.widgets.default;\n\n/**\n * Get widget by field's `id` attribute\n * @method getWidgetById\n * @param {string} id Id\n * @returns {string} Widget component.\n */\nconst getWidgetByFieldId = (id) => config.widgets.id[id] || null;\n\n/**\n * Get widget by factory attribute\n * @method getWidgetByFactory\n * @param {string} id Id\n * @returns {string} Widget component.\n */\nconst getWidgetByFactory = (factory) =>\n  config.widgets.factory?.[factory] || null;\n\n/**\n * Get widget by field's `widget` attribute\n * @method getWidgetByName\n * @param {string} widget Widget\n * @returns {string} Widget component.\n */\nconst getWidgetByName = (widget) =>\n  typeof widget === 'string'\n    ? config.widgets.widget[widget] || getWidgetDefault()\n    : null;\n\n/**\n * Get widget by tagged values\n * @param {object} widgetOptions\n * @returns {string} Widget component.\n *\n\ndirectives.widget(\n    'fieldname',\n    frontendOptions={\n        \"widget\": 'specialwidget',\n        \"version\": 'extra'\n    })\n\n */\nconst getWidgetFromTaggedValues = (widgetOptions) =>\n  typeof widgetOptions?.frontendOptions?.widget === 'string'\n    ? config.widgets.widget[widgetOptions.frontendOptions.widget]\n    : null;\n\n/**\n * Get widget props from tagged values\n * @param {object} widgetOptions\n * @returns {string} Widget component.\n *\n\ndirectives.widget(\n    \"fieldname\",\n    frontendOptions={\n        \"widget\": \"specialwidget\",\n        \"widgetProps\": {\"prop1\": \"specialprop\"}\n    })\n\n */\nconst getWidgetPropsFromTaggedValues = (widgetOptions) =>\n  typeof widgetOptions?.frontendOptions?.widgetProps === 'object'\n    ? widgetOptions.frontendOptions.widgetProps\n    : null;\n\n/**\n * Get widget by field's `vocabulary` attribute\n * @method getWidgetByVocabulary\n * @param {string} vocabulary Widget\n * @returns {string} Widget component.\n */\nconst getWidgetByVocabulary = (vocabulary) =>\n  vocabulary && vocabulary['@id']\n    ? config.widgets.vocabulary[\n        vocabulary['@id'].replace(/^.*\\/@vocabularies\\//, '')\n      ]\n    : null;\n\n/**\n * Get widget by field's hints `vocabulary` attribute in widgetOptions\n * @method getWidgetByVocabularyFromHint\n * @param {string} props Widget props\n * @returns {string} Widget component.\n */\nconst getWidgetByVocabularyFromHint = (props) =>\n  props.widgetOptions && props.widgetOptions.vocabulary\n    ? config.widgets.vocabulary[\n        props.widgetOptions.vocabulary['@id'].replace(\n          /^.*\\/@vocabularies\\//,\n          '',\n        )\n      ]\n    : null;\n\n/**\n * Get widget by field's `choices` attribute\n * @method getWidgetByChoices\n * @param {string} choices Widget\n * @returns {string} Widget component.\n */\nconst getWidgetByChoices = (props) => {\n  if (props.choices) {\n    return config.widgets.choices;\n  }\n\n  if (props.vocabulary) {\n    // If vocabulary exists, then it means it's a choice field in disguise with\n    // no widget specified that probably contains a string then we force it\n    // to be a select widget instead\n    return config.widgets.choices;\n  }\n\n  return null;\n};\n\n/**\n * Get widget by field's `type` attribute\n * @method getWidgetByType\n * @param {string} type Type\n * @returns {string} Widget component.\n */\nconst getWidgetByType = (type) => config.widgets.type[type] || null;\n\n/**\n * Field component class.\n * @function Field\n * @param {Object} props Properties.\n * @returns {string} Markup of the component.\n */\nconst UnconnectedField = (props, { intl }) => {\n  const Widget =\n    getWidgetByFieldId(props.id) ||\n    getWidgetFromTaggedValues(props.widgetOptions) ||\n    getWidgetByName(props.widget) ||\n    getWidgetByChoices(props) ||\n    getWidgetByVocabulary(props.vocabulary) ||\n    getWidgetByVocabularyFromHint(props) ||\n    getWidgetByFactory(props.factory) ||\n    getWidgetByType(props.type) ||\n    getWidgetDefault();\n\n  if (props.mode === MODE_HIDDEN) {\n    return null;\n  }\n\n  // Adding the widget props from tagged values (if any)\n  const widgetProps = {\n    ...props,\n    ...getWidgetPropsFromTaggedValues(props.widgetOptions),\n  };\n\n  if (props.onOrder) {\n    const { DropTarget, DragSource } = props.reactDnd;\n    const WrappedWidget = DropTarget(\n      'field',\n      {\n        hover(properties, monitor) {\n          const dragOrder = monitor.getItem().order;\n          const hoverOrder = properties.order;\n\n          if (dragOrder === hoverOrder) {\n            return;\n          }\n          properties.onOrder(dragOrder, hoverOrder - dragOrder);\n\n          monitor.getItem().order = hoverOrder;\n        },\n      },\n      (connect) => ({\n        connectDropTarget: connect.dropTarget(),\n      }),\n    )(\n      DragSource(\n        'field',\n        {\n          beginDrag(properties) {\n            return {\n              id: properties.label,\n              order: properties.order,\n            };\n          },\n        },\n        (connect, monitor) => ({\n          connectDragSource: connect.dragSource(),\n          connectDragPreview: connect.dragPreview(),\n          isDragging: monitor.isDragging(),\n        }),\n      )(\n        ({\n          connectDropTarget,\n          connectDragSource,\n          connectDragPreview,\n          ...rest\n        }) =>\n          connectDropTarget(\n            connectDragSource(\n              connectDragPreview(\n                <div>\n                  <Widget {...rest} />\n                </div>,\n              ),\n            ),\n          ),\n      ),\n    );\n    return <WrappedWidget {...widgetProps} />;\n  }\n  return <Widget {...widgetProps} />;\n};\n\nconst DndConnectedField = injectLazyLibs(['reactDnd'])(UnconnectedField);\n\nconst Field = (props) =>\n  props.onOrder ? (\n    <DndConnectedField {...props} />\n  ) : (\n    <UnconnectedField {...props} />\n  );\n\n/**\n * Property types.\n * @property {Object} propTypes Property types.\n * @static\n */\nField.propTypes = {\n  widget: PropTypes.string,\n  vocabulary: PropTypes.shape({ '@id': PropTypes.string }),\n  choices: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.string)),\n  type: PropTypes.string,\n  id: PropTypes.string.isRequired,\n  focus: PropTypes.bool,\n  onOrder: PropTypes.func,\n};\n\n/**\n * Default properties.\n * @property {Object} defaultProps Default properties.\n * @static\n */\nField.defaultProps = {\n  widget: null,\n  vocabulary: null,\n  choices: null,\n  type: 'string',\n  focus: false,\n  onOrder: null,\n};\n\nexport default injectIntl(Field);\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module"}