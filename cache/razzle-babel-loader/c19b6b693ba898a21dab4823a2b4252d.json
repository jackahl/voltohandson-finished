{"ast":null,"code":"import _first from \"lodash/first\";\nimport _some from \"lodash/some\";\nimport _includes from \"lodash/includes\";\nimport _find from \"lodash/find\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/* eslint no-console: [\"error\", { allow: [\"error\", \"warn\"] }] */\nimport { Editor, Transforms, Text } from 'slate'; // Range, RangeRef\n\nimport config from '@plone/volto/registry';\nimport { getBlocksFieldname, getBlocksLayoutFieldname } from '@plone/volto/helpers';\nimport { makeEditor } from './editor'; // case sensitive; first in an inner array is the default and preffered format\n// in that array of formats\n\nconst formatAliases = [['strong', 'b'], ['em', 'i'], ['del', 's']];\n/**\n * Excerpt from Slate documentation, kept here for posterity:\n * See https://docs.slatejs.org/concepts/11-normalizing#built-in-constraints\n\n## Built-in Constraints\n\nSlate editors come with a few built-in constraints out of the box. These\nconstraints are there to make working with content much more predictable than\nstandard contenteditable. All of the built-in logic in Slate depends on these\nconstraints, so unfortunately you cannot omit them. They are...\n\n- All Element nodes must contain at least one Text descendant. If an element node\ndoes not contain any children, an empty text node will be added as its only\nchild. This constraint exists to ensure that the selection's anchor and focus\npoints (which rely on referencing text nodes) can always be placed inside any\nnode. With this, empty elements (or void elements) wouldn't be selectable.\n\n- Two adjacent texts with the same custom properties will be merged. If two\nadjacent text nodes have the same formatting, they're merged into a single text\nnode with a combined text string of the two. This exists to prevent the text\nnodes from only ever expanding in count in the document, since both adding and\nremoving formatting results in splitting text nodes.\n\n- Block nodes can only contain other blocks, or inline and text nodes. For\nexample, a paragraph block cannot have another paragraph block element and\na link inline element as children at the same time. The type of children\nallowed is determined by the first child, and any other non-conforming children\nare removed. This ensures that common richtext behaviors like \"splitting\na block in two\" function consistently.\n\n- Inline nodes cannot be the first or last child of a parent block, nor can it\nbe next to another inline node in the children array. If this is the case, an\nempty text node will be added to correct this to be in compliance with the\nconstraint.\n\n- The top-level editor node can only contain block nodes. If any of the\ntop-level children are inline or text nodes they will be removed. This ensures\nthat there are always block nodes in the editor so that behaviors like\n\"splitting a block in two\" work as expected.\n\n- These default constraints are all mandated because they make working with\nSlate documents much more predictable.\n\nAlthough these constraints are the best we've come up with now, we're always\nlooking for ways to have Slate's built-in constraints be less constraining if\npossible—as long as it keeps standard behaviors easy to reason about. If you\ncome up with a way to reduce or remove a built-in constraint with a different\napproach, we're all ears!\n *\n */\n\nexport const normalizeExternalData = (editor, nodes) => {\n  let fakeEditor = makeEditor({\n    extensions: editor._installedPlugins\n  });\n  fakeEditor.children = nodes; // put all the non-blocks (e.g. images which are inline Elements) inside p-s\n\n  Editor.withoutNormalizing(fakeEditor, () => {\n    //for htmlSlateWidget compatibility\n    if (nodes && !Editor.isBlock(fakeEditor, nodes[0])) Transforms.wrapNodes(fakeEditor, {\n      type: 'p'\n    }, {\n      at: [],\n      match: (node, path) => !Editor.isEditor(node) && !Editor.isBlock(fakeEditor, node) || fakeEditor.isInline(node),\n      mode: 'highest'\n    });\n  });\n  Editor.normalize(fakeEditor, {\n    force: true\n  });\n  return fakeEditor.children;\n};\n/**\n * Is it text? Is it whitespace (space, newlines, tabs) ?\n *\n */\n\nexport const isWhitespace = c => {\n  return typeof c === 'string' && c.replace(/\\s/g, '').replace(/\\t/g, '').replace(/\\n/g, '').length === 0;\n};\nexport function createDefaultBlock(children) {\n  return {\n    type: config.settings.slate.defaultBlockType,\n    children: children || [{\n      text: ''\n    }]\n  };\n}\nexport function createBlock(type, children) {\n  return {\n    type,\n    children: children || [{\n      text: ''\n    }]\n  };\n}\nexport function createEmptyParagraph() {\n  // TODO: rename to createEmptyBlock\n  return {\n    type: config.settings.slate.defaultBlockType,\n    children: [{\n      text: ''\n    }]\n  };\n}\nexport const isSingleBlockTypeActive = (editor, format) => {\n  const [match] = Editor.nodes(editor, {\n    match: n => n.type === format\n  });\n  return !!match;\n};\nexport const isBlockActive = (editor, format) => {\n  const aliasList = _find(formatAliases, x => _includes(x, format));\n\n  if (aliasList) {\n    const aliasFound = _some(aliasList, y => {\n      return isSingleBlockTypeActive(editor, y);\n    });\n\n    if (aliasFound) {\n      return true;\n    }\n  }\n\n  return isSingleBlockTypeActive(editor, format);\n};\nexport const getBlockTypeContextData = (editor, format) => {\n  let isActive, defaultFormat, matcher;\n\n  const aliasList = _find(formatAliases, x => _includes(x, format));\n\n  if (aliasList) {\n    const aliasFound = _some(aliasList, y => {\n      return isSingleBlockTypeActive(editor, y);\n    });\n\n    if (aliasFound) {\n      isActive = true;\n      defaultFormat = _first(aliasList);\n\n      matcher = n => _includes(aliasList, n.type);\n\n      return {\n        isActive,\n        defaultFormat,\n        matcher\n      };\n    }\n  }\n\n  isActive = isBlockActive(editor, format);\n  defaultFormat = format;\n\n  matcher = n => n.type === format;\n\n  return {\n    isActive,\n    defaultFormat,\n    matcher\n  };\n};\nexport const toggleInlineFormat = (editor, format) => {\n  const {\n    isActive,\n    defaultFormat,\n    matcher\n  } = getBlockTypeContextData(editor, format);\n\n  if (isActive) {\n    const rangeRef = Editor.rangeRef(editor, editor.selection);\n    Transforms.unwrapNodes(editor, {\n      match: matcher,\n      split: false\n    });\n    const newSel = JSON.parse(JSON.stringify(rangeRef.current));\n    Transforms.select(editor, newSel);\n    editor.setSavedSelection(newSel); // editor.savedSelection = newSel;\n\n    return;\n  } // `children` property is added automatically as an empty array then\n  // normalized\n\n\n  const block = {\n    type: defaultFormat\n  };\n  Transforms.wrapNodes(editor, block, {\n    split: true\n  });\n};\nexport const toggleBlock = (editor, format, allowedChildren) => {\n  // We have 6 boolean variables which need to be accounted for.\n  // See https://docs.google.com/spreadsheets/d/1mVeMuqSTMABV2BhoHPrPAFjn7zUksbNgZ9AQK_dcd3U/edit?usp=sharing\n  const {\n    slate\n  } = config.settings;\n  const {\n    listTypes\n  } = slate;\n  const isListItem = isBlockActive(editor, slate.listItemType);\n  const isActive = isBlockActive(editor, format);\n  const wantsList = listTypes.includes(format);\n\n  if (isListItem && !wantsList) {\n    toggleFormatAsListItem(editor, format);\n  } else if (isListItem && wantsList && !isActive) {\n    switchListType(editor, format);\n  } else if (!isListItem && wantsList) {\n    changeBlockToList(editor, format);\n  } else if (!isListItem && !wantsList) {\n    toggleFormat(editor, format, allowedChildren);\n  } else if (isListItem && wantsList && isActive) {\n    clearFormatting(editor);\n  } else {\n    console.warn('toggleBlock case not covered, please examine:', {\n      wantsList,\n      isActive,\n      isListItem\n    });\n  }\n};\n/*\n * Applies a block format to a list item. Will split the list\n */\n\nexport const toggleFormatAsListItem = (editor, format) => {\n  Transforms.setNodes(editor, {\n    type: format\n  });\n  Editor.normalize(editor);\n};\n/*\n * Toggles between list types by exploding the block\n */\n\nexport const switchListType = (editor, format) => {\n  const {\n    slate\n  } = config.settings;\n  Transforms.unwrapNodes(editor, {\n    match: n => slate.listTypes.includes(n.type),\n    split: true\n  });\n  const block = {\n    type: format,\n    children: []\n  };\n  Transforms.wrapNodes(editor, block);\n};\nexport const changeBlockToList = (editor, format) => {\n  const {\n    slate\n  } = config.settings;\n  const [match] = Editor.nodes(editor, {\n    match: n => n.type === slate.listItemType\n  });\n\n  if (!match) {\n    Transforms.setNodes(editor, {\n      type: slate.listItemType // id: nanoid(8),\n\n    });\n  } // `children` property is added automatically as an empty array then\n  // normalized\n\n\n  const block = {\n    type: format\n  };\n  Transforms.wrapNodes(editor, block);\n};\nexport const toggleFormat = (editor, format, allowedChildren) => {\n  const {\n    slate\n  } = config.settings;\n  const isActive = isBlockActive(editor, format);\n  const type = isActive ? slate.defaultBlockType : format;\n  Transforms.setNodes(editor, {\n    type\n  });\n  (allowedChildren === null || allowedChildren === void 0 ? void 0 : allowedChildren.length) && Transforms.unwrapNodes(editor, {\n    mode: 'all',\n    at: [0],\n    match: (n, path) => {\n      const isMatch = path.length > 1 && // we don't deal with the parent nodes\n      !(Text.isText(n) || allowedChildren.includes(n === null || n === void 0 ? void 0 : n.type));\n      return isMatch;\n    }\n  });\n};\n/**\n * @param {object} properties A prop received by the View component\n *  which is read by the `getBlocksFieldname` and\n * `getBlocksLayoutFieldname` Volto helpers to produce the return value.\n * @returns {Array} All the blocks data taken from the Volto form.\n */\n\nexport const getAllBlocks = (properties, blocks) => {\n  const blocksFieldName = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n\n  for (const n of (properties === null || properties === void 0 ? void 0 : (_properties$blocksLay = properties[blocksLayoutFieldname]) === null || _properties$blocksLay === void 0 ? void 0 : _properties$blocksLay.items) || []) {\n    var _properties$blocksLay, _block$data, _block$data2;\n\n    const block = properties[blocksFieldName][n]; // TODO Make this configurable via block config getBlocks\n\n    if (block !== null && block !== void 0 && (_block$data = block.data) !== null && _block$data !== void 0 && _block$data[blocksLayoutFieldname] && block !== null && block !== void 0 && (_block$data2 = block.data) !== null && _block$data2 !== void 0 && _block$data2[blocksFieldName]) {\n      getAllBlocks(block.data, blocks);\n    } else if (block !== null && block !== void 0 && block[blocksLayoutFieldname] && block !== null && block !== void 0 && block[blocksFieldName]) {\n      getAllBlocks(block, blocks);\n    }\n\n    blocks.push(_objectSpread({\n      id: n\n    }, block));\n  }\n\n  return blocks;\n};\nexport const clearFormatting = editor => {\n  const {\n    slate\n  } = config.settings;\n  Transforms.setNodes(editor, {\n    type: slate.defaultBlockType\n  });\n  Transforms.unwrapNodes(editor, {\n    match: n => n.type && n.type !== slate.defaultBlockType,\n    mode: 'all',\n    split: false\n  });\n};","map":{"version":3,"names":["Editor","Transforms","Text","config","getBlocksFieldname","getBlocksLayoutFieldname","makeEditor","formatAliases","normalizeExternalData","editor","nodes","fakeEditor","extensions","_installedPlugins","children","withoutNormalizing","isBlock","wrapNodes","type","at","match","node","path","isEditor","isInline","mode","normalize","force","isWhitespace","c","replace","length","createDefaultBlock","settings","slate","defaultBlockType","text","createBlock","createEmptyParagraph","isSingleBlockTypeActive","format","n","isBlockActive","aliasList","x","aliasFound","y","getBlockTypeContextData","isActive","defaultFormat","matcher","toggleInlineFormat","rangeRef","selection","unwrapNodes","split","newSel","JSON","parse","stringify","current","select","setSavedSelection","block","toggleBlock","allowedChildren","listTypes","isListItem","listItemType","wantsList","includes","toggleFormatAsListItem","switchListType","changeBlockToList","toggleFormat","clearFormatting","console","warn","setNodes","isMatch","isText","getAllBlocks","properties","blocks","blocksFieldName","blocksLayoutFieldname","items","data","push","id"],"sources":["/home/jakob/workspace/training-project/node_modules/@plone/volto/packages/volto-slate/src/utils/blocks.js"],"sourcesContent":["/* eslint no-console: [\"error\", { allow: [\"error\", \"warn\"] }] */\nimport { Editor, Transforms, Text } from 'slate'; // Range, RangeRef\nimport config from '@plone/volto/registry';\nimport {\n  getBlocksFieldname,\n  getBlocksLayoutFieldname,\n} from '@plone/volto/helpers';\nimport _ from 'lodash';\nimport { makeEditor } from './editor';\n\n// case sensitive; first in an inner array is the default and preffered format\n// in that array of formats\nconst formatAliases = [\n  ['strong', 'b'],\n  ['em', 'i'],\n  ['del', 's'],\n];\n\n/**\n * Excerpt from Slate documentation, kept here for posterity:\n * See https://docs.slatejs.org/concepts/11-normalizing#built-in-constraints\n\n## Built-in Constraints\n\nSlate editors come with a few built-in constraints out of the box. These\nconstraints are there to make working with content much more predictable than\nstandard contenteditable. All of the built-in logic in Slate depends on these\nconstraints, so unfortunately you cannot omit them. They are...\n\n- All Element nodes must contain at least one Text descendant. If an element node\ndoes not contain any children, an empty text node will be added as its only\nchild. This constraint exists to ensure that the selection's anchor and focus\npoints (which rely on referencing text nodes) can always be placed inside any\nnode. With this, empty elements (or void elements) wouldn't be selectable.\n\n- Two adjacent texts with the same custom properties will be merged. If two\nadjacent text nodes have the same formatting, they're merged into a single text\nnode with a combined text string of the two. This exists to prevent the text\nnodes from only ever expanding in count in the document, since both adding and\nremoving formatting results in splitting text nodes.\n\n- Block nodes can only contain other blocks, or inline and text nodes. For\nexample, a paragraph block cannot have another paragraph block element and\na link inline element as children at the same time. The type of children\nallowed is determined by the first child, and any other non-conforming children\nare removed. This ensures that common richtext behaviors like \"splitting\na block in two\" function consistently.\n\n- Inline nodes cannot be the first or last child of a parent block, nor can it\nbe next to another inline node in the children array. If this is the case, an\nempty text node will be added to correct this to be in compliance with the\nconstraint.\n\n- The top-level editor node can only contain block nodes. If any of the\ntop-level children are inline or text nodes they will be removed. This ensures\nthat there are always block nodes in the editor so that behaviors like\n\"splitting a block in two\" work as expected.\n\n- These default constraints are all mandated because they make working with\nSlate documents much more predictable.\n\nAlthough these constraints are the best we've come up with now, we're always\nlooking for ways to have Slate's built-in constraints be less constraining if\npossible—as long as it keeps standard behaviors easy to reason about. If you\ncome up with a way to reduce or remove a built-in constraint with a different\napproach, we're all ears!\n *\n */\n\nexport const normalizeExternalData = (editor, nodes) => {\n  let fakeEditor = makeEditor({ extensions: editor._installedPlugins });\n  fakeEditor.children = nodes;\n  // put all the non-blocks (e.g. images which are inline Elements) inside p-s\n  Editor.withoutNormalizing(fakeEditor, () => {\n    //for htmlSlateWidget compatibility\n    if (nodes && !Editor.isBlock(fakeEditor, nodes[0]))\n      Transforms.wrapNodes(\n        fakeEditor,\n        { type: 'p' },\n        {\n          at: [],\n          match: (node, path) =>\n            (!Editor.isEditor(node) && !Editor.isBlock(fakeEditor, node)) ||\n            fakeEditor.isInline(node),\n          mode: 'highest',\n        },\n      );\n  });\n\n  Editor.normalize(fakeEditor, { force: true });\n\n  return fakeEditor.children;\n};\n\n/**\n * Is it text? Is it whitespace (space, newlines, tabs) ?\n *\n */\nexport const isWhitespace = (c) => {\n  return (\n    typeof c === 'string' &&\n    c.replace(/\\s/g, '').replace(/\\t/g, '').replace(/\\n/g, '').length === 0\n  );\n};\n\nexport function createDefaultBlock(children) {\n  return {\n    type: config.settings.slate.defaultBlockType,\n    children: children || [{ text: '' }],\n  };\n}\n\nexport function createBlock(type, children) {\n  return {\n    type,\n    children: children || [{ text: '' }],\n  };\n}\n\nexport function createEmptyParagraph() {\n  // TODO: rename to createEmptyBlock\n  return {\n    type: config.settings.slate.defaultBlockType,\n    children: [{ text: '' }],\n  };\n}\n\nexport const isSingleBlockTypeActive = (editor, format) => {\n  const [match] = Editor.nodes(editor, {\n    match: (n) => n.type === format,\n  });\n\n  return !!match;\n};\n\nexport const isBlockActive = (editor, format) => {\n  const aliasList = _.find(formatAliases, (x) => _.includes(x, format));\n\n  if (aliasList) {\n    const aliasFound = _.some(aliasList, (y) => {\n      return isSingleBlockTypeActive(editor, y);\n    });\n\n    if (aliasFound) {\n      return true;\n    }\n  }\n\n  return isSingleBlockTypeActive(editor, format);\n};\n\nexport const getBlockTypeContextData = (editor, format) => {\n  let isActive, defaultFormat, matcher;\n\n  const aliasList = _.find(formatAliases, (x) => _.includes(x, format));\n\n  if (aliasList) {\n    const aliasFound = _.some(aliasList, (y) => {\n      return isSingleBlockTypeActive(editor, y);\n    });\n\n    if (aliasFound) {\n      isActive = true;\n      defaultFormat = _.first(aliasList);\n      matcher = (n) => _.includes(aliasList, n.type);\n\n      return { isActive, defaultFormat, matcher };\n    }\n  }\n\n  isActive = isBlockActive(editor, format);\n  defaultFormat = format;\n  matcher = (n) => n.type === format;\n\n  return { isActive, defaultFormat, matcher };\n};\n\nexport const toggleInlineFormat = (editor, format) => {\n  const { isActive, defaultFormat, matcher } = getBlockTypeContextData(\n    editor,\n    format,\n  );\n\n  if (isActive) {\n    const rangeRef = Editor.rangeRef(editor, editor.selection);\n\n    Transforms.unwrapNodes(editor, {\n      match: matcher,\n      split: false,\n    });\n\n    const newSel = JSON.parse(JSON.stringify(rangeRef.current));\n\n    Transforms.select(editor, newSel);\n    editor.setSavedSelection(newSel);\n    // editor.savedSelection = newSel;\n    return;\n  }\n\n  // `children` property is added automatically as an empty array then\n  // normalized\n  const block = { type: defaultFormat };\n  Transforms.wrapNodes(editor, block, { split: true });\n};\n\nexport const toggleBlock = (editor, format, allowedChildren) => {\n  // We have 6 boolean variables which need to be accounted for.\n  // See https://docs.google.com/spreadsheets/d/1mVeMuqSTMABV2BhoHPrPAFjn7zUksbNgZ9AQK_dcd3U/edit?usp=sharing\n  const { slate } = config.settings;\n  const { listTypes } = slate;\n\n  const isListItem = isBlockActive(editor, slate.listItemType);\n  const isActive = isBlockActive(editor, format);\n  const wantsList = listTypes.includes(format);\n\n  if (isListItem && !wantsList) {\n    toggleFormatAsListItem(editor, format);\n  } else if (isListItem && wantsList && !isActive) {\n    switchListType(editor, format);\n  } else if (!isListItem && wantsList) {\n    changeBlockToList(editor, format);\n  } else if (!isListItem && !wantsList) {\n    toggleFormat(editor, format, allowedChildren);\n  } else if (isListItem && wantsList && isActive) {\n    clearFormatting(editor);\n  } else {\n    console.warn('toggleBlock case not covered, please examine:', {\n      wantsList,\n      isActive,\n      isListItem,\n    });\n  }\n};\n\n/*\n * Applies a block format to a list item. Will split the list\n */\nexport const toggleFormatAsListItem = (editor, format) => {\n  Transforms.setNodes(editor, {\n    type: format,\n  });\n\n  Editor.normalize(editor);\n};\n\n/*\n * Toggles between list types by exploding the block\n */\nexport const switchListType = (editor, format) => {\n  const { slate } = config.settings;\n  Transforms.unwrapNodes(editor, {\n    match: (n) => slate.listTypes.includes(n.type),\n    split: true,\n  });\n  const block = { type: format, children: [] };\n  Transforms.wrapNodes(editor, block);\n};\n\nexport const changeBlockToList = (editor, format) => {\n  const { slate } = config.settings;\n  const [match] = Editor.nodes(editor, {\n    match: (n) => n.type === slate.listItemType,\n  });\n\n  if (!match) {\n    Transforms.setNodes(editor, {\n      type: slate.listItemType,\n      // id: nanoid(8),\n    });\n  }\n\n  // `children` property is added automatically as an empty array then\n  // normalized\n  const block = { type: format };\n  Transforms.wrapNodes(editor, block);\n};\n\nexport const toggleFormat = (editor, format, allowedChildren) => {\n  const { slate } = config.settings;\n  const isActive = isBlockActive(editor, format);\n  const type = isActive ? slate.defaultBlockType : format;\n  Transforms.setNodes(editor, {\n    type,\n  });\n  allowedChildren?.length &&\n    Transforms.unwrapNodes(editor, {\n      mode: 'all',\n      at: [0],\n      match: (n, path) => {\n        const isMatch =\n          path.length > 1 && // we don't deal with the parent nodes\n          !(Text.isText(n) || allowedChildren.includes(n?.type));\n        return isMatch;\n      },\n    });\n};\n\n/**\n * @param {object} properties A prop received by the View component\n *  which is read by the `getBlocksFieldname` and\n * `getBlocksLayoutFieldname` Volto helpers to produce the return value.\n * @returns {Array} All the blocks data taken from the Volto form.\n */\nexport const getAllBlocks = (properties, blocks) => {\n  const blocksFieldName = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n\n  for (const n of properties?.[blocksLayoutFieldname]?.items || []) {\n    const block = properties[blocksFieldName][n];\n    // TODO Make this configurable via block config getBlocks\n    if (\n      block?.data?.[blocksLayoutFieldname] &&\n      block?.data?.[blocksFieldName]\n    ) {\n      getAllBlocks(block.data, blocks);\n    } else if (block?.[blocksLayoutFieldname] && block?.[blocksFieldName]) {\n      getAllBlocks(block, blocks);\n    }\n    blocks.push({\n      id: n,\n      ...block,\n    });\n  }\n  return blocks;\n};\n\nexport const clearFormatting = (editor) => {\n  const { slate } = config.settings;\n  Transforms.setNodes(editor, {\n    type: slate.defaultBlockType,\n  });\n  Transforms.unwrapNodes(editor, {\n    match: (n) => n.type && n.type !== slate.defaultBlockType,\n    mode: 'all',\n    split: false,\n  });\n};\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module"}