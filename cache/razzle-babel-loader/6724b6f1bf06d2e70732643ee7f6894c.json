{"ast":null,"code":"import _objectSpread from \"/home/jakob/workspace/training-project/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport { Editor, Range, Transforms, Text, Node } from 'slate';\nimport { getMaxRange, selectAll, getSelectionNodesArrayByType } from '@plone/volto-slate/utils';\nimport { P, LI, UL, OL } from '@plone/volto-slate/constants';\nexport function unwrapNodesByType(editor, types) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Transforms.unwrapNodes(editor, _objectSpread({\n    match: n => types.includes(n.type)\n  }, options));\n}\nexport function unwrapList(editor, willWrapAgain) {\n  let {\n    typeUl = UL,\n    typeOl = OL,\n    typeLi = LI,\n    unwrapFromList = false\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  // TODO: toggling from one list type to another should keep the structure untouched\n  if (editor.selection && Range.isExpanded(editor.selection) && unwrapFromList) {\n    if (unwrapFromList) {// unwrapNodesByType(editor, [typeLi]);\n      // unwrapNodesByType(editor, [typeUl, typeOl], {\n      //   split: true,\n      // });\n      // else ...\n    }\n  } else {\n    unwrapNodesByType(editor, [typeLi], {\n      at: getMaxRange(editor)\n    });\n    unwrapNodesByType(editor, [typeUl, typeOl], {\n      at: getMaxRange(editor)\n    });\n  }\n\n  if (!willWrapAgain) {\n    convertAllToParagraph(editor);\n  }\n}\nexport function convertAllToParagraph(editor) {\n  // let count = Array.from(Node.children(editor, [])).length;\n  let result = recursive(editor);\n  compactAndNormalize(result);\n  Editor.withoutNormalizing(editor, () => {\n    Transforms.removeNodes(editor, {\n      at: [0\n      /* , i */\n      ]\n    });\n    Transforms.insertNodes(editor, {\n      type: P,\n      children: [{\n        text: ''\n      }]\n    }, {\n      at: [0]\n    });\n    Transforms.insertFragment(editor, [...result], {\n      at: [0]\n    });\n  });\n}\nexport function recursive(myNode) {\n  if (Text.isText(myNode)) return [_objectSpread({}, myNode)];\n  let output = [];\n  let children = Node.children(myNode, []);\n\n  for (const [node] of children) {\n    if (Text.isText(node)) {\n      output.push(_objectSpread({}, node));\n    } else {\n      let count = Array.from(node.children).length;\n\n      for (let i = 0; i < count; ++i) {\n        let o = recursive(node.children[i]);\n\n        for (let j = 0; j < o.length; ++j) {\n          output.push(o[j]);\n        }\n      }\n    }\n  }\n\n  return output;\n} // TODO: make this add a space between any two Text instances\n\nexport function compactAndNormalize(result) {\n  for (let i = 0; i < result.length - 1; ++i) {\n    let a = result[i];\n    let b = result[i + 1];\n    let m = textsMatch(a, b);\n\n    if (m) {\n      result[i].text += b.text;\n      result.splice(i + 1, 1);\n    }\n  }\n\n  if (result.length === 0) {\n    result.push({\n      text: ''\n    });\n  }\n\n  return;\n} // TODO: optimize this:\n\nexport function textsMatch(a, b) {\n  const aKeys = Object.keys(a);\n  const bKeys = Object.keys(b);\n\n  for (let x in a) {\n    if (x === 'text') continue;\n\n    if (aKeys.includes(x) && bKeys.includes(x)) {\n      if (a[x] !== b[x]) {\n        return false;\n      }\n    }\n  }\n\n  for (let x in b) {\n    if (x === 'text') continue;\n\n    if (aKeys.includes(x) && bKeys.includes(x)) {\n      if (a[x] !== b[x]) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n/**\n * @summary Toggles list type.\n * @todo need to redo this\n * @todo should preserve structure of list if going from a list type to another\n * @todo allow nested lists, currently the Markdown plugin uses this function but crashes when making a UL in an OL's LI\n * @param {Editor} editor\n * @param {object} options\n */\n\nexport function toggleList(editor, _ref) {\n  let {\n    typeList,\n    typeUl = UL,\n    typeOl = OL,\n    typeLi = LI,\n    typeP = P,\n    isBulletedActive = false,\n    isNumberedActive = false\n  } = _ref;\n  // TODO: set previous selection (not this 'select all' command) after toggling list (in all three cases: toggling to numbered, bulleted or none)\n  selectAll(editor); // const isActive = isNodeInSelection(editor, [typeList]);\n  // if (the list type/s are unset) {\n\n  const B = typeList === UL;\n  const N = typeList === OL;\n\n  if (N && !isBulletedActive && !isNumberedActive) {\n    convertAllToParagraph(editor); // go on with const willWrapAgain etc.\n  } else if (N && !isBulletedActive && isNumberedActive) {\n    convertAllToParagraph(editor);\n    return;\n  } else if (N && isBulletedActive && !isNumberedActive) {// go on with const willWrapAgain etc.\n  } else if (B && !isBulletedActive && !isNumberedActive) {\n    convertAllToParagraph(editor); // go on with const willWrapAgain etc.\n  } else if (B && !isBulletedActive && isNumberedActive) {// go on with const willWrapAgain etc.\n  } else if (B && isBulletedActive && !isNumberedActive) {\n    convertAllToParagraph(editor);\n    return;\n  }\n\n  selectAll(editor);\n  const willWrapAgain = !isBulletedActive;\n  unwrapList(editor, willWrapAgain, {\n    unwrapFromList: isBulletedActive\n  }); // a new list is created and everything in the editor is put in it;\n  // `children` property is added automatically as an empty array then\n  // normalized\n\n  const list = {\n    type: typeList\n  };\n  Transforms.wrapNodes(editor, list); // get all the selected paragraphs\n\n  const nodes = getSelectionNodesArrayByType(editor, typeP); // for each paragraph\n\n  for (const [, path] of nodes) {\n    // convert the paragraph to a list item\n    Transforms.setNodes(editor, {\n      type: LI\n    }, {\n      at: path\n    });\n  }\n}","map":{"version":3,"names":["Editor","Range","Transforms","Text","Node","getMaxRange","selectAll","getSelectionNodesArrayByType","P","LI","UL","OL","unwrapNodesByType","editor","types","options","unwrapNodes","match","n","includes","type","unwrapList","willWrapAgain","typeUl","typeOl","typeLi","unwrapFromList","selection","isExpanded","at","convertAllToParagraph","result","recursive","compactAndNormalize","withoutNormalizing","removeNodes","insertNodes","children","text","insertFragment","myNode","isText","output","node","push","count","Array","from","length","i","o","j","a","b","m","textsMatch","splice","aKeys","Object","keys","bKeys","x","toggleList","typeList","typeP","isBulletedActive","isNumberedActive","B","N","list","wrapNodes","nodes","path","setNodes"],"sources":["/home/jakob/workspace/training-project/node_modules/@plone/volto/packages/volto-slate/src/editor/plugins/Markdown/utils.js"],"sourcesContent":["import { Editor, Range, Transforms, Text, Node } from 'slate';\nimport {\n  getMaxRange,\n  selectAll,\n  getSelectionNodesArrayByType,\n} from '@plone/volto-slate/utils';\nimport { P, LI, UL, OL } from '@plone/volto-slate/constants';\n\nexport function unwrapNodesByType(editor, types, options = {}) {\n  Transforms.unwrapNodes(editor, {\n    match: (n) => types.includes(n.type),\n    ...options,\n  });\n}\n\nexport function unwrapList(\n  editor,\n  willWrapAgain,\n  { typeUl = UL, typeOl = OL, typeLi = LI, unwrapFromList = false } = {},\n) {\n  // TODO: toggling from one list type to another should keep the structure untouched\n  if (\n    editor.selection &&\n    Range.isExpanded(editor.selection) &&\n    unwrapFromList\n  ) {\n    if (unwrapFromList) {\n      // unwrapNodesByType(editor, [typeLi]);\n      // unwrapNodesByType(editor, [typeUl, typeOl], {\n      //   split: true,\n      // });\n      // else ...\n    }\n  } else {\n    unwrapNodesByType(editor, [typeLi], { at: getMaxRange(editor) });\n    unwrapNodesByType(editor, [typeUl, typeOl], {\n      at: getMaxRange(editor),\n    });\n  }\n\n  if (!willWrapAgain) {\n    convertAllToParagraph(editor);\n  }\n}\n\nexport function convertAllToParagraph(editor) {\n  // let count = Array.from(Node.children(editor, [])).length;\n  let result = recursive(editor);\n  compactAndNormalize(result);\n\n  Editor.withoutNormalizing(editor, () => {\n    Transforms.removeNodes(editor, { at: [0 /* , i */] });\n    Transforms.insertNodes(\n      editor,\n      { type: P, children: [{ text: '' }] },\n      { at: [0] },\n    );\n    Transforms.insertFragment(editor, [...result], { at: [0] });\n  });\n}\n\nexport function recursive(myNode) {\n  if (Text.isText(myNode)) return [{ ...myNode }];\n\n  let output = [];\n  let children = Node.children(myNode, []);\n\n  for (const [node] of children) {\n    if (Text.isText(node)) {\n      output.push({ ...node });\n    } else {\n      let count = Array.from(node.children).length;\n      for (let i = 0; i < count; ++i) {\n        let o = recursive(node.children[i]);\n        for (let j = 0; j < o.length; ++j) {\n          output.push(o[j]);\n        }\n      }\n    }\n  }\n\n  return output;\n}\n\n// TODO: make this add a space between any two Text instances\nexport function compactAndNormalize(result) {\n  for (let i = 0; i < result.length - 1; ++i) {\n    let a = result[i];\n    let b = result[i + 1];\n\n    let m = textsMatch(a, b);\n    if (m) {\n      result[i].text += b.text;\n      result.splice(i + 1, 1);\n    }\n  }\n\n  if (result.length === 0) {\n    result.push({ text: '' });\n  }\n\n  return;\n}\n\n// TODO: optimize this:\nexport function textsMatch(a, b) {\n  const aKeys = Object.keys(a);\n  const bKeys = Object.keys(b);\n\n  for (let x in a) {\n    if (x === 'text') continue;\n    if (aKeys.includes(x) && bKeys.includes(x)) {\n      if (a[x] !== b[x]) {\n        return false;\n      }\n    }\n  }\n\n  for (let x in b) {\n    if (x === 'text') continue;\n    if (aKeys.includes(x) && bKeys.includes(x)) {\n      if (a[x] !== b[x]) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\n/**\n * @summary Toggles list type.\n * @todo need to redo this\n * @todo should preserve structure of list if going from a list type to another\n * @todo allow nested lists, currently the Markdown plugin uses this function but crashes when making a UL in an OL's LI\n * @param {Editor} editor\n * @param {object} options\n */\nexport function toggleList(\n  editor,\n  {\n    typeList,\n    typeUl = UL,\n    typeOl = OL,\n    typeLi = LI,\n    typeP = P,\n    isBulletedActive = false,\n    isNumberedActive = false,\n  },\n) {\n  // TODO: set previous selection (not this 'select all' command) after toggling list (in all three cases: toggling to numbered, bulleted or none)\n  selectAll(editor);\n\n  // const isActive = isNodeInSelection(editor, [typeList]);\n\n  // if (the list type/s are unset) {\n\n  const B = typeList === UL;\n  const N = typeList === OL;\n\n  if (N && !isBulletedActive && !isNumberedActive) {\n    convertAllToParagraph(editor);\n    // go on with const willWrapAgain etc.\n  } else if (N && !isBulletedActive && isNumberedActive) {\n    convertAllToParagraph(editor);\n    return;\n  } else if (N && isBulletedActive && !isNumberedActive) {\n    // go on with const willWrapAgain etc.\n  } else if (B && !isBulletedActive && !isNumberedActive) {\n    convertAllToParagraph(editor);\n    // go on with const willWrapAgain etc.\n  } else if (B && !isBulletedActive && isNumberedActive) {\n    // go on with const willWrapAgain etc.\n  } else if (B && isBulletedActive && !isNumberedActive) {\n    convertAllToParagraph(editor);\n    return;\n  }\n\n  selectAll(editor);\n\n  const willWrapAgain = !isBulletedActive;\n  unwrapList(editor, willWrapAgain, { unwrapFromList: isBulletedActive });\n\n  // a new list is created and everything in the editor is put in it;\n  // `children` property is added automatically as an empty array then\n  // normalized\n  const list = { type: typeList };\n  Transforms.wrapNodes(editor, list);\n\n  // get all the selected paragraphs\n  const nodes = getSelectionNodesArrayByType(editor, typeP);\n\n  // for each paragraph\n  for (const [, path] of nodes) {\n    // convert the paragraph to a list item\n    Transforms.setNodes(editor, { type: LI }, { at: path });\n  }\n}\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module"}