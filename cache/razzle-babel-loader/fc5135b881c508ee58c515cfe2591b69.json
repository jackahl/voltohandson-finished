{"ast":null,"code":"import { Editor, Range, Transforms } from 'slate';\nimport config from '@plone/volto/registry';\nimport { isCursorAtBlockEnd, splitEditorInTwoFragments, setEditorContent, createAndSelectNewBlockAfter, getCurrentListItem, createEmptyParagraph } from '@plone/volto-slate/utils';\n/**\n * Handles `Enter` key on empty and non-empty list items.\n *\n * @param {Editor} editor The editor which should be modified by this extension\n * with a new version of the `insertBreak` method of the Slate editor.\n *\n * @description If the selection does not exist or is expanded, handle with the\n * default behavior. If the selection is inside a LI and it starts at a non-0\n * offset, split the LI. If the selection anchor is not in a LI or it is not at\n * offset 0, handle with the default behavior. Else delete the line before the\n * text cursor and then split the editor in two fragments, and convert them to\n * separate Slate Text blocks, based on the selection.\n */\n\nexport const breakList = editor => {\n  const {\n    insertBreak\n  } = editor;\n\n  editor.insertBreak = () => {\n    // If the selection does not exist or is expanded, handle with the default\n    // behavior.\n    if (!(editor.selection && Range.isCollapsed(editor.selection))) {\n      insertBreak();\n      return false;\n    }\n\n    const {\n      slate\n    } = config.settings;\n    const {\n      anchor\n    } = editor.selection;\n    const ref = Editor.rangeRef(editor, editor.selection, {\n      affinity: 'inward'\n    }); // If the selection is inside a LI and it starts at a non-0 offset, split\n    // the LI. (if one of the parents is a list item, break that list item)\n\n    const [listItem, listItemPath] = getCurrentListItem(editor);\n\n    if (listItem) {\n      // if there is text in the selection\n      if (Editor.string(editor, listItemPath)) {\n        Transforms.splitNodes(editor, {\n          at: editor.selection,\n          match: node => node.type === slate.listItemType,\n          always: true // in case cursor is at end of line\n\n        });\n        return true;\n      }\n    } // If the selection anchor is not in a LI or it is not at offset 0, handle\n    // with the default behavior.\n\n\n    const [parent] = Editor.parent(editor, anchor.path); // , parentPath\n\n    if (parent.type !== slate.listItemType || anchor.offset > 0) {\n      insertBreak();\n      return; // applies default behaviour, as defined in insertBreak.js extension\n    }\n\n    if (parent) {\n      const blockProps = editor.getBlockProps();\n      const {\n        data\n      } = blockProps; // Don't add new block if not allowed\n\n      if (data !== null && data !== void 0 && data.disableNewBlocks) {\n        return insertBreak();\n      }\n    }\n\n    Editor.deleteBackward(editor, {\n      unit: 'line'\n    }); // also account for empty nodes [{text: ''}]\n\n    if (Editor.isEmpty(editor, parent)) {\n      Transforms.removeNodes(editor, {\n        at: ref.current\n      });\n      createAndSelectNewBlockAfter(editor, [createEmptyParagraph()]);\n      return true;\n    }\n\n    Transforms.removeNodes(editor, {\n      at: ref.current\n    });\n\n    if (isCursorAtBlockEnd(editor)) {\n      createAndSelectNewBlockAfter(editor, [createEmptyParagraph()]);\n      return true;\n    }\n\n    const [top, bottom] = splitEditorInTwoFragments(editor, ref.current);\n    setEditorContent(editor, top);\n    createAndSelectNewBlockAfter(editor, bottom);\n    return true;\n  };\n\n  return editor;\n};","map":{"version":3,"names":["Editor","Range","Transforms","config","isCursorAtBlockEnd","splitEditorInTwoFragments","setEditorContent","createAndSelectNewBlockAfter","getCurrentListItem","createEmptyParagraph","breakList","editor","insertBreak","selection","isCollapsed","slate","settings","anchor","ref","rangeRef","affinity","listItem","listItemPath","string","splitNodes","at","match","node","type","listItemType","always","parent","path","offset","blockProps","getBlockProps","data","disableNewBlocks","deleteBackward","unit","isEmpty","removeNodes","current","top","bottom"],"sources":["/home/jakob/workspace/training-project/node_modules/@plone/volto/packages/volto-slate/src/blocks/Text/extensions/breakList.js"],"sourcesContent":["import { Editor, Range, Transforms } from 'slate';\nimport config from '@plone/volto/registry';\nimport {\n  isCursorAtBlockEnd,\n  splitEditorInTwoFragments,\n  setEditorContent,\n  createAndSelectNewBlockAfter,\n  getCurrentListItem,\n  createEmptyParagraph,\n} from '@plone/volto-slate/utils';\n\n/**\n * Handles `Enter` key on empty and non-empty list items.\n *\n * @param {Editor} editor The editor which should be modified by this extension\n * with a new version of the `insertBreak` method of the Slate editor.\n *\n * @description If the selection does not exist or is expanded, handle with the\n * default behavior. If the selection is inside a LI and it starts at a non-0\n * offset, split the LI. If the selection anchor is not in a LI or it is not at\n * offset 0, handle with the default behavior. Else delete the line before the\n * text cursor and then split the editor in two fragments, and convert them to\n * separate Slate Text blocks, based on the selection.\n */\nexport const breakList = (editor) => {\n  const { insertBreak } = editor;\n\n  editor.insertBreak = () => {\n    // If the selection does not exist or is expanded, handle with the default\n    // behavior.\n    if (!(editor.selection && Range.isCollapsed(editor.selection))) {\n      insertBreak();\n      return false;\n    }\n\n    const { slate } = config.settings;\n    const { anchor } = editor.selection;\n\n    const ref = Editor.rangeRef(editor, editor.selection, {\n      affinity: 'inward',\n    });\n\n    // If the selection is inside a LI and it starts at a non-0 offset, split\n    // the LI. (if one of the parents is a list item, break that list item)\n    const [listItem, listItemPath] = getCurrentListItem(editor);\n    if (listItem) {\n      // if there is text in the selection\n      if (Editor.string(editor, listItemPath)) {\n        Transforms.splitNodes(editor, {\n          at: editor.selection,\n          match: (node) => node.type === slate.listItemType,\n          always: true, // in case cursor is at end of line\n        });\n\n        return true;\n      }\n    }\n\n    // If the selection anchor is not in a LI or it is not at offset 0, handle\n    // with the default behavior.\n    const [parent] = Editor.parent(editor, anchor.path); // , parentPath\n\n    if (parent.type !== slate.listItemType || anchor.offset > 0) {\n      insertBreak();\n      return; // applies default behaviour, as defined in insertBreak.js extension\n    }\n\n    if (parent) {\n      const blockProps = editor.getBlockProps();\n      const { data } = blockProps;\n      // Don't add new block if not allowed\n      if (data?.disableNewBlocks) {\n        return insertBreak();\n      }\n    }\n\n    Editor.deleteBackward(editor, { unit: 'line' });\n    // also account for empty nodes [{text: ''}]\n    if (Editor.isEmpty(editor, parent)) {\n      Transforms.removeNodes(editor, { at: ref.current });\n      createAndSelectNewBlockAfter(editor, [createEmptyParagraph()]);\n      return true;\n    }\n\n    Transforms.removeNodes(editor, { at: ref.current });\n\n    if (isCursorAtBlockEnd(editor)) {\n      createAndSelectNewBlockAfter(editor, [createEmptyParagraph()]);\n      return true;\n    }\n\n    const [top, bottom] = splitEditorInTwoFragments(editor, ref.current);\n    setEditorContent(editor, top);\n    createAndSelectNewBlockAfter(editor, bottom);\n\n    return true;\n  };\n\n  return editor;\n};\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module"}