{"ast":null,"code":"import _extends from \"/home/jakob/workspace/training-project/node_modules/@babel/runtime/helpers/esm/extends\";\nimport _isEqual from \"lodash/isEqual\";\n\nvar _jsxFileName = \"/home/jakob/workspace/training-project/node_modules/@plone/volto/packages/volto-slate/src/editor/SlateEditor.jsx\",\n    _window;\n\nvar __jsx = React.createElement;\nimport ReactDOM from 'react-dom';\nimport cx from 'classnames';\nimport { Transforms, Editor } from 'slate'; // , Transforms\n\nimport { Slate, Editable, ReactEditor } from 'slate-react';\nimport React, { Component } from 'react'; // , useState\n\nimport { connect } from 'react-redux';\nimport { v4 as uuid } from 'uuid';\nimport config from '@plone/volto/registry';\nimport { Element, Leaf } from './render';\nimport withTestingFeatures from './extensions/withTestingFeatures';\nimport { makeEditor, toggleInlineFormat, toggleMark, parseDefaultSelection } from '@plone/volto-slate/utils';\nimport { InlineToolbar } from './ui';\nimport EditorContext from './EditorContext';\nimport isHotkey from 'is-hotkey';\nimport './less/editor.less';\nimport Toolbar from './ui/Toolbar';\n\nconst handleHotKeys = (editor, event, config) => {\n  let wasHotkey = false;\n\n  for (const hk of Object.entries(config.hotkeys)) {\n    const [shortcut, {\n      format,\n      type\n    }] = hk;\n\n    if (isHotkey(shortcut, event)) {\n      event.preventDefault();\n\n      if (type === 'inline') {\n        toggleInlineFormat(editor, format);\n      } else {\n        // type === 'mark'\n        toggleMark(editor, format);\n      }\n\n      wasHotkey = true;\n    }\n  }\n\n  return wasHotkey;\n}; // TODO: implement onFocus\n\n\nclass SlateEditor extends Component {\n  constructor(props) {\n    super(props);\n    this.createEditor = this.createEditor.bind(this);\n    this.multiDecorator = this.multiDecorator.bind(this);\n    this.handleChange = this.handleChange.bind(this);\n    this.getSavedSelection = this.getSavedSelection.bind(this);\n    this.setSavedSelection = this.setSavedSelection.bind(this);\n    this.savedSelection = null;\n    const uid = uuid(); // used to namespace the editor's plugins\n\n    this.slateSettings = props.slateSettings || config.settings.slate;\n    this.state = {\n      editor: this.createEditor(uid),\n      showExpandedToolbar: config.settings.slate.showExpandedToolbar,\n      internalValue: this.props.value || this.slateSettings.defaultValue(),\n      uid\n    };\n    this.editor = null;\n    this.selectionTimeout = null;\n  }\n\n  getSavedSelection() {\n    return this.savedSelection;\n  }\n\n  setSavedSelection(selection) {\n    this.savedSelection = selection;\n  }\n\n  createEditor(uid) {\n    // extensions are \"editor plugins\" or \"editor wrappers\". It's a similar\n    // similar to OOP inheritance, where a callable creates a new copy of the\n    // editor, while replacing or adding new capabilities to that editor.\n    // Extensions are purely JS, no React components.\n    const editor = makeEditor({\n      extensions: this.props.extensions\n    }); // When the editor loses focus it no longer has a valid selections. This\n    // makes it impossible to have complex types of interactions (like filling\n    // in another text box, operating a select menu, etc). For this reason we\n    // save the active selection\n\n    editor.getSavedSelection = this.getSavedSelection;\n    editor.setSavedSelection = this.setSavedSelection;\n    editor.uid = uid || this.state.uid;\n    return editor;\n  }\n\n  handleChange(value) {\n    ReactDOM.unstable_batchedUpdates(() => {\n      this.setState({\n        internalValue: value\n      });\n\n      if (this.props.onChange && !_isEqual(value, this.props.value)) {\n        this.props.onChange(value, this.editor);\n      }\n    });\n  }\n\n  multiDecorator(_ref) {\n    let [node, path] = _ref;\n    // Decorations (such as higlighting node types, selection, etc).\n    const {\n      runtimeDecorators = []\n    } = this.slateSettings;\n    return runtimeDecorators.reduce((acc, deco) => deco(this.state.editor, [node, path], acc), []);\n  }\n\n  componentDidMount() {\n    // watch the dom change\n    if (this.props.selected) {\n      let focused = true;\n\n      try {\n        focused = ReactEditor.isFocused(this.state.editor);\n      } catch {}\n\n      if (!focused) {\n        setTimeout(() => {\n          try {\n            ReactEditor.focus(this.state.editor);\n          } catch {}\n        }, 100); // flush\n      }\n    }\n  }\n\n  componentWillUnmount() {\n    this.isUnmounted = true;\n  }\n\n  componentDidUpdate(prevProps) {\n    if (!_isEqual(prevProps.extensions, this.props.extensions)) {\n      this.setState({\n        editor: this.createEditor()\n      });\n      return;\n    }\n\n    if (this.props.value && !_isEqual(this.props.value, this.state.internalValue)) {\n      const {\n        editor\n      } = this.state;\n      editor.children = this.props.value;\n\n      if (this.props.defaultSelection) {\n        const selection = parseDefaultSelection(editor, this.props.defaultSelection);\n        ReactEditor.focus(editor);\n        Transforms.select(editor, selection);\n      } else {\n        Transforms.select(editor, Editor.end(editor, []));\n      }\n\n      this.setState({\n        // editor,\n        internalValue: this.props.value\n      });\n      return;\n    }\n\n    const {\n      editor\n    } = this.state;\n\n    if (!prevProps.selected && this.props.selected) {\n      // if the SlateEditor becomes selected from unselected\n      if (window.getSelection().type === 'None') {\n        // TODO: why is this condition checked?\n        Transforms.select(this.state.editor, Editor.range(this.state.editor, Editor.start(this.state.editor, [])));\n      }\n\n      ReactEditor.focus(this.state.editor);\n    }\n\n    if (this.props.selected && this.props.onUpdate) {\n      this.props.onUpdate(editor);\n    }\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    const {\n      selected = true,\n      value,\n      readOnly\n    } = nextProps;\n    const res = selected || this.props.selected !== selected || this.props.readOnly !== readOnly || !_isEqual(value, this.props.value);\n    return res;\n  }\n\n  render() {\n    var _this$props$value;\n\n    const {\n      selected,\n      placeholder,\n      onKeyDown,\n      testingEditorRef,\n      readOnly,\n      className,\n      renderExtensions = []\n    } = this.props;\n    const slateSettings = this.slateSettings; // renderExtensions is needed because the editor is memoized, so if these\n    // extensions need an updated state (for example to insert updated\n    // blockProps) then we need to always wrap the editor with them\n\n    const editor = renderExtensions.reduce((acc, apply) => apply(acc), this.state.editor); // Reset selection if field is reset\n\n    if (editor.selection && ((_this$props$value = this.props.value) === null || _this$props$value === void 0 ? void 0 : _this$props$value.length) === 1 && this.props.value[0].children.length === 1 && this.props.value[0].children[0].text === '') {\n      Transforms.select(editor, {\n        anchor: {\n          path: [0, 0],\n          offset: 0\n        },\n        focus: {\n          path: [0, 0],\n          offset: 0\n        }\n      });\n    }\n\n    this.editor = editor;\n\n    if (testingEditorRef) {\n      testingEditorRef.current = editor;\n    } // debug-values are `data-` HTML attributes in withTestingFeatures HOC\n\n\n    return __jsx(\"div\", _extends({}, this.props['debug-values'], {\n      className: cx('slate-editor', {\n        'show-toolbar': this.state.showExpandedToolbar,\n        selected\n      }),\n      tabIndex: -1,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 250,\n        columnNumber: 7\n      }\n    }), __jsx(EditorContext.Provider, {\n      value: editor,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 258,\n        columnNumber: 9\n      }\n    }, __jsx(Slate, {\n      editor: editor,\n      value: this.props.value || slateSettings.defaultValue(),\n      onChange: this.handleChange,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 259,\n        columnNumber: 11\n      }\n    }, selected ? __jsx(React.Fragment, null, __jsx(InlineToolbar, {\n      editor: editor,\n      className: className,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 266,\n        columnNumber: 17\n      }\n    }), Object.keys(slateSettings.elementToolbarButtons).map((t, i) => {\n      return __jsx(Toolbar, {\n        elementType: t,\n        key: i,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 270,\n          columnNumber: 23\n        }\n      }, slateSettings.elementToolbarButtons[t].map((Btn, b) => {\n        return __jsx(Btn, {\n          editor: editor,\n          key: b,\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 273,\n            columnNumber: 36\n          }\n        });\n      }));\n    })) : '', __jsx(Editable, {\n      tabIndex: this.props.tabIndex || 0,\n      readOnly: readOnly,\n      placeholder: placeholder,\n      renderElement: props => __jsx(Element, _extends({}, props, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 288,\n          columnNumber: 41\n        }\n      })),\n      renderLeaf: props => __jsx(Leaf, _extends({}, props, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 289,\n          columnNumber: 38\n        }\n      })),\n      decorate: this.multiDecorator,\n      spellCheck: false,\n      scrollSelectionIntoView: slateSettings.scrollIntoView ? undefined : () => null,\n      onBlur: () => {\n        this.props.onBlur && this.props.onBlur();\n        return null;\n      },\n      onClick: this.props.onClick,\n      onSelect: e => {\n        if (!selected && this.props.onFocus) {\n          // we can't overwrite the onFocus of Editable, as the onFocus\n          // in Slate has too much builtin behaviour that's not\n          // accessible otherwise. Instead we try to detect such an\n          // event based on observing selected state\n          if (!editor.selection) {\n            setTimeout(() => {\n              this.props.onFocus();\n            }, 100); // TODO: why 100 is chosen here?\n          }\n        }\n\n        if (this.selectionTimeout) clearTimeout(this.selectionTimeout);\n        this.selectionTimeout = setTimeout(() => {\n          if (editor.selection && !_isEqual(editor.selection, this.savedSelection) && !this.isUnmounted) {\n            this.setState(state => ({\n              update: !this.state.update\n            }));\n            this.setSavedSelection(JSON.parse(JSON.stringify(editor.selection)));\n          }\n        }, 200);\n      },\n      onKeyDown: event => {\n        const handled = handleHotKeys(editor, event, slateSettings);\n        if (handled) return;\n        onKeyDown && onKeyDown({\n          editor,\n          event\n        });\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 284,\n        columnNumber: 13\n      }\n    }), selected && slateSettings.persistentHelpers.map((Helper, i) => {\n      return __jsx(Helper, {\n        key: i,\n        editor: editor,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 335,\n          columnNumber: 24\n        }\n      });\n    }), this.props.debug ? __jsx(\"ul\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 338,\n        columnNumber: 15\n      }\n    }, __jsx(\"li\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 339,\n        columnNumber: 17\n      }\n    }, selected ? 'selected' : 'no-selected'), __jsx(\"li\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 340,\n        columnNumber: 17\n      }\n    }, \"savedSelection: \", JSON.stringify(editor.getSavedSelection())), __jsx(\"li\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 343,\n        columnNumber: 17\n      }\n    }, \"live selection: \", JSON.stringify(editor.selection)), __jsx(\"li\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 344,\n        columnNumber: 17\n      }\n    }, \"children: \", JSON.stringify(editor.children)), __jsx(\"li\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 345,\n        columnNumber: 17\n      }\n    }, \" \", selected ? 'selected' : 'notselected'), __jsx(\"li\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 346,\n        columnNumber: 17\n      }\n    }, ReactEditor.isFocused(editor) ? 'focused' : 'unfocused')) : '', this.props.children)));\n  }\n\n}\n\nSlateEditor.defaultProps = {\n  extensions: [],\n  className: ''\n};\nexport default connect((state, props) => {\n  return {};\n})(__CLIENT__ && (_window = window) !== null && _window !== void 0 && _window.Cypress ? withTestingFeatures(SlateEditor) : SlateEditor);","map":{"version":3,"names":["ReactDOM","cx","Transforms","Editor","Slate","Editable","ReactEditor","React","Component","connect","v4","uuid","config","Element","Leaf","withTestingFeatures","makeEditor","toggleInlineFormat","toggleMark","parseDefaultSelection","InlineToolbar","EditorContext","isHotkey","Toolbar","handleHotKeys","editor","event","wasHotkey","hk","Object","entries","hotkeys","shortcut","format","type","preventDefault","SlateEditor","constructor","props","createEditor","bind","multiDecorator","handleChange","getSavedSelection","setSavedSelection","savedSelection","uid","slateSettings","settings","slate","state","showExpandedToolbar","internalValue","value","defaultValue","selectionTimeout","selection","extensions","unstable_batchedUpdates","setState","onChange","node","path","runtimeDecorators","reduce","acc","deco","componentDidMount","selected","focused","isFocused","setTimeout","focus","componentWillUnmount","isUnmounted","componentDidUpdate","prevProps","children","defaultSelection","select","end","window","getSelection","range","start","onUpdate","shouldComponentUpdate","nextProps","nextState","readOnly","res","render","placeholder","onKeyDown","testingEditorRef","className","renderExtensions","apply","length","text","anchor","offset","current","keys","elementToolbarButtons","map","t","i","Btn","b","tabIndex","scrollIntoView","undefined","onBlur","onClick","e","onFocus","clearTimeout","update","JSON","parse","stringify","handled","persistentHelpers","Helper","debug","defaultProps","__CLIENT__","Cypress"],"sources":["/home/jakob/workspace/training-project/node_modules/@plone/volto/packages/volto-slate/src/editor/SlateEditor.jsx"],"sourcesContent":["import ReactDOM from 'react-dom';\nimport cx from 'classnames';\nimport { isEqual } from 'lodash';\nimport { Transforms, Editor } from 'slate'; // , Transforms\nimport { Slate, Editable, ReactEditor } from 'slate-react';\nimport React, { Component } from 'react'; // , useState\nimport { connect } from 'react-redux';\nimport { v4 as uuid } from 'uuid';\n\nimport config from '@plone/volto/registry';\n\nimport { Element, Leaf } from './render';\n\nimport withTestingFeatures from './extensions/withTestingFeatures';\nimport {\n  makeEditor,\n  toggleInlineFormat,\n  toggleMark,\n  parseDefaultSelection,\n} from '@plone/volto-slate/utils';\nimport { InlineToolbar } from './ui';\nimport EditorContext from './EditorContext';\n\nimport isHotkey from 'is-hotkey';\n\nimport './less/editor.less';\n\nimport Toolbar from './ui/Toolbar';\n\nconst handleHotKeys = (editor, event, config) => {\n  let wasHotkey = false;\n\n  for (const hk of Object.entries(config.hotkeys)) {\n    const [shortcut, { format, type }] = hk;\n    if (isHotkey(shortcut, event)) {\n      event.preventDefault();\n\n      if (type === 'inline') {\n        toggleInlineFormat(editor, format);\n      } else {\n        // type === 'mark'\n        toggleMark(editor, format);\n      }\n\n      wasHotkey = true;\n    }\n  }\n\n  return wasHotkey;\n};\n\n// TODO: implement onFocus\nclass SlateEditor extends Component {\n  constructor(props) {\n    super(props);\n\n    this.createEditor = this.createEditor.bind(this);\n    this.multiDecorator = this.multiDecorator.bind(this);\n    this.handleChange = this.handleChange.bind(this);\n    this.getSavedSelection = this.getSavedSelection.bind(this);\n    this.setSavedSelection = this.setSavedSelection.bind(this);\n\n    this.savedSelection = null;\n\n    const uid = uuid(); // used to namespace the editor's plugins\n\n    this.slateSettings = props.slateSettings || config.settings.slate;\n\n    this.state = {\n      editor: this.createEditor(uid),\n      showExpandedToolbar: config.settings.slate.showExpandedToolbar,\n      internalValue: this.props.value || this.slateSettings.defaultValue(),\n      uid,\n    };\n\n    this.editor = null;\n    this.selectionTimeout = null;\n  }\n\n  getSavedSelection() {\n    return this.savedSelection;\n  }\n  setSavedSelection(selection) {\n    this.savedSelection = selection;\n  }\n\n  createEditor(uid) {\n    // extensions are \"editor plugins\" or \"editor wrappers\". It's a similar\n    // similar to OOP inheritance, where a callable creates a new copy of the\n    // editor, while replacing or adding new capabilities to that editor.\n    // Extensions are purely JS, no React components.\n    const editor = makeEditor({ extensions: this.props.extensions });\n\n    // When the editor loses focus it no longer has a valid selections. This\n    // makes it impossible to have complex types of interactions (like filling\n    // in another text box, operating a select menu, etc). For this reason we\n    // save the active selection\n\n    editor.getSavedSelection = this.getSavedSelection;\n    editor.setSavedSelection = this.setSavedSelection;\n    editor.uid = uid || this.state.uid;\n\n    return editor;\n  }\n\n  handleChange(value) {\n    ReactDOM.unstable_batchedUpdates(() => {\n      this.setState({ internalValue: value });\n      if (this.props.onChange && !isEqual(value, this.props.value)) {\n        this.props.onChange(value, this.editor);\n      }\n    });\n  }\n\n  multiDecorator([node, path]) {\n    // Decorations (such as higlighting node types, selection, etc).\n    const { runtimeDecorators = [] } = this.slateSettings;\n    return runtimeDecorators.reduce(\n      (acc, deco) => deco(this.state.editor, [node, path], acc),\n      [],\n    );\n  }\n\n  componentDidMount() {\n    // watch the dom change\n\n    if (this.props.selected) {\n      let focused = true;\n      try {\n        focused = ReactEditor.isFocused(this.state.editor);\n      } catch {}\n      if (!focused) {\n        setTimeout(() => {\n          try {\n            ReactEditor.focus(this.state.editor);\n          } catch {}\n        }, 100); // flush\n      }\n    }\n  }\n\n  componentWillUnmount() {\n    this.isUnmounted = true;\n  }\n\n  componentDidUpdate(prevProps) {\n    if (!isEqual(prevProps.extensions, this.props.extensions)) {\n      this.setState({ editor: this.createEditor() });\n      return;\n    }\n\n    if (\n      this.props.value &&\n      !isEqual(this.props.value, this.state.internalValue)\n    ) {\n      const { editor } = this.state;\n      editor.children = this.props.value;\n\n      if (this.props.defaultSelection) {\n        const selection = parseDefaultSelection(\n          editor,\n          this.props.defaultSelection,\n        );\n\n        ReactEditor.focus(editor);\n        Transforms.select(editor, selection);\n      } else {\n        Transforms.select(editor, Editor.end(editor, []));\n      }\n\n      this.setState({\n        // editor,\n        internalValue: this.props.value,\n      });\n      return;\n    }\n\n    const { editor } = this.state;\n\n    if (!prevProps.selected && this.props.selected) {\n      // if the SlateEditor becomes selected from unselected\n\n      if (window.getSelection().type === 'None') {\n        // TODO: why is this condition checked?\n        Transforms.select(\n          this.state.editor,\n          Editor.range(this.state.editor, Editor.start(this.state.editor, [])),\n        );\n      }\n\n      ReactEditor.focus(this.state.editor);\n    }\n\n    if (this.props.selected && this.props.onUpdate) {\n      this.props.onUpdate(editor);\n    }\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    const { selected = true, value, readOnly } = nextProps;\n    const res =\n      selected ||\n      this.props.selected !== selected ||\n      this.props.readOnly !== readOnly ||\n      !isEqual(value, this.props.value);\n    return res;\n  }\n\n  render() {\n    const {\n      selected,\n      placeholder,\n      onKeyDown,\n      testingEditorRef,\n      readOnly,\n      className,\n      renderExtensions = [],\n    } = this.props;\n    const slateSettings = this.slateSettings;\n\n    // renderExtensions is needed because the editor is memoized, so if these\n    // extensions need an updated state (for example to insert updated\n    // blockProps) then we need to always wrap the editor with them\n    const editor = renderExtensions.reduce(\n      (acc, apply) => apply(acc),\n      this.state.editor,\n    );\n\n    // Reset selection if field is reset\n    if (\n      editor.selection &&\n      this.props.value?.length === 1 &&\n      this.props.value[0].children.length === 1 &&\n      this.props.value[0].children[0].text === ''\n    ) {\n      Transforms.select(editor, {\n        anchor: { path: [0, 0], offset: 0 },\n        focus: { path: [0, 0], offset: 0 },\n      });\n    }\n    this.editor = editor;\n\n    if (testingEditorRef) {\n      testingEditorRef.current = editor;\n    }\n\n    // debug-values are `data-` HTML attributes in withTestingFeatures HOC\n\n    return (\n      <div\n        {...this.props['debug-values']}\n        className={cx('slate-editor', {\n          'show-toolbar': this.state.showExpandedToolbar,\n          selected,\n        })}\n        tabIndex={-1}\n      >\n        <EditorContext.Provider value={editor}>\n          <Slate\n            editor={editor}\n            value={this.props.value || slateSettings.defaultValue()}\n            onChange={this.handleChange}\n          >\n            {selected ? (\n              <>\n                <InlineToolbar editor={editor} className={className} />\n                {Object.keys(slateSettings.elementToolbarButtons).map(\n                  (t, i) => {\n                    return (\n                      <Toolbar elementType={t} key={i}>\n                        {slateSettings.elementToolbarButtons[t].map(\n                          (Btn, b) => {\n                            return <Btn editor={editor} key={b} />;\n                          },\n                        )}\n                      </Toolbar>\n                    );\n                  },\n                )}\n              </>\n            ) : (\n              ''\n            )}\n            <Editable\n              tabIndex={this.props.tabIndex || 0}\n              readOnly={readOnly}\n              placeholder={placeholder}\n              renderElement={(props) => <Element {...props} />}\n              renderLeaf={(props) => <Leaf {...props} />}\n              decorate={this.multiDecorator}\n              spellCheck={false}\n              scrollSelectionIntoView={\n                slateSettings.scrollIntoView ? undefined : () => null\n              }\n              onBlur={() => {\n                this.props.onBlur && this.props.onBlur();\n                return null;\n              }}\n              onClick={this.props.onClick}\n              onSelect={(e) => {\n                if (!selected && this.props.onFocus) {\n                  // we can't overwrite the onFocus of Editable, as the onFocus\n                  // in Slate has too much builtin behaviour that's not\n                  // accessible otherwise. Instead we try to detect such an\n                  // event based on observing selected state\n                  if (!editor.selection) {\n                    setTimeout(() => {\n                      this.props.onFocus();\n                    }, 100); // TODO: why 100 is chosen here?\n                  }\n                }\n\n                if (this.selectionTimeout) clearTimeout(this.selectionTimeout);\n                this.selectionTimeout = setTimeout(() => {\n                  if (\n                    editor.selection &&\n                    !isEqual(editor.selection, this.savedSelection) &&\n                    !this.isUnmounted\n                  ) {\n                    this.setState((state) => ({ update: !this.state.update }));\n                    this.setSavedSelection(\n                      JSON.parse(JSON.stringify(editor.selection)),\n                    );\n                  }\n                }, 200);\n              }}\n              onKeyDown={(event) => {\n                const handled = handleHotKeys(editor, event, slateSettings);\n                if (handled) return;\n                onKeyDown && onKeyDown({ editor, event });\n              }}\n            />\n            {selected &&\n              slateSettings.persistentHelpers.map((Helper, i) => {\n                return <Helper key={i} editor={editor} />;\n              })}\n            {this.props.debug ? (\n              <ul>\n                <li>{selected ? 'selected' : 'no-selected'}</li>\n                <li>\n                  savedSelection: {JSON.stringify(editor.getSavedSelection())}\n                </li>\n                <li>live selection: {JSON.stringify(editor.selection)}</li>\n                <li>children: {JSON.stringify(editor.children)}</li>\n                <li> {selected ? 'selected' : 'notselected'}</li>\n                <li>\n                  {ReactEditor.isFocused(editor) ? 'focused' : 'unfocused'}\n                </li>\n              </ul>\n            ) : (\n              ''\n            )}\n            {this.props.children}\n          </Slate>\n        </EditorContext.Provider>\n      </div>\n    );\n  }\n}\n\nSlateEditor.defaultProps = {\n  extensions: [],\n  className: '',\n};\n\nexport default connect((state, props) => {\n  return {};\n})(\n  __CLIENT__ && window?.Cypress\n    ? withTestingFeatures(SlateEditor)\n    : SlateEditor,\n);\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module"}