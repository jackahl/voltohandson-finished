{"ast":null,"code":"import _extends from \"/home/jakob/workspace/training-project/node_modules/@babel/runtime/helpers/esm/extends\";\nimport _transform from \"lodash/transform\";\nimport _isObject from \"lodash/isObject\";\nimport _isEqual from \"lodash/isEqual\";\nimport _flatten from \"lodash/flatten\";\nimport _cloneDeepWith from \"lodash/cloneDeepWith\";\nvar _jsxFileName = \"/home/jakob/workspace/training-project/node_modules/@plone/volto/src/helpers/Utils/Utils.js\";\nvar __jsx = React.createElement;\nimport React from 'react';\nimport { matchPath } from 'react-router';\nimport config from '@plone/volto/registry';\n/**\n * Deep diff between two object, using lodash\n * @param  {Object} object Object compared\n * @param  {Object} base   Object to compare with\n * @return {Object}        Return a new object who represent the diff\n */\n\nexport function difference(object, base) {\n  return _transform(object, (result, value, key) => {\n    if (!_isEqual(value, base[key])) {\n      result[key] = _isObject(value) && _isObject(base[key]) ? difference(value, base[key]) : value;\n    }\n  });\n}\n/**\n * Throw an error if the wrapped function returns undefined\n *\n * @param {Function} func\n */\n\nexport const safeWrapper = func => config => {\n  const res = func(config);\n\n  if (typeof res === 'undefined') {\n    throw new Error(`Configuration function doesn't return config, ${func}`);\n  }\n\n  return res;\n};\n/**\n * A helper to pipe a configuration object through configuration loaders\n *\n * @param {Array} configMethods A list of configuration methods\n * @param {Object} config The Volto singleton config object\n */\n\nexport function applyConfig(configMethods, config) {\n  return configMethods.reduce((acc, apply) => safeWrapper(apply)(acc), config);\n}\n/**\n * A HOC factory that propagates the status of asyncConnected requests back to\n * the main server process, to allow properly expressing an error status as\n * HTTP status code\n *\n * @param {} code HTTP return code\n */\n\nexport function withServerErrorCode(code) {\n  return WrappedComponent => props => {\n    if (props.staticContext && Object.keys(props.staticContext).length === 0) {\n      const {\n        staticContext\n      } = props;\n      staticContext.error_code = code;\n      staticContext.error = props.error;\n    }\n\n    return __jsx(WrappedComponent, _extends({}, props, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 60,\n        columnNumber: 12\n      }\n    }));\n  };\n} // See https://en.wikipedia.org/wiki/Web_colors#Extended_colors\n\nconst safeColors = ['Black', 'Blue', 'BlueViolet', 'Brown', 'Crimson', 'DarkBlue', 'DarkCyan', 'DarkGreen', 'DarkMagenta', 'DarkOliveGreen', 'DarkOrchid', 'DarkRed', 'DarkSlateBlue', 'DarkSlateGray', 'DarkViolet', 'DeepPink', 'DimGray', 'DodgerBlue', 'Firebrick', 'ForestGreen', 'Fuchsia', 'Green', 'IndianRed', 'Indigo', 'Magenta', 'Maroon', 'MediumBlue', 'MediumSlateBlue', 'MediumVioletRed', 'MidnightBlue', 'Navy', 'Olive', 'OliveDrab', 'OrangeRed', 'Purple', 'Red', 'RoyalBlue', 'SaddleBrown', 'SeaGreen', 'Sienna', 'SlateBlue', 'SlateGray', 'SteelBlue', 'Teal'];\nconst namedColors = {};\n/**\n * Will generate initials from string\n * @param {string} name\n * @param {integer} count\n * @returns {string} only one letter if received only one name\n */\n\nexport const getInitials = (title, limit) => {\n  const text = title.split(' ').map(n => n[0] ? n[0].toUpperCase() : '').join('');\n\n  if (limit) {\n    return text.substring(0, limit);\n  }\n\n  return text;\n};\n/**\n * Will generate a random color hex\n * Will also remmember the color for each userId\n * @param {string} userId\n */\n\nexport const getColor = name => {\n  const namedColor = namedColors[name] ? namedColors[name] : safeColors.length > 0 ? safeColors.pop() : `#${Math.floor(Math.random() * 16777215).toString(16)}`;\n\n  if (!namedColors[name]) {\n    namedColors[name] = namedColor;\n  }\n\n  return namedColor;\n};\n/**\n * Fixes TimeZones issues on moment date objects\n * Parses a DateTime and sets correct moment locale\n * @param {string} locale Current locale\n * @param {string} value DateTime string\n * @param {string} format Date format of choice\n * @returns {Object|string} Moment object or string if format is set\n */\n\nexport const parseDateTime = (locale, value, format, moment) => {\n  //  Used to set a server timezone or UTC as default\n  moment.updateLocale(locale, moment.localeData(locale)._config); // copy locale to moment-timezone\n\n  let datetime = null;\n\n  if (value) {\n    // check if datetime has timezone, otherwise assumes it's UTC\n    datetime = !value.match(/T/) || value.match(/T(.)*(-|\\+|Z)/g) ? // Since we assume UTC everywhere, then transform to local (momentjs default)\n    moment(value) : // This might happen in old Plone versions dates\n    moment(`${value}Z`);\n  }\n\n  if (format && datetime) {\n    return datetime.format(format);\n  }\n\n  return datetime;\n};\n/**\n * Converts a language code to the format `lang_region`\n * Useful for passing from Plone's i18n lang names to Xnix locale names\n * eg. LC_MESSAGES/lang_region.po filenames\n * @param {string} language Language to be converted\n * @returns {string} Language converted\n */\n\nexport const normalizeLanguageName = language => {\n  if (language.includes('-')) {\n    let normalizedLang = language.split('-');\n    normalizedLang = `${normalizedLang[0]}_${normalizedLang[1].toUpperCase()}`;\n    return normalizedLang;\n  }\n\n  return language;\n};\n/**\n * Converts a language code to the format `lang-region`\n * `react-intl` only supports this syntax, so coming from the language\n * negotiation of the `locale` lib, one need to convert it first\n * @param {string} language Language to be converted\n * @returns {string} Language converted\n */\n\nexport const toLangUnderscoreRegion = language => {\n  if (language.includes('_')) {\n    let langCode = language.split('_');\n    langCode = `${langCode[0]}-${langCode[1].toUpperCase()}`;\n    return langCode;\n  }\n\n  return language;\n};\n/**\n * Lookup if a given expander is set in apiExpanders\n * @param {string} language Language to be normalized\n * @returns {string} Language normalized\n */\n\nexport const hasApiExpander = function (expander) {\n  let path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  let type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'GET_CONTENT';\n  return _flatten(config.settings.apiExpanders.filter(expand => matchPath(path, expand.match) && expand[type]).map(expand => expand[type])).includes(expander);\n};\n/**\n * Insert element into array at a give index\n * @param {Array} array Array with data\n * @param {*} element Element to be inserted\n * @param {number} index Index of item to be inserted at\n * @returns {Array} Array with inserted element\n */\n\nexport const insertInArray = (array, element, index) => [...array.slice(0, index), element, ...array.slice(index)];\n/**\n * Replace element in array at a give index\n * @param {Array} array Array with data\n * @param {*} element Element to be replaced\n * @param {number} index Index of item to be replaced at\n * @returns {Array} Array with replaced element\n */\n\nexport const replaceItemOfArray = (array, index, value) => Object.assign([...array], {\n  [index]: value\n});\n/**\n * Remove item from array at given index\n * @param {Array} array Array with data\n * @param {number} index Index of item to be removed\n * @returns {Array} Array without deleted element\n */\n\nexport const removeFromArray = (array, index) => {\n  let newArray = array.slice();\n  newArray.splice(index, 1);\n  return newArray;\n};\n/**\n * Reorder array\n * @param {Array} array Array with data\n * @param {number} origin Index of item to be reordered\n * @param {number} target Index of item to be reordered to\n * @returns {Array} Array with reordered elements\n */\n\nexport const reorderArray = (array, origin, target) => {\n  const result = Array.from(array);\n  const [removed] = result.splice(origin, 1);\n  result.splice(target, 0, removed);\n  return result;\n};\n/**\n * Slugify a string: remove whitespaces, special chars and replace with _\n * @param {string} string String to be slugified\n * @returns {string} Slugified string\n */\n\nexport const slugify = string => {\n  return string.toLowerCase().replace(/[\\s-]+/g, '_').replace(/[^\\w]+/g, '');\n};\n/**\n * cloneDeep an object with support for JSX nodes on it\n * Somehow, in a browser it fails with a \"Illegal invocation\" error\n * but in node (Jest test) it doesn't. This does the trick.\n * @param {object} object object to be cloned\n * @returns {object} deep cloned object\n */\n\nexport const cloneDeepSchema = object => {\n  return _cloneDeepWith(object, value => {\n    if ( /*#__PURE__*/React.isValidElement(value)) {\n      // If a JSX valid element, just return it, do not try to deep clone it\n      return value;\n    }\n  });\n};","map":{"version":3,"names":["React","matchPath","config","difference","object","base","result","value","key","safeWrapper","func","res","Error","applyConfig","configMethods","reduce","acc","apply","withServerErrorCode","code","WrappedComponent","props","staticContext","Object","keys","length","error_code","error","safeColors","namedColors","getInitials","title","limit","text","split","map","n","toUpperCase","join","substring","getColor","name","namedColor","pop","Math","floor","random","toString","parseDateTime","locale","format","moment","updateLocale","localeData","_config","datetime","match","normalizeLanguageName","language","includes","normalizedLang","toLangUnderscoreRegion","langCode","hasApiExpander","expander","path","type","settings","apiExpanders","filter","expand","insertInArray","array","element","index","slice","replaceItemOfArray","assign","removeFromArray","newArray","splice","reorderArray","origin","target","Array","from","removed","slugify","string","toLowerCase","replace","cloneDeepSchema","isValidElement"],"sources":["/home/jakob/workspace/training-project/node_modules/@plone/volto/src/helpers/Utils/Utils.js"],"sourcesContent":["import { cloneDeepWith, flatten, isEqual, isObject, transform } from 'lodash';\nimport React from 'react';\nimport { matchPath } from 'react-router';\nimport config from '@plone/volto/registry';\n\n/**\n * Deep diff between two object, using lodash\n * @param  {Object} object Object compared\n * @param  {Object} base   Object to compare with\n * @return {Object}        Return a new object who represent the diff\n */\nexport function difference(object, base) {\n  return transform(object, (result, value, key) => {\n    if (!isEqual(value, base[key])) {\n      result[key] =\n        isObject(value) && isObject(base[key])\n          ? difference(value, base[key])\n          : value;\n    }\n  });\n}\n\n/**\n * Throw an error if the wrapped function returns undefined\n *\n * @param {Function} func\n */\nexport const safeWrapper = (func) => (config) => {\n  const res = func(config);\n  if (typeof res === 'undefined') {\n    throw new Error(`Configuration function doesn't return config, ${func}`);\n  }\n  return res;\n};\n\n/**\n * A helper to pipe a configuration object through configuration loaders\n *\n * @param {Array} configMethods A list of configuration methods\n * @param {Object} config The Volto singleton config object\n */\nexport function applyConfig(configMethods, config) {\n  return configMethods.reduce((acc, apply) => safeWrapper(apply)(acc), config);\n}\n\n/**\n * A HOC factory that propagates the status of asyncConnected requests back to\n * the main server process, to allow properly expressing an error status as\n * HTTP status code\n *\n * @param {} code HTTP return code\n */\nexport function withServerErrorCode(code) {\n  return (WrappedComponent) => (props) => {\n    if (props.staticContext && Object.keys(props.staticContext).length === 0) {\n      const { staticContext } = props;\n      staticContext.error_code = code;\n      staticContext.error = props.error;\n    }\n    return <WrappedComponent {...props} />;\n  };\n}\n\n// See https://en.wikipedia.org/wiki/Web_colors#Extended_colors\nconst safeColors = [\n  'Black',\n  'Blue',\n  'BlueViolet',\n  'Brown',\n  'Crimson',\n  'DarkBlue',\n  'DarkCyan',\n  'DarkGreen',\n  'DarkMagenta',\n  'DarkOliveGreen',\n  'DarkOrchid',\n  'DarkRed',\n  'DarkSlateBlue',\n  'DarkSlateGray',\n  'DarkViolet',\n  'DeepPink',\n  'DimGray',\n  'DodgerBlue',\n  'Firebrick',\n  'ForestGreen',\n  'Fuchsia',\n  'Green',\n  'IndianRed',\n  'Indigo',\n  'Magenta',\n  'Maroon',\n  'MediumBlue',\n  'MediumSlateBlue',\n  'MediumVioletRed',\n  'MidnightBlue',\n  'Navy',\n  'Olive',\n  'OliveDrab',\n  'OrangeRed',\n  'Purple',\n  'Red',\n  'RoyalBlue',\n  'SaddleBrown',\n  'SeaGreen',\n  'Sienna',\n  'SlateBlue',\n  'SlateGray',\n  'SteelBlue',\n  'Teal',\n];\nconst namedColors = {};\n\n/**\n * Will generate initials from string\n * @param {string} name\n * @param {integer} count\n * @returns {string} only one letter if received only one name\n */\nexport const getInitials = (title, limit) => {\n  const text = title\n    .split(' ')\n    .map((n) => (n[0] ? n[0].toUpperCase() : ''))\n    .join('');\n  if (limit) {\n    return text.substring(0, limit);\n  }\n  return text;\n};\n\n/**\n * Will generate a random color hex\n * Will also remmember the color for each userId\n * @param {string} userId\n */\nexport const getColor = (name) => {\n  const namedColor = namedColors[name]\n    ? namedColors[name]\n    : safeColors.length > 0\n    ? safeColors.pop()\n    : `#${Math.floor(Math.random() * 16777215).toString(16)}`;\n  if (!namedColors[name]) {\n    namedColors[name] = namedColor;\n  }\n  return namedColor;\n};\n\n/**\n * Fixes TimeZones issues on moment date objects\n * Parses a DateTime and sets correct moment locale\n * @param {string} locale Current locale\n * @param {string} value DateTime string\n * @param {string} format Date format of choice\n * @returns {Object|string} Moment object or string if format is set\n */\nexport const parseDateTime = (locale, value, format, moment) => {\n  //  Used to set a server timezone or UTC as default\n  moment.updateLocale(locale, moment.localeData(locale)._config); // copy locale to moment-timezone\n  let datetime = null;\n\n  if (value) {\n    // check if datetime has timezone, otherwise assumes it's UTC\n    datetime =\n      !value.match(/T/) || value.match(/T(.)*(-|\\+|Z)/g)\n        ? // Since we assume UTC everywhere, then transform to local (momentjs default)\n          moment(value)\n        : // This might happen in old Plone versions dates\n          moment(`${value}Z`);\n  }\n\n  if (format && datetime) {\n    return datetime.format(format);\n  }\n  return datetime;\n};\n\n/**\n * Converts a language code to the format `lang_region`\n * Useful for passing from Plone's i18n lang names to Xnix locale names\n * eg. LC_MESSAGES/lang_region.po filenames\n * @param {string} language Language to be converted\n * @returns {string} Language converted\n */\nexport const normalizeLanguageName = (language) => {\n  if (language.includes('-')) {\n    let normalizedLang = language.split('-');\n    normalizedLang = `${normalizedLang[0]}_${normalizedLang[1].toUpperCase()}`;\n    return normalizedLang;\n  }\n\n  return language;\n};\n\n/**\n * Converts a language code to the format `lang-region`\n * `react-intl` only supports this syntax, so coming from the language\n * negotiation of the `locale` lib, one need to convert it first\n * @param {string} language Language to be converted\n * @returns {string} Language converted\n */\nexport const toLangUnderscoreRegion = (language) => {\n  if (language.includes('_')) {\n    let langCode = language.split('_');\n    langCode = `${langCode[0]}-${langCode[1].toUpperCase()}`;\n    return langCode;\n  }\n\n  return language;\n};\n\n/**\n * Lookup if a given expander is set in apiExpanders\n * @param {string} language Language to be normalized\n * @returns {string} Language normalized\n */\nexport const hasApiExpander = (expander, path = '', type = 'GET_CONTENT') => {\n  return flatten(\n    config.settings.apiExpanders\n      .filter((expand) => matchPath(path, expand.match) && expand[type])\n      .map((expand) => expand[type]),\n  ).includes(expander);\n};\n\n/**\n * Insert element into array at a give index\n * @param {Array} array Array with data\n * @param {*} element Element to be inserted\n * @param {number} index Index of item to be inserted at\n * @returns {Array} Array with inserted element\n */\nexport const insertInArray = (array, element, index) => [\n  ...array.slice(0, index),\n  element,\n  ...array.slice(index),\n];\n\n/**\n * Replace element in array at a give index\n * @param {Array} array Array with data\n * @param {*} element Element to be replaced\n * @param {number} index Index of item to be replaced at\n * @returns {Array} Array with replaced element\n */\nexport const replaceItemOfArray = (array, index, value) =>\n  Object.assign([...array], { [index]: value });\n\n/**\n * Remove item from array at given index\n * @param {Array} array Array with data\n * @param {number} index Index of item to be removed\n * @returns {Array} Array without deleted element\n */\nexport const removeFromArray = (array, index) => {\n  let newArray = array.slice();\n  newArray.splice(index, 1);\n  return newArray;\n};\n\n/**\n * Reorder array\n * @param {Array} array Array with data\n * @param {number} origin Index of item to be reordered\n * @param {number} target Index of item to be reordered to\n * @returns {Array} Array with reordered elements\n */\nexport const reorderArray = (array, origin, target) => {\n  const result = Array.from(array);\n  const [removed] = result.splice(origin, 1);\n  result.splice(target, 0, removed);\n\n  return result;\n};\n\n/**\n * Slugify a string: remove whitespaces, special chars and replace with _\n * @param {string} string String to be slugified\n * @returns {string} Slugified string\n */\nexport const slugify = (string) => {\n  return string\n    .toLowerCase()\n    .replace(/[\\s-]+/g, '_')\n    .replace(/[^\\w]+/g, '');\n};\n\n/**\n * cloneDeep an object with support for JSX nodes on it\n * Somehow, in a browser it fails with a \"Illegal invocation\" error\n * but in node (Jest test) it doesn't. This does the trick.\n * @param {object} object object to be cloned\n * @returns {object} deep cloned object\n */\nexport const cloneDeepSchema = (object) => {\n  return cloneDeepWith(object, (value) => {\n    if (React.isValidElement(value)) {\n      // If a JSX valid element, just return it, do not try to deep clone it\n      return value;\n    }\n  });\n};\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module"}