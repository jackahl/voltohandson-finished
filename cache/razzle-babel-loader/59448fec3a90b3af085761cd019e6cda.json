{"ast":null,"code":"import _isEmpty from \"lodash/isEmpty\";\nimport _intersection from \"lodash/intersection\";\nimport _keys from \"lodash/keys\";\nimport _uniq from \"lodash/uniq\";\nimport _map from \"lodash/map\";\nimport { messages } from '../MessageLabels/MessageLabels';\n/**\n * Will return the intl message if invalid\n * @param {boolean} isValid\n * @param {string} maxCriterion\n * @param {string | number} valueToCompare can compare '47' < 50\n * @param {Function} intlFunc\n */\n\nconst validationMessage = (isValid, maxCriterion, valueToCompare, intlFunc) => !isValid ? intlFunc(messages[maxCriterion], {\n  len: valueToCompare\n}) : null;\n/**\n * Returns if based on the criterion the value is lower or equal\n * @param {string | number} value can compare '47' < 50\n * @param {string | number} valueToCompare can compare '47' < 50\n * @param {string} minCriterion\n * @param {Function} intlFunc\n */\n\n\nconst isMaxPropertyValid = (value, valueToCompare, minCriterion, intlFunc) => {\n  const isValid = valueToCompare !== undefined ? value <= valueToCompare : true;\n  return validationMessage(isValid, minCriterion, valueToCompare, intlFunc);\n};\n/**\n * Returns if based on the criterion the value is higher or equal\n * @param {string | number} value can compare '47' < 50\n * @param {string | number} valueToCompare can compare '47' < 50\n * @param {string} minCriterion\n * @param {Function} intlFunc\n */\n\n\nconst isMinPropertyValid = (value, valueToCompare, maxCriterion, intlFunc) => {\n  const isValid = valueToCompare !== undefined ? value >= valueToCompare : true;\n  return validationMessage(isValid, maxCriterion, valueToCompare, intlFunc);\n};\n\nconst widgetValidation = {\n  email: {\n    isValidEmail: (emailValue, emailObj, intlFunc) => {\n      // Email Regex taken from from WHATWG living standard:\n      // https://html.spec.whatwg.org/multipage/input.html#e-mail-state-(type=email)\n      const emailRegex = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n      const isValid = emailRegex.test(emailValue);\n      return !isValid ? intlFunc(messages.isValidEmail) : null;\n    },\n    minLength: (emailValue, emailObj, intlFunc) => isMinPropertyValid(emailValue.length, emailObj.minLength, 'minLength', intlFunc),\n    maxLength: (emailValue, emailObj, intlFunc) => isMaxPropertyValid(emailValue.length, emailObj.maxLength, 'maxLength', intlFunc)\n  },\n  url: {\n    isValidURL: (urlValue, urlObj, intlFunc) => {\n      const urlRegex = /^(http:\\/\\/www\\.|https:\\/\\/www\\.|http:\\/\\/|https:\\/\\/)?[a-z0-9]+([-.]{1}[a-z0-9]+)*\\.[a-z]{2,5}(:[0-9]{1,5})?(\\/.*)?|^(http:\\/\\/www\\.|https:\\/\\/www\\.|http:\\/\\/|https:\\/\\/)?[a-z0-9]+([_.]{1}[a-z0-9]+)*\\.[a-z]{2,5}(:[0-9]{1,5})?(\\/.*)?|^((http:\\/\\/www\\.|https:\\/\\/www\\.|http:\\/\\/|https:\\/\\/)?([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$/gm;\n      const isValid = urlRegex.test(urlValue);\n      return !isValid ? intlFunc(messages.isValidURL) : null;\n    },\n    minLength: (urlValue, urlObj, intlFunc) => isMinPropertyValid(urlValue.length, urlObj.minLength, 'minLength', intlFunc),\n    maxLength: (urlValue, urlObj, intlFunc) => isMaxPropertyValid(urlValue.length, urlObj.maxLength, 'maxLength', intlFunc)\n  },\n  password: {\n    minLength: (passwordValue, passwordObj, intlFunc) => isMinPropertyValid(passwordValue.length, passwordObj.minLength, 'minLength', intlFunc),\n    maxLength: (passwordValue, passwordObj, intlFunc) => isMaxPropertyValid(passwordValue.length, passwordObj.maxLength, 'maxLength', intlFunc)\n  },\n  string: {\n    minLength: (value, itemObj, intlFunc) => isMinPropertyValid(value.length, itemObj.minLength, 'minLength', intlFunc),\n    maxLength: (value, itemObj, intlFunc) => isMaxPropertyValid(value.length, itemObj.maxLengthj, 'maxLength', intlFunc)\n  },\n  number: {\n    isNumber: (value, itemObj, intlFunc) => {\n      const floatRegex = /^[+-]?\\d+(\\.\\d+)?$/;\n      const isValid = !isNaN(value) && floatRegex.test(value);\n      return !isValid ? intlFunc(messages.isNumber) : null;\n    },\n    minimum: (value, itemObj, intlFunc) => isMinPropertyValid(value, itemObj.minimum, 'minimum', intlFunc),\n    maximum: (value, itemObj, intlFunc) => isMaxPropertyValid(value, itemObj.maximum, 'maximum', intlFunc)\n  },\n  integer: {\n    isInteger: (value, itemObj, intlFunc) => {\n      const intRegex = /^-?[0-9]+$/;\n      const isValid = !isNaN(value) && intRegex.test(value);\n      return !isValid ? intlFunc(messages.isInteger) : null;\n    },\n    minimum: (value, itemObj, intlFunc) => isMinPropertyValid(value, itemObj.minimum, 'minimum', intlFunc),\n    maximum: (value, itemObj, intlFunc) => isMaxPropertyValid(value, itemObj.maximum, 'maximum', intlFunc)\n  }\n};\n/**\n * The string that comes my not be a valid JSON\n * @param {string} requestItem\n */\n\nconst tryParseJSON = requestItem => {\n  let resultObj = null;\n\n  try {\n    resultObj = JSON.parse(requestItem);\n  } catch (e) {\n    try {\n      resultObj = JSON.parse(requestItem.replace(/'/g, '\"'));\n    } catch (e) {\n      resultObj = null;\n    }\n  }\n\n  return resultObj;\n};\n/**\n * Returns errors if obj has unique Items\n * @param {Object} field\n * @param {*} fieldData\n * @returns {Object[string]} - list of errors\n */\n\n\nconst hasUniqueItems = (field, fieldData, formatMessage) => {\n  const errors = [];\n\n  if (field.uniqueItems && fieldData && _uniq(fieldData).length !== fieldData.length) {\n    errors.push(formatMessage(messages.uniqueItems));\n  }\n\n  return errors;\n};\n/**\n * If required fields are undefined, return list of errors\n * @returns {Object[string]} - list of errors\n */\n\n\nconst validateRequiredFields = (schema, formData, formatMessage, touchedField) => {\n  const errors = {};\n  const fields = _isEmpty(touchedField) ? schema.required : _intersection(schema.required, _keys(touchedField));\n\n  _map(fields, requiredField => {\n    var _schema$properties$re, _schema$properties$re2;\n\n    const type = (_schema$properties$re = schema.properties[requiredField]) === null || _schema$properties$re === void 0 ? void 0 : _schema$properties$re.type;\n    const widget = (_schema$properties$re2 = schema.properties[requiredField]) === null || _schema$properties$re2 === void 0 ? void 0 : _schema$properties$re2.widget;\n    let isEmpty = !formData[requiredField];\n\n    if (!isEmpty) {\n      if (type === 'array') {\n        isEmpty = formData[requiredField] ? formData[requiredField].length === 0 : true;\n      } else if (type === 'string' && widget === 'richtext') {\n        var _formData$requiredFie, _formData$requiredFie2;\n\n        isEmpty = !(((_formData$requiredFie = formData[requiredField]) === null || _formData$requiredFie === void 0 ? void 0 : (_formData$requiredFie2 = _formData$requiredFie.data) === null || _formData$requiredFie2 === void 0 ? void 0 : _formData$requiredFie2.replace(/(<([^>]+)>)/g, '').length) > 0);\n      }\n    }\n\n    if (schema.properties[requiredField] && schema.properties[requiredField].type !== 'boolean' && !schema.properties[requiredField].readonly && isEmpty) {\n      const requiredFieldName = schema.properties[requiredField].title || requiredField;\n      errors[requiredFieldName] = [];\n      errors[requiredFieldName].push(formatMessage(messages.required));\n    }\n  });\n\n  return errors;\n};\n/**\n * Return list of errors if field constraints are not respected\n * (ex min, max, maxLength, email format, url format etc)\n * each potential criterion has a validation process in widgetValidation\n * !!ONLY fields with data will be tested (those undefined are ignored here)\n * @returns {Object[string]} - list of errors\n */\n\n\nconst validateFieldsPerFieldset = (schema, formData, formatMessage, touchedField) => {\n  const errors = validateRequiredFields(schema, formData, formatMessage, touchedField);\n\n  _map(schema.properties, (field, fieldId) => {\n    const fieldWidgetType = field.widget || field.type;\n    const widgetValidationCriteria = widgetValidation[fieldWidgetType] ? Object.keys(widgetValidation[fieldWidgetType]) : [];\n    let fieldData = formData[fieldId]; // test each criterion ex maximum, isEmail, isUrl, maxLength etc\n\n    const fieldErrors = widgetValidationCriteria.map(widgetCriterion => {\n      const errorMessage = fieldData === undefined || fieldData === null ? null : widgetValidation[fieldWidgetType][widgetCriterion](fieldData, field, formatMessage);\n      return errorMessage;\n    }).filter(item => !!item);\n    const uniqueErrors = hasUniqueItems(field, fieldData, formatMessage);\n    const mergedErrors = [...fieldErrors, ...uniqueErrors];\n\n    if (mergedErrors.length > 0) {\n      errors[fieldId] = [...(errors[fieldId] || []), ...fieldErrors, ...uniqueErrors];\n    }\n  });\n\n  return errors;\n};\n/**\n * Create the errors object from backend the same way it is done on Frontend validation\n * @param {string} requestError form the server\n * @returns {Object}\n */\n\n\nconst giveServerErrorsToCorrespondingFields = requestError => {\n  let errorsList = tryParseJSON(requestError);\n  const errors = {};\n\n  if (Array.isArray(errorsList) && errorsList.length > 0) {\n    errorsList.forEach(errorItem => {\n      errors[errorItem.field] = errors[errorItem.field] ? errors[errorItem.field].push(errorItem.message) : [errorItem.message];\n    });\n  }\n\n  return errors;\n};\n/**\n * The first Fieldset (Tab) that has any errors\n * will be selected\n * @param {Object[]} errors\n * @param {string} errors[].field\n * @param {Object} schema\n * @returns {number} activeIndex\n */\n\n\nconst getIndexOfFirstTabWithErrors = (errors, schema) => {\n  let activeIndex = 0;\n  schema.fieldsets.some((fieldSet, index) => {\n    let foundfield = fieldSet.fields.some(fieldId => errors[fieldId]);\n    activeIndex = foundfield ? index : activeIndex;\n    return foundfield;\n  });\n  return activeIndex;\n};\n\nclass FormValidation {\n  /**\n   * The first Fieldset (Tab) that has any errors\n   * will be selected\n   * @param {Object} errors\n   * @param {Object} schema\n   * @returns {number} activeIndex\n   */\n  static showFirstTabWithErrors() {\n    let {\n      errors = {},\n      schema = {\n        properties: {},\n        fieldsets: [],\n        required: []\n      }\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return getIndexOfFirstTabWithErrors(errors, schema);\n  }\n  /**\n   * Create the errors object from backend the same way it is done on Frontend validation\n   * @param {string} requestError form the server\n   * @returns {Object}\n   */\n\n\n  static giveServerErrorsToCorrespondingFields() {\n    let requestError = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    return giveServerErrorsToCorrespondingFields(requestError);\n  }\n  /**\n   * Return validation result\n   * @param {Object} schema\n   * @param {Object} formData\n   * @param {function} formatMessage\n   * @returns {Object} errors\n   */\n\n\n  static validateFieldsPerFieldset() {\n    let {\n      schema = {\n        properties: {},\n        fieldsets: [],\n        required: []\n      },\n      formData = {},\n      formatMessage = () => {},\n      touchedField = {}\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return validateFieldsPerFieldset(schema, formData, formatMessage, touchedField);\n  }\n\n}\n\nexport default FormValidation;","map":{"version":3,"names":["messages","validationMessage","isValid","maxCriterion","valueToCompare","intlFunc","len","isMaxPropertyValid","value","minCriterion","undefined","isMinPropertyValid","widgetValidation","email","isValidEmail","emailValue","emailObj","emailRegex","test","minLength","length","maxLength","url","isValidURL","urlValue","urlObj","urlRegex","password","passwordValue","passwordObj","string","itemObj","maxLengthj","number","isNumber","floatRegex","isNaN","minimum","maximum","integer","isInteger","intRegex","tryParseJSON","requestItem","resultObj","JSON","parse","e","replace","hasUniqueItems","field","fieldData","formatMessage","errors","uniqueItems","push","validateRequiredFields","schema","formData","touchedField","fields","required","requiredField","type","properties","widget","isEmpty","data","readonly","requiredFieldName","title","validateFieldsPerFieldset","fieldId","fieldWidgetType","widgetValidationCriteria","Object","keys","fieldErrors","map","widgetCriterion","errorMessage","filter","item","uniqueErrors","mergedErrors","giveServerErrorsToCorrespondingFields","requestError","errorsList","Array","isArray","forEach","errorItem","message","getIndexOfFirstTabWithErrors","activeIndex","fieldsets","some","fieldSet","index","foundfield","FormValidation","showFirstTabWithErrors"],"sources":["/home/jakob/workspace/training-project/node_modules/@plone/volto/src/helpers/FormValidation/FormValidation.js"],"sourcesContent":["import { map, uniq, keys, intersection, isEmpty } from 'lodash';\nimport { messages } from '../MessageLabels/MessageLabels';\n\n/**\n * Will return the intl message if invalid\n * @param {boolean} isValid\n * @param {string} maxCriterion\n * @param {string | number} valueToCompare can compare '47' < 50\n * @param {Function} intlFunc\n */\nconst validationMessage = (isValid, maxCriterion, valueToCompare, intlFunc) =>\n  !isValid\n    ? intlFunc(messages[maxCriterion], {\n        len: valueToCompare,\n      })\n    : null;\n/**\n * Returns if based on the criterion the value is lower or equal\n * @param {string | number} value can compare '47' < 50\n * @param {string | number} valueToCompare can compare '47' < 50\n * @param {string} minCriterion\n * @param {Function} intlFunc\n */\nconst isMaxPropertyValid = (value, valueToCompare, minCriterion, intlFunc) => {\n  const isValid = valueToCompare !== undefined ? value <= valueToCompare : true;\n  return validationMessage(isValid, minCriterion, valueToCompare, intlFunc);\n};\n/**\n * Returns if based on the criterion the value is higher or equal\n * @param {string | number} value can compare '47' < 50\n * @param {string | number} valueToCompare can compare '47' < 50\n * @param {string} minCriterion\n * @param {Function} intlFunc\n */\nconst isMinPropertyValid = (value, valueToCompare, maxCriterion, intlFunc) => {\n  const isValid = valueToCompare !== undefined ? value >= valueToCompare : true;\n  return validationMessage(isValid, maxCriterion, valueToCompare, intlFunc);\n};\n\nconst widgetValidation = {\n  email: {\n    isValidEmail: (emailValue, emailObj, intlFunc) => {\n      // Email Regex taken from from WHATWG living standard:\n      // https://html.spec.whatwg.org/multipage/input.html#e-mail-state-(type=email)\n      const emailRegex = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n      const isValid = emailRegex.test(emailValue);\n      return !isValid ? intlFunc(messages.isValidEmail) : null;\n    },\n    minLength: (emailValue, emailObj, intlFunc) =>\n      isMinPropertyValid(\n        emailValue.length,\n        emailObj.minLength,\n        'minLength',\n        intlFunc,\n      ),\n    maxLength: (emailValue, emailObj, intlFunc) =>\n      isMaxPropertyValid(\n        emailValue.length,\n        emailObj.maxLength,\n        'maxLength',\n        intlFunc,\n      ),\n  },\n  url: {\n    isValidURL: (urlValue, urlObj, intlFunc) => {\n      const urlRegex = /^(http:\\/\\/www\\.|https:\\/\\/www\\.|http:\\/\\/|https:\\/\\/)?[a-z0-9]+([-.]{1}[a-z0-9]+)*\\.[a-z]{2,5}(:[0-9]{1,5})?(\\/.*)?|^(http:\\/\\/www\\.|https:\\/\\/www\\.|http:\\/\\/|https:\\/\\/)?[a-z0-9]+([_.]{1}[a-z0-9]+)*\\.[a-z]{2,5}(:[0-9]{1,5})?(\\/.*)?|^((http:\\/\\/www\\.|https:\\/\\/www\\.|http:\\/\\/|https:\\/\\/)?([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$/gm;\n      const isValid = urlRegex.test(urlValue);\n      return !isValid ? intlFunc(messages.isValidURL) : null;\n    },\n    minLength: (urlValue, urlObj, intlFunc) =>\n      isMinPropertyValid(\n        urlValue.length,\n        urlObj.minLength,\n        'minLength',\n        intlFunc,\n      ),\n    maxLength: (urlValue, urlObj, intlFunc) =>\n      isMaxPropertyValid(\n        urlValue.length,\n        urlObj.maxLength,\n        'maxLength',\n        intlFunc,\n      ),\n  },\n  password: {\n    minLength: (passwordValue, passwordObj, intlFunc) =>\n      isMinPropertyValid(\n        passwordValue.length,\n        passwordObj.minLength,\n        'minLength',\n        intlFunc,\n      ),\n    maxLength: (passwordValue, passwordObj, intlFunc) =>\n      isMaxPropertyValid(\n        passwordValue.length,\n        passwordObj.maxLength,\n        'maxLength',\n        intlFunc,\n      ),\n  },\n  string: {\n    minLength: (value, itemObj, intlFunc) =>\n      isMinPropertyValid(\n        value.length,\n        itemObj.minLength,\n        'minLength',\n        intlFunc,\n      ),\n    maxLength: (value, itemObj, intlFunc) =>\n      isMaxPropertyValid(\n        value.length,\n        itemObj.maxLengthj,\n        'maxLength',\n        intlFunc,\n      ),\n  },\n  number: {\n    isNumber: (value, itemObj, intlFunc) => {\n      const floatRegex = /^[+-]?\\d+(\\.\\d+)?$/;\n      const isValid = !isNaN(value) && floatRegex.test(value);\n      return !isValid ? intlFunc(messages.isNumber) : null;\n    },\n    minimum: (value, itemObj, intlFunc) =>\n      isMinPropertyValid(value, itemObj.minimum, 'minimum', intlFunc),\n    maximum: (value, itemObj, intlFunc) =>\n      isMaxPropertyValid(value, itemObj.maximum, 'maximum', intlFunc),\n  },\n  integer: {\n    isInteger: (value, itemObj, intlFunc) => {\n      const intRegex = /^-?[0-9]+$/;\n      const isValid = !isNaN(value) && intRegex.test(value);\n      return !isValid ? intlFunc(messages.isInteger) : null;\n    },\n    minimum: (value, itemObj, intlFunc) =>\n      isMinPropertyValid(value, itemObj.minimum, 'minimum', intlFunc),\n    maximum: (value, itemObj, intlFunc) =>\n      isMaxPropertyValid(value, itemObj.maximum, 'maximum', intlFunc),\n  },\n};\n\n/**\n * The string that comes my not be a valid JSON\n * @param {string} requestItem\n */\nconst tryParseJSON = (requestItem) => {\n  let resultObj = null;\n  try {\n    resultObj = JSON.parse(requestItem);\n  } catch (e) {\n    try {\n      resultObj = JSON.parse(requestItem.replace(/'/g, '\"'));\n    } catch (e) {\n      resultObj = null;\n    }\n  }\n  return resultObj;\n};\n\n/**\n * Returns errors if obj has unique Items\n * @param {Object} field\n * @param {*} fieldData\n * @returns {Object[string]} - list of errors\n */\nconst hasUniqueItems = (field, fieldData, formatMessage) => {\n  const errors = [];\n  if (\n    field.uniqueItems &&\n    fieldData &&\n    uniq(fieldData).length !== fieldData.length\n  ) {\n    errors.push(formatMessage(messages.uniqueItems));\n  }\n  return errors;\n};\n\n/**\n * If required fields are undefined, return list of errors\n * @returns {Object[string]} - list of errors\n */\nconst validateRequiredFields = (\n  schema,\n  formData,\n  formatMessage,\n  touchedField,\n) => {\n  const errors = {};\n  const fields = isEmpty(touchedField)\n    ? schema.required\n    : intersection(schema.required, keys(touchedField));\n  map(fields, (requiredField) => {\n    const type = schema.properties[requiredField]?.type;\n    const widget = schema.properties[requiredField]?.widget;\n\n    let isEmpty = !formData[requiredField];\n    if (!isEmpty) {\n      if (type === 'array') {\n        isEmpty = formData[requiredField]\n          ? formData[requiredField].length === 0\n          : true;\n      } else if (type === 'string' && widget === 'richtext') {\n        isEmpty = !(\n          formData[requiredField]?.data?.replace(/(<([^>]+)>)/g, '').length > 0\n        );\n      }\n    }\n    if (\n      schema.properties[requiredField] &&\n      schema.properties[requiredField].type !== 'boolean' &&\n      !schema.properties[requiredField].readonly &&\n      isEmpty\n    ) {\n      const requiredFieldName =\n        schema.properties[requiredField].title || requiredField;\n      errors[requiredFieldName] = [];\n      errors[requiredFieldName].push(formatMessage(messages.required));\n    }\n  });\n\n  return errors;\n};\n/**\n * Return list of errors if field constraints are not respected\n * (ex min, max, maxLength, email format, url format etc)\n * each potential criterion has a validation process in widgetValidation\n * !!ONLY fields with data will be tested (those undefined are ignored here)\n * @returns {Object[string]} - list of errors\n */\nconst validateFieldsPerFieldset = (\n  schema,\n  formData,\n  formatMessage,\n  touchedField,\n) => {\n  const errors = validateRequiredFields(\n    schema,\n    formData,\n    formatMessage,\n    touchedField,\n  );\n\n  map(schema.properties, (field, fieldId) => {\n    const fieldWidgetType = field.widget || field.type;\n    const widgetValidationCriteria = widgetValidation[fieldWidgetType]\n      ? Object.keys(widgetValidation[fieldWidgetType])\n      : [];\n    let fieldData = formData[fieldId];\n    // test each criterion ex maximum, isEmail, isUrl, maxLength etc\n    const fieldErrors = widgetValidationCriteria\n      .map((widgetCriterion) => {\n        const errorMessage =\n          fieldData === undefined || fieldData === null\n            ? null\n            : widgetValidation[fieldWidgetType][widgetCriterion](\n                fieldData,\n                field,\n                formatMessage,\n              );\n        return errorMessage;\n      })\n      .filter((item) => !!item);\n\n    const uniqueErrors = hasUniqueItems(field, fieldData, formatMessage);\n    const mergedErrors = [...fieldErrors, ...uniqueErrors];\n\n    if (mergedErrors.length > 0) {\n      errors[fieldId] = [\n        ...(errors[fieldId] || []),\n        ...fieldErrors,\n        ...uniqueErrors,\n      ];\n    }\n  });\n\n  return errors;\n};\n\n/**\n * Create the errors object from backend the same way it is done on Frontend validation\n * @param {string} requestError form the server\n * @returns {Object}\n */\nconst giveServerErrorsToCorrespondingFields = (requestError) => {\n  let errorsList = tryParseJSON(requestError);\n  const errors = {};\n\n  if (Array.isArray(errorsList) && errorsList.length > 0) {\n    errorsList.forEach((errorItem) => {\n      errors[errorItem.field] = errors[errorItem.field]\n        ? errors[errorItem.field].push(errorItem.message)\n        : [errorItem.message];\n    });\n  }\n  return errors;\n};\n\n/**\n * The first Fieldset (Tab) that has any errors\n * will be selected\n * @param {Object[]} errors\n * @param {string} errors[].field\n * @param {Object} schema\n * @returns {number} activeIndex\n */\nconst getIndexOfFirstTabWithErrors = (errors, schema) => {\n  let activeIndex = 0;\n\n  schema.fieldsets.some((fieldSet, index) => {\n    let foundfield = fieldSet.fields.some((fieldId) => errors[fieldId]);\n\n    activeIndex = foundfield ? index : activeIndex;\n    return foundfield;\n  });\n\n  return activeIndex;\n};\n\nclass FormValidation {\n  /**\n   * The first Fieldset (Tab) that has any errors\n   * will be selected\n   * @param {Object} errors\n   * @param {Object} schema\n   * @returns {number} activeIndex\n   */\n  static showFirstTabWithErrors({\n    errors = {},\n    schema = { properties: {}, fieldsets: [], required: [] },\n  } = {}) {\n    return getIndexOfFirstTabWithErrors(errors, schema);\n  }\n  /**\n   * Create the errors object from backend the same way it is done on Frontend validation\n   * @param {string} requestError form the server\n   * @returns {Object}\n   */\n  static giveServerErrorsToCorrespondingFields(requestError = '') {\n    return giveServerErrorsToCorrespondingFields(requestError);\n  }\n  /**\n   * Return validation result\n   * @param {Object} schema\n   * @param {Object} formData\n   * @param {function} formatMessage\n   * @returns {Object} errors\n   */\n  static validateFieldsPerFieldset({\n    schema = { properties: {}, fieldsets: [], required: [] },\n    formData = {},\n    formatMessage = () => {},\n    touchedField = {},\n  } = {}) {\n    return validateFieldsPerFieldset(\n      schema,\n      formData,\n      formatMessage,\n      touchedField,\n    );\n  }\n}\n\nexport default FormValidation;\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module"}