{"ast":null,"code":"import _identity from \"lodash/identity\";\nimport _toPairs from \"lodash/toPairs\";\nimport _pickBy from \"lodash/pickBy\";\nimport _map from \"lodash/map\";\nimport _join from \"lodash/join\";\nimport _isArray from \"lodash/isArray\";\nimport _concat from \"lodash/concat\";\nimport _compact from \"lodash/compact\";\nimport { RESET_SEARCH_CONTENT, SEARCH_CONTENT } from '@plone/volto/constants/ActionTypes';\n/**\n * Search content function.\n * @function searchContent\n * @param {string} url Url to use as base.\n * @param {Object} options Search options.\n * @param {string} subrequest Key of the subrequest.\n * @returns {Object} Search content action.\n */\n\nexport function searchContent(url, options) {\n  let subrequest = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  let queryArray = [];\n  options = _pickBy(options, _identity);\n\n  const arrayOptions = _pickBy(options, item => _isArray(item));\n\n  queryArray = _concat(queryArray, options ? _join(_map(_toPairs(_pickBy(options, item => !_isArray(item))), item => {\n    if (item[0] === 'SearchableText') {\n      // Adds the wildcard to the SearchableText param\n      item[1] = `${item[1]}*`;\n    }\n\n    return _join(item, '=');\n  }), '&') : '');\n  queryArray = _concat(queryArray, arrayOptions ? _join(_map(_pickBy(arrayOptions), (item, key) => _join(item.map(value => `${key}:list=${value}`), '&')), '&') : '');\n\n  const querystring = _join(_compact(queryArray), '&');\n\n  return {\n    type: SEARCH_CONTENT,\n    subrequest,\n    request: {\n      op: 'get',\n      path: `${url}/@search${querystring ? `?${querystring}` : ''}`\n    }\n  };\n}\n/**\n * Reset search content function.\n * @function resetSearchContent\n * @param {string} subrequest Key of the subrequest.\n * @returns {Object} Search content action.\n */\n\nexport function resetSearchContent() {\n  let subrequest = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  return {\n    type: RESET_SEARCH_CONTENT,\n    subrequest\n  };\n}","map":{"version":3,"names":["RESET_SEARCH_CONTENT","SEARCH_CONTENT","searchContent","url","options","subrequest","queryArray","arrayOptions","item","key","map","value","querystring","type","request","op","path","resetSearchContent"],"sources":["/home/jakob/workspace/training-project/node_modules/@plone/volto/src/actions/search/search.js"],"sourcesContent":["/**\n * Search actions.\n * @module actions/search/search\n */\n\nimport {\n  compact,\n  concat,\n  isArray,\n  join,\n  map,\n  pickBy,\n  toPairs,\n  identity,\n} from 'lodash';\n\nimport {\n  RESET_SEARCH_CONTENT,\n  SEARCH_CONTENT,\n} from '@plone/volto/constants/ActionTypes';\n\n/**\n * Search content function.\n * @function searchContent\n * @param {string} url Url to use as base.\n * @param {Object} options Search options.\n * @param {string} subrequest Key of the subrequest.\n * @returns {Object} Search content action.\n */\nexport function searchContent(url, options, subrequest = null) {\n  let queryArray = [];\n  options = pickBy(options, identity);\n  const arrayOptions = pickBy(options, (item) => isArray(item));\n\n  queryArray = concat(\n    queryArray,\n    options\n      ? join(\n          map(toPairs(pickBy(options, (item) => !isArray(item))), (item) => {\n            if (item[0] === 'SearchableText') {\n              // Adds the wildcard to the SearchableText param\n              item[1] = `${item[1]}*`;\n            }\n            return join(item, '=');\n          }),\n          '&',\n        )\n      : '',\n  );\n\n  queryArray = concat(\n    queryArray,\n    arrayOptions\n      ? join(\n          map(pickBy(arrayOptions), (item, key) =>\n            join(\n              item.map((value) => `${key}:list=${value}`),\n              '&',\n            ),\n          ),\n          '&',\n        )\n      : '',\n  );\n\n  const querystring = join(compact(queryArray), '&');\n\n  return {\n    type: SEARCH_CONTENT,\n    subrequest,\n    request: {\n      op: 'get',\n      path: `${url}/@search${querystring ? `?${querystring}` : ''}`,\n    },\n  };\n}\n\n/**\n * Reset search content function.\n * @function resetSearchContent\n * @param {string} subrequest Key of the subrequest.\n * @returns {Object} Search content action.\n */\nexport function resetSearchContent(subrequest = null) {\n  return {\n    type: RESET_SEARCH_CONTENT,\n    subrequest,\n  };\n}\n"],"mappings":";;;;;;;;AAgBA,SACEA,oBADF,EAEEC,cAFF,QAGO,oCAHP;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,aAAT,CAAuBC,GAAvB,EAA4BC,OAA5B,EAAwD;EAAA,IAAnBC,UAAmB,uEAAN,IAAM;EAC7D,IAAIC,UAAU,GAAG,EAAjB;EACAF,OAAO,GAAG,QAAOA,OAAP,YAAV;;EACA,MAAMG,YAAY,GAAG,QAAOH,OAAP,EAAiBI,IAAD,IAAU,SAAQA,IAAR,CAA1B,CAArB;;EAEAF,UAAU,GAAG,QACXA,UADW,EAEXF,OAAO,GACH,MACE,KAAI,SAAQ,QAAOA,OAAP,EAAiBI,IAAD,IAAU,CAAC,SAAQA,IAAR,CAA3B,CAAR,CAAJ,EAAyDA,IAAD,IAAU;IAChE,IAAIA,IAAI,CAAC,CAAD,CAAJ,KAAY,gBAAhB,EAAkC;MAChC;MACAA,IAAI,CAAC,CAAD,CAAJ,GAAW,GAAEA,IAAI,CAAC,CAAD,CAAI,GAArB;IACD;;IACD,OAAO,MAAKA,IAAL,EAAW,GAAX,CAAP;EACD,CAND,CADF,EAQE,GARF,CADG,GAWH,EAbO,CAAb;EAgBAF,UAAU,GAAG,QACXA,UADW,EAEXC,YAAY,GACR,MACE,KAAI,QAAOA,YAAP,CAAJ,EAA0B,CAACC,IAAD,EAAOC,GAAP,KACxB,MACED,IAAI,CAACE,GAAL,CAAUC,KAAD,IAAY,GAAEF,GAAI,SAAQE,KAAM,EAAzC,CADF,EAEE,GAFF,CADF,CADF,EAOE,GAPF,CADQ,GAUR,EAZO,CAAb;;EAeA,MAAMC,WAAW,GAAG,MAAK,SAAQN,UAAR,CAAL,EAA0B,GAA1B,CAApB;;EAEA,OAAO;IACLO,IAAI,EAAEZ,cADD;IAELI,UAFK;IAGLS,OAAO,EAAE;MACPC,EAAE,EAAE,KADG;MAEPC,IAAI,EAAG,GAAEb,GAAI,WAAUS,WAAW,GAAI,IAAGA,WAAY,EAAnB,GAAuB,EAAG;IAFrD;EAHJ,CAAP;AAQD;AAED;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASK,kBAAT,GAA+C;EAAA,IAAnBZ,UAAmB,uEAAN,IAAM;EACpD,OAAO;IACLQ,IAAI,EAAEb,oBADD;IAELK;EAFK,CAAP;AAID"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module"}