{"ast":null,"code":"import { Text, Transforms, Element, Node } from 'slate'; // Editor,\n\nimport config from '@plone/volto/registry';\nexport const normalizeNode = editor => {\n  // enforce list rules (no block elements, only ol/ul/li as possible children\n  const {\n    normalizeNode\n  } = editor;\n  const {\n    slate\n  } = config.settings;\n  const validListElements = [...slate.listTypes, slate.listItemType];\n\n  editor.normalizeNode = entry => {\n    const [node, path] = entry;\n    const isTextNode = Text.isText(node);\n    const isInlineNode = editor.isInline(node);\n    const isElementNode = Element.isElement(node);\n    const isListTypeNode = slate.listTypes.includes(node.type); // delete childless ul/ol nodes\n\n    if (!isTextNode && isElementNode && !isInlineNode && isListTypeNode) {\n      if ((node.children || []).length === 0) {\n        Transforms.removeNodes(editor, {\n          at: path\n        });\n        return;\n      }\n    }\n\n    if (isElementNode && isListTypeNode) {\n      // lift all child nodes of ul/ol that are not ul/ol/li\n      for (const [child, childPath] of Node.children(editor, path)) {\n        if (!validListElements.includes(child.type) && !validListElements.includes(node.type)) {\n          Transforms.liftNodes(editor, {\n            at: childPath,\n            split: true\n          }); // Alternate strategy, need to investigate\n          // const newParent = { type: slate.defaultBlockType, children: [] };\n          // Transforms.wrapNodes(editor, newParent, { at: childPath });\n\n          return;\n        }\n      }\n    }\n\n    normalizeNode(entry);\n  };\n\n  return editor;\n};","map":{"version":3,"names":["Text","Transforms","Element","Node","config","normalizeNode","editor","slate","settings","validListElements","listTypes","listItemType","entry","node","path","isTextNode","isText","isInlineNode","isInline","isElementNode","isElement","isListTypeNode","includes","type","children","length","removeNodes","at","child","childPath","liftNodes","split"],"sources":["/home/jakob/workspace/training-project/node_modules/@plone/volto/packages/volto-slate/src/editor/extensions/normalizeNode.js"],"sourcesContent":["import { Text, Transforms, Element, Node } from 'slate'; // Editor,\nimport config from '@plone/volto/registry';\n\nexport const normalizeNode = (editor) => {\n  // enforce list rules (no block elements, only ol/ul/li as possible children\n  const { normalizeNode } = editor;\n  const { slate } = config.settings;\n\n  const validListElements = [...slate.listTypes, slate.listItemType];\n\n  editor.normalizeNode = (entry) => {\n    const [node, path] = entry;\n\n    const isTextNode = Text.isText(node);\n    const isInlineNode = editor.isInline(node);\n    const isElementNode = Element.isElement(node);\n    const isListTypeNode = slate.listTypes.includes(node.type);\n\n    // delete childless ul/ol nodes\n    if (!isTextNode && isElementNode && !isInlineNode && isListTypeNode) {\n      if ((node.children || []).length === 0) {\n        Transforms.removeNodes(editor, { at: path });\n        return;\n      }\n    }\n\n    if (isElementNode && isListTypeNode) {\n      // lift all child nodes of ul/ol that are not ul/ol/li\n      for (const [child, childPath] of Node.children(editor, path)) {\n        if (\n          !validListElements.includes(child.type) &&\n          !validListElements.includes(node.type)\n        ) {\n          Transforms.liftNodes(editor, { at: childPath, split: true });\n\n          // Alternate strategy, need to investigate\n          // const newParent = { type: slate.defaultBlockType, children: [] };\n          // Transforms.wrapNodes(editor, newParent, { at: childPath });\n          return;\n        }\n      }\n    }\n\n    normalizeNode(entry);\n  };\n\n  return editor;\n};\n"],"mappings":"AAAA,SAASA,IAAT,EAAeC,UAAf,EAA2BC,OAA3B,EAAoCC,IAApC,QAAgD,OAAhD,C,CAAyD;;AACzD,OAAOC,MAAP,MAAmB,uBAAnB;AAEA,OAAO,MAAMC,aAAa,GAAIC,MAAD,IAAY;EACvC;EACA,MAAM;IAAED;EAAF,IAAoBC,MAA1B;EACA,MAAM;IAAEC;EAAF,IAAYH,MAAM,CAACI,QAAzB;EAEA,MAAMC,iBAAiB,GAAG,CAAC,GAAGF,KAAK,CAACG,SAAV,EAAqBH,KAAK,CAACI,YAA3B,CAA1B;;EAEAL,MAAM,CAACD,aAAP,GAAwBO,KAAD,IAAW;IAChC,MAAM,CAACC,IAAD,EAAOC,IAAP,IAAeF,KAArB;IAEA,MAAMG,UAAU,GAAGf,IAAI,CAACgB,MAAL,CAAYH,IAAZ,CAAnB;IACA,MAAMI,YAAY,GAAGX,MAAM,CAACY,QAAP,CAAgBL,IAAhB,CAArB;IACA,MAAMM,aAAa,GAAGjB,OAAO,CAACkB,SAAR,CAAkBP,IAAlB,CAAtB;IACA,MAAMQ,cAAc,GAAGd,KAAK,CAACG,SAAN,CAAgBY,QAAhB,CAAyBT,IAAI,CAACU,IAA9B,CAAvB,CANgC,CAQhC;;IACA,IAAI,CAACR,UAAD,IAAeI,aAAf,IAAgC,CAACF,YAAjC,IAAiDI,cAArD,EAAqE;MACnE,IAAI,CAACR,IAAI,CAACW,QAAL,IAAiB,EAAlB,EAAsBC,MAAtB,KAAiC,CAArC,EAAwC;QACtCxB,UAAU,CAACyB,WAAX,CAAuBpB,MAAvB,EAA+B;UAAEqB,EAAE,EAAEb;QAAN,CAA/B;QACA;MACD;IACF;;IAED,IAAIK,aAAa,IAAIE,cAArB,EAAqC;MACnC;MACA,KAAK,MAAM,CAACO,KAAD,EAAQC,SAAR,CAAX,IAAiC1B,IAAI,CAACqB,QAAL,CAAclB,MAAd,EAAsBQ,IAAtB,CAAjC,EAA8D;QAC5D,IACE,CAACL,iBAAiB,CAACa,QAAlB,CAA2BM,KAAK,CAACL,IAAjC,CAAD,IACA,CAACd,iBAAiB,CAACa,QAAlB,CAA2BT,IAAI,CAACU,IAAhC,CAFH,EAGE;UACAtB,UAAU,CAAC6B,SAAX,CAAqBxB,MAArB,EAA6B;YAAEqB,EAAE,EAAEE,SAAN;YAAiBE,KAAK,EAAE;UAAxB,CAA7B,EADA,CAGA;UACA;UACA;;UACA;QACD;MACF;IACF;;IAED1B,aAAa,CAACO,KAAD,CAAb;EACD,CAlCD;;EAoCA,OAAON,MAAP;AACD,CA5CM"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module"}