{"ast":null,"code":"import _objectSpread from \"/home/jakob/workspace/training-project/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _omit from \"lodash/omit\";\nimport ReactDOM from 'react-dom';\nimport { v4 as uuid } from 'uuid';\nimport { addBlock, changeBlock, getBlocksFieldname, getBlocksLayoutFieldname } from '@plone/volto/helpers';\nimport { Transforms, Editor, Node, Text, Path } from 'slate';\nimport { serializeNodesToText } from '@plone/volto-slate/editor/render';\nimport config from '@plone/volto/registry';\n\nfunction fromEntries(pairs) {\n  const res = {};\n  pairs.forEach(p => {\n    res[p[0]] = p[1];\n  });\n  return res;\n} // TODO: should be made generic, no need for \"prevBlock.value\"\n\n\nexport function mergeSlateWithBlockBackward(editor, prevBlock, event) {\n  // To work around current architecture limitations, read the value from\n  // previous block. Replace it in the current editor (over which we have\n  // control), join with current block value, then use this result for previous\n  // block, delete current block\n  const prev = prevBlock.value; // collapse the selection to its start point\n\n  Transforms.collapse(editor, {\n    edge: 'start'\n  });\n  let rangeRef;\n  let end;\n  Editor.withoutNormalizing(editor, () => {\n    // insert block #0 contents in block #1 contents, at the beginning\n    Transforms.insertNodes(editor, prev, {\n      at: Editor.start(editor, [])\n    }); // the contents that should be moved into the `ul`, as the last `li`\n\n    rangeRef = Editor.rangeRef(editor, {\n      anchor: Editor.start(editor, [1]),\n      focus: Editor.end(editor, [1])\n    });\n    const source = rangeRef.current;\n    end = Editor.end(editor, [0]);\n    let endPoint;\n    Transforms.insertNodes(editor, {\n      text: ''\n    }, {\n      at: end\n    });\n    end = Editor.end(editor, [0]);\n    Transforms.splitNodes(editor, {\n      at: end,\n      always: true,\n      height: 1,\n      mode: 'highest',\n      match: n => n.type === 'li' || Text.isText(n)\n    });\n    endPoint = Editor.end(editor, [0]);\n    Transforms.moveNodes(editor, {\n      at: source,\n      to: endPoint.path,\n      mode: 'all',\n      match: (n, p) => p.length === 2\n    });\n  });\n  const [n] = Editor.node(editor, [1]);\n\n  if (Editor.isEmpty(editor, n)) {\n    Transforms.removeNodes(editor, {\n      at: [1]\n    });\n  }\n\n  rangeRef.unref();\n  const [, lastPath] = Editor.last(editor, [0]);\n  end = Editor.start(editor, Path.parent(lastPath));\n  return end;\n}\nexport function mergeSlateWithBlockForward(editor, nextBlock, event) {\n  // To work around current architecture limitations, read the value from next\n  // block. Replace it in the current editor (over which we have control), join\n  // with current block value, then use this result for next block, delete\n  // current block\n  const next = nextBlock.value; // collapse the selection to its start point\n\n  Transforms.collapse(editor, {\n    edge: 'end'\n  });\n  Transforms.insertNodes(editor, next, {\n    at: Editor.end(editor, [])\n  });\n  Editor.deleteForward(editor, {\n    unit: 'character'\n  });\n}\nexport function syncCreateSlateBlock(value) {\n  const id = uuid();\n  const block = {\n    '@type': 'slate',\n    value: JSON.parse(JSON.stringify(value)),\n    plaintext: serializeNodesToText(value)\n  };\n  return [id, block];\n}\nexport function createImageBlock(url, index, props) {\n  const {\n    properties,\n    onChangeField,\n    onSelectBlock\n  } = props;\n  const blocksFieldname = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n  const [id, formData] = addBlock(properties, 'image', index + 1);\n  const newFormData = changeBlock(formData, id, {\n    '@type': 'image',\n    url\n  });\n  ReactDOM.unstable_batchedUpdates(() => {\n    onChangeField(blocksFieldname, newFormData[blocksFieldname]);\n    onChangeField(blocksLayoutFieldname, newFormData[blocksLayoutFieldname]);\n    onSelectBlock(id);\n  });\n}\nexport const createAndSelectNewBlockAfter = (editor, blockValue) => {\n  const blockProps = editor.getBlockProps();\n  const {\n    onSelectBlock,\n    properties,\n    index,\n    onChangeField\n  } = blockProps;\n  const [blockId, formData] = addBlock(properties, 'slate', index + 1);\n  const options = {\n    '@type': 'slate',\n    value: JSON.parse(JSON.stringify(blockValue)),\n    plaintext: serializeNodesToText(blockValue)\n  };\n  const newFormData = changeBlock(formData, blockId, options);\n  const blocksFieldname = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties); // console.log('layout', blocksLayoutFieldname, newFormData);\n\n  ReactDOM.unstable_batchedUpdates(() => {\n    blockProps.saveSlateBlockSelection(blockId, 'start');\n    onChangeField(blocksFieldname, newFormData[blocksFieldname]);\n    onChangeField(blocksLayoutFieldname, newFormData[blocksLayoutFieldname]);\n    onSelectBlock(blockId);\n  });\n};\nexport function getNextVoltoBlock(index, properties) {\n  // TODO: look for any next slate block\n  // join this block with previous block, if previous block is slate\n  const blocksFieldname = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n  const blocks_layout = properties[blocksLayoutFieldname];\n  if (index === blocks_layout.items.length) return;\n  const nextBlockId = blocks_layout.items[index + 1];\n  const nextBlock = properties[blocksFieldname][nextBlockId];\n  return [nextBlock, nextBlockId];\n}\nexport function getPreviousVoltoBlock(index, properties) {\n  // TODO: look for any prev slate block\n  if (index === 0) return;\n  const blocksFieldname = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n  const blocks_layout = properties[blocksLayoutFieldname];\n  const prevBlockId = blocks_layout.items[index - 1];\n  const prevBlock = properties[blocksFieldname][prevBlockId];\n  return [prevBlock, prevBlockId];\n} // //check for existing img children\n// const checkContainImg = (elements) => {\n//   var check = false;\n//   elements.forEach((e) =>\n//     e.children.forEach((c) => {\n//       if (c && c.type && c.type === 'img') {\n//         check = true;\n//       }\n//     }),\n//   );\n//   return check;\n// };\n// //check for existing table children\n// const checkContainTable = (elements) => {\n//   var check = false;\n//   elements.forEach((e) => {\n//     if (e && e.type && e.type === 'table') {\n//       check = true;\n//     }\n//   });\n//   return check;\n// };\n\n/**\n * The editor has the properties `dataTransferHandlers` (object) and\n * `dataTransferFormatsOrder` and in `dataTransferHandlers` are functions which\n * sometimes must call this function. Some types of data storeable in Slate\n * documents can be and should be put into separate Volto blocks. The\n * `deconstructToVoltoBlocks` function scans the contents of the Slate document\n * and, through configured Volto block emitters, it outputs separate Volto\n * blocks into the same Volto page form. The `deconstructToVoltoBlocks` function\n * should be called only in key places where it is necessary.\n *\n * @example See the `src/editor/extensions/insertData.js` file.\n *\n * @param {Editor} editor The Slate editor object which should be deconstructed\n * if possible.\n *\n * @returns {Promise}\n */\n\nexport function deconstructToVoltoBlocks(editor) {\n  // Explodes editor content into separate blocks\n  // If the editor has multiple top-level children, split the current block\n  // into multiple slate blocks. This will delete and replace the current\n  // block.\n  //\n  // It returns a promise that, when resolved, will pass a list of Volto block\n  // ids that were affected\n  //\n  // For the Volto blocks manipulation we do low-level changes to the context\n  // form state, as that ensures a better performance (no un-needed UI updates)\n  if (!editor.getBlockProps) return;\n  const blockProps = editor.getBlockProps();\n  const {\n    slate\n  } = config.settings;\n  const {\n    voltoBlockEmiters\n  } = slate;\n  return new Promise((resolve, reject) => {\n    if (!(editor !== null && editor !== void 0 && editor.children)) return;\n\n    if (editor.children.length === 1) {\n      return resolve([blockProps.block]);\n    }\n\n    const {\n      properties,\n      onChangeField,\n      onSelectBlock\n    } = editor.getBlockProps();\n    const blocksFieldname = getBlocksFieldname(properties);\n    const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n    const {\n      index\n    } = blockProps;\n    let blocks = []; // TODO: should use Editor.levels() instead of Node.children\n\n    const pathRefs = Array.from(Node.children(editor, [])).map(_ref => {\n      let [, path] = _ref;\n      return Editor.pathRef(editor, path);\n    });\n\n    for (const pathRef of pathRefs) {\n      // extra nodes are always extracted after the text node\n      let extras = voltoBlockEmiters.map(emit => emit(editor, pathRef)).flat(1); // The node might have been replaced with a Volto block\n\n      if (pathRef.current) {\n        const [childNode] = Editor.node(editor, pathRef.current);\n        if (childNode && !Editor.isEmpty(editor, childNode)) blocks.push(syncCreateSlateBlock([childNode]));\n      }\n\n      blocks = [...blocks, ...extras];\n    }\n\n    const blockids = blocks.map(b => b[0]); // TODO: add the placeholder block, because we remove it\n    // (when we remove the current block)\n\n    const blocksData = _omit(_objectSpread(_objectSpread({}, properties[blocksFieldname]), fromEntries(blocks)), blockProps.block);\n\n    const layoutData = _objectSpread(_objectSpread({}, properties[blocksLayoutFieldname]), {}, {\n      items: [...properties[blocksLayoutFieldname].items.slice(0, index), ...blockids, ...properties[blocksLayoutFieldname].items.slice(index)].filter(id => id !== blockProps.block)\n    }); // TODO: use onChangeFormData instead of this API style\n\n\n    ReactDOM.unstable_batchedUpdates(() => {\n      onChangeField(blocksFieldname, blocksData);\n      onChangeField(blocksLayoutFieldname, layoutData);\n      onSelectBlock(blockids[blockids.length - 1]); // resolve(blockids);\n      // or rather this?\n\n      Promise.resolve().then(resolve(blockids));\n    });\n  });\n}","map":{"version":3,"names":["ReactDOM","v4","uuid","addBlock","changeBlock","getBlocksFieldname","getBlocksLayoutFieldname","Transforms","Editor","Node","Text","Path","serializeNodesToText","config","fromEntries","pairs","res","forEach","p","mergeSlateWithBlockBackward","editor","prevBlock","event","prev","value","collapse","edge","rangeRef","end","withoutNormalizing","insertNodes","at","start","anchor","focus","source","current","endPoint","text","splitNodes","always","height","mode","match","n","type","isText","moveNodes","to","path","length","node","isEmpty","removeNodes","unref","lastPath","last","parent","mergeSlateWithBlockForward","nextBlock","next","deleteForward","unit","syncCreateSlateBlock","id","block","JSON","parse","stringify","plaintext","createImageBlock","url","index","props","properties","onChangeField","onSelectBlock","blocksFieldname","blocksLayoutFieldname","formData","newFormData","unstable_batchedUpdates","createAndSelectNewBlockAfter","blockValue","blockProps","getBlockProps","blockId","options","saveSlateBlockSelection","getNextVoltoBlock","blocks_layout","items","nextBlockId","getPreviousVoltoBlock","prevBlockId","deconstructToVoltoBlocks","slate","settings","voltoBlockEmiters","Promise","resolve","reject","children","blocks","pathRefs","Array","from","map","pathRef","extras","emit","flat","childNode","push","blockids","b","blocksData","layoutData","slice","filter","then"],"sources":["/home/jakob/workspace/training-project/node_modules/@plone/volto/packages/volto-slate/src/utils/volto-blocks.js"],"sourcesContent":["import ReactDOM from 'react-dom';\nimport { v4 as uuid } from 'uuid';\nimport {\n  addBlock,\n  changeBlock,\n  getBlocksFieldname,\n  getBlocksLayoutFieldname,\n} from '@plone/volto/helpers';\nimport { Transforms, Editor, Node, Text, Path } from 'slate';\nimport { serializeNodesToText } from '@plone/volto-slate/editor/render';\nimport { omit } from 'lodash';\nimport config from '@plone/volto/registry';\n\nfunction fromEntries(pairs) {\n  const res = {};\n  pairs.forEach((p) => {\n    res[p[0]] = p[1];\n  });\n  return res;\n}\n\n// TODO: should be made generic, no need for \"prevBlock.value\"\nexport function mergeSlateWithBlockBackward(editor, prevBlock, event) {\n  // To work around current architecture limitations, read the value from\n  // previous block. Replace it in the current editor (over which we have\n  // control), join with current block value, then use this result for previous\n  // block, delete current block\n\n  const prev = prevBlock.value;\n\n  // collapse the selection to its start point\n  Transforms.collapse(editor, { edge: 'start' });\n\n  let rangeRef;\n  let end;\n\n  Editor.withoutNormalizing(editor, () => {\n    // insert block #0 contents in block #1 contents, at the beginning\n    Transforms.insertNodes(editor, prev, {\n      at: Editor.start(editor, []),\n    });\n\n    // the contents that should be moved into the `ul`, as the last `li`\n    rangeRef = Editor.rangeRef(editor, {\n      anchor: Editor.start(editor, [1]),\n      focus: Editor.end(editor, [1]),\n    });\n\n    const source = rangeRef.current;\n\n    end = Editor.end(editor, [0]);\n\n    let endPoint;\n\n    Transforms.insertNodes(editor, { text: '' }, { at: end });\n\n    end = Editor.end(editor, [0]);\n\n    Transforms.splitNodes(editor, {\n      at: end,\n      always: true,\n      height: 1,\n      mode: 'highest',\n      match: (n) => n.type === 'li' || Text.isText(n),\n    });\n\n    endPoint = Editor.end(editor, [0]);\n\n    Transforms.moveNodes(editor, {\n      at: source,\n      to: endPoint.path,\n      mode: 'all',\n      match: (n, p) => p.length === 2,\n    });\n  });\n\n  const [n] = Editor.node(editor, [1]);\n\n  if (Editor.isEmpty(editor, n)) {\n    Transforms.removeNodes(editor, { at: [1] });\n  }\n\n  rangeRef.unref();\n\n  const [, lastPath] = Editor.last(editor, [0]);\n\n  end = Editor.start(editor, Path.parent(lastPath));\n\n  return end;\n}\n\nexport function mergeSlateWithBlockForward(editor, nextBlock, event) {\n  // To work around current architecture limitations, read the value from next\n  // block. Replace it in the current editor (over which we have control), join\n  // with current block value, then use this result for next block, delete\n  // current block\n\n  const next = nextBlock.value;\n\n  // collapse the selection to its start point\n  Transforms.collapse(editor, { edge: 'end' });\n  Transforms.insertNodes(editor, next, {\n    at: Editor.end(editor, []),\n  });\n\n  Editor.deleteForward(editor, { unit: 'character' });\n}\n\nexport function syncCreateSlateBlock(value) {\n  const id = uuid();\n  const block = {\n    '@type': 'slate',\n    value: JSON.parse(JSON.stringify(value)),\n    plaintext: serializeNodesToText(value),\n  };\n  return [id, block];\n}\n\nexport function createImageBlock(url, index, props) {\n  const { properties, onChangeField, onSelectBlock } = props;\n  const blocksFieldname = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n\n  const [id, formData] = addBlock(properties, 'image', index + 1);\n  const newFormData = changeBlock(formData, id, { '@type': 'image', url });\n\n  ReactDOM.unstable_batchedUpdates(() => {\n    onChangeField(blocksFieldname, newFormData[blocksFieldname]);\n    onChangeField(blocksLayoutFieldname, newFormData[blocksLayoutFieldname]);\n    onSelectBlock(id);\n  });\n}\n\nexport const createAndSelectNewBlockAfter = (editor, blockValue) => {\n  const blockProps = editor.getBlockProps();\n\n  const { onSelectBlock, properties, index, onChangeField } = blockProps;\n\n  const [blockId, formData] = addBlock(properties, 'slate', index + 1);\n\n  const options = {\n    '@type': 'slate',\n    value: JSON.parse(JSON.stringify(blockValue)),\n    plaintext: serializeNodesToText(blockValue),\n  };\n\n  const newFormData = changeBlock(formData, blockId, options);\n\n  const blocksFieldname = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n  // console.log('layout', blocksLayoutFieldname, newFormData);\n\n  ReactDOM.unstable_batchedUpdates(() => {\n    blockProps.saveSlateBlockSelection(blockId, 'start');\n    onChangeField(blocksFieldname, newFormData[blocksFieldname]);\n    onChangeField(blocksLayoutFieldname, newFormData[blocksLayoutFieldname]);\n    onSelectBlock(blockId);\n  });\n};\n\nexport function getNextVoltoBlock(index, properties) {\n  // TODO: look for any next slate block\n  // join this block with previous block, if previous block is slate\n  const blocksFieldname = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n\n  const blocks_layout = properties[blocksLayoutFieldname];\n\n  if (index === blocks_layout.items.length) return;\n\n  const nextBlockId = blocks_layout.items[index + 1];\n  const nextBlock = properties[blocksFieldname][nextBlockId];\n\n  return [nextBlock, nextBlockId];\n}\n\nexport function getPreviousVoltoBlock(index, properties) {\n  // TODO: look for any prev slate block\n  if (index === 0) return;\n\n  const blocksFieldname = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n\n  const blocks_layout = properties[blocksLayoutFieldname];\n  const prevBlockId = blocks_layout.items[index - 1];\n  const prevBlock = properties[blocksFieldname][prevBlockId];\n\n  return [prevBlock, prevBlockId];\n}\n\n// //check for existing img children\n// const checkContainImg = (elements) => {\n//   var check = false;\n//   elements.forEach((e) =>\n//     e.children.forEach((c) => {\n//       if (c && c.type && c.type === 'img') {\n//         check = true;\n//       }\n//     }),\n//   );\n//   return check;\n// };\n\n// //check for existing table children\n// const checkContainTable = (elements) => {\n//   var check = false;\n//   elements.forEach((e) => {\n//     if (e && e.type && e.type === 'table') {\n//       check = true;\n//     }\n//   });\n//   return check;\n// };\n\n/**\n * The editor has the properties `dataTransferHandlers` (object) and\n * `dataTransferFormatsOrder` and in `dataTransferHandlers` are functions which\n * sometimes must call this function. Some types of data storeable in Slate\n * documents can be and should be put into separate Volto blocks. The\n * `deconstructToVoltoBlocks` function scans the contents of the Slate document\n * and, through configured Volto block emitters, it outputs separate Volto\n * blocks into the same Volto page form. The `deconstructToVoltoBlocks` function\n * should be called only in key places where it is necessary.\n *\n * @example See the `src/editor/extensions/insertData.js` file.\n *\n * @param {Editor} editor The Slate editor object which should be deconstructed\n * if possible.\n *\n * @returns {Promise}\n */\nexport function deconstructToVoltoBlocks(editor) {\n  // Explodes editor content into separate blocks\n  // If the editor has multiple top-level children, split the current block\n  // into multiple slate blocks. This will delete and replace the current\n  // block.\n  //\n  // It returns a promise that, when resolved, will pass a list of Volto block\n  // ids that were affected\n  //\n  // For the Volto blocks manipulation we do low-level changes to the context\n  // form state, as that ensures a better performance (no un-needed UI updates)\n\n  if (!editor.getBlockProps) return;\n\n  const blockProps = editor.getBlockProps();\n  const { slate } = config.settings;\n  const { voltoBlockEmiters } = slate;\n\n  return new Promise((resolve, reject) => {\n    if (!editor?.children) return;\n\n    if (editor.children.length === 1) {\n      return resolve([blockProps.block]);\n    }\n    const { properties, onChangeField, onSelectBlock } = editor.getBlockProps();\n    const blocksFieldname = getBlocksFieldname(properties);\n    const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n\n    const { index } = blockProps;\n    let blocks = [];\n\n    // TODO: should use Editor.levels() instead of Node.children\n    const pathRefs = Array.from(Node.children(editor, [])).map(([, path]) =>\n      Editor.pathRef(editor, path),\n    );\n\n    for (const pathRef of pathRefs) {\n      // extra nodes are always extracted after the text node\n      let extras = voltoBlockEmiters\n        .map((emit) => emit(editor, pathRef))\n        .flat(1);\n\n      // The node might have been replaced with a Volto block\n      if (pathRef.current) {\n        const [childNode] = Editor.node(editor, pathRef.current);\n        if (childNode && !Editor.isEmpty(editor, childNode))\n          blocks.push(syncCreateSlateBlock([childNode]));\n      }\n      blocks = [...blocks, ...extras];\n    }\n\n    const blockids = blocks.map((b) => b[0]);\n\n    // TODO: add the placeholder block, because we remove it\n    // (when we remove the current block)\n\n    const blocksData = omit(\n      {\n        ...properties[blocksFieldname],\n        ...fromEntries(blocks),\n      },\n      blockProps.block,\n    );\n    const layoutData = {\n      ...properties[blocksLayoutFieldname],\n      items: [\n        ...properties[blocksLayoutFieldname].items.slice(0, index),\n        ...blockids,\n        ...properties[blocksLayoutFieldname].items.slice(index),\n      ].filter((id) => id !== blockProps.block),\n    };\n\n    // TODO: use onChangeFormData instead of this API style\n    ReactDOM.unstable_batchedUpdates(() => {\n      onChangeField(blocksFieldname, blocksData);\n      onChangeField(blocksLayoutFieldname, layoutData);\n      onSelectBlock(blockids[blockids.length - 1]);\n      // resolve(blockids);\n      // or rather this?\n      Promise.resolve().then(resolve(blockids));\n    });\n  });\n}\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module"}