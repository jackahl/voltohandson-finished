{"ast":null,"code":"var _jsxFileName = \"/home/jakob/workspace/training-project/node_modules/@plone/volto/src/components/manage/Blocks/Search/hocs/withSearch.jsx\";\nvar __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React from 'react';\nimport { useSelector } from 'react-redux';\nimport qs from 'query-string';\nimport { useLocation, useHistory } from 'react-router-dom';\nimport { resolveExtension } from '@plone/volto/helpers/Extensions/withBlockExtensions';\nimport config from '@plone/volto/registry';\n\nfunction getDisplayName(WrappedComponent) {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\nconst SEARCH_ENDPOINT_FIELDS = ['SearchableText', 'b_size', 'limit', 'sort_on', 'sort_order'];\nconst PAQO = 'plone.app.querystring.operation';\n/**\n * Based on URL state, gets an initial internal state for the search\n *\n * @function getInitialState\n *\n */\n\nfunction getInitialState(data, facets, urlSearchText, id) {\n  var _data$query, _data$query2, _data$query3, _data$query4, _data$query5;\n\n  const {\n    types: facetWidgetTypes\n  } = config.blocks.blocksConfig.search.extensions.facetWidgets;\n  const facetSettings = (data === null || data === void 0 ? void 0 : data.facets) || [];\n  return {\n    query: [...(((_data$query = data.query) === null || _data$query === void 0 ? void 0 : _data$query.query) || []), ...(facetSettings || []).map(facet => {\n      if (!(facet !== null && facet !== void 0 && facet.field)) return null;\n      const {\n        valueToQuery\n      } = resolveExtension('type', facetWidgetTypes, facet);\n      const name = facet.field.value;\n      const value = facets[name];\n      return valueToQuery({\n        value,\n        facet\n      });\n    }).filter(f => !!f), ...(urlSearchText ? [{\n      i: 'SearchableText',\n      o: 'plone.app.querystring.operation.string.contains',\n      v: urlSearchText\n    }] : [])],\n    sort_on: (_data$query2 = data.query) === null || _data$query2 === void 0 ? void 0 : _data$query2.sort_on,\n    sort_order: (_data$query3 = data.query) === null || _data$query3 === void 0 ? void 0 : _data$query3.sort_order,\n    b_size: (_data$query4 = data.query) === null || _data$query4 === void 0 ? void 0 : _data$query4.b_size,\n    limit: (_data$query5 = data.query) === null || _data$query5 === void 0 ? void 0 : _data$query5.limit,\n    block: id\n  };\n}\n/**\n * \"Normalizes\" the search state to something that's serializable\n * (for querying) and used to compute data for the ListingBody\n *\n * @function normalizeState\n *\n */\n\n\nfunction normalizeState({\n  query,\n  // base query\n  facets,\n  // facet values\n  id,\n  // block id\n  searchText,\n  // SearchableText\n  sortOn,\n  sortOrder,\n  facetSettings // data.facets extracted from block data\n\n}) {\n  const {\n    types: facetWidgetTypes\n  } = config.blocks.blocksConfig.search.extensions.facetWidgets;\n  const params = {\n    query: [...(query.query || []), ...(facetSettings || []).map(facet => {\n      if (!(facet !== null && facet !== void 0 && facet.field)) return null;\n      const {\n        valueToQuery\n      } = resolveExtension('type', facetWidgetTypes, facet);\n      const name = facet.field.value;\n      const value = facets[name];\n      return valueToQuery({\n        value,\n        facet\n      });\n    })].filter(o => !!o),\n    sort_on: sortOn || query.sort_on,\n    sort_order: sortOrder || query.sort_order,\n    b_size: query.b_size,\n    limit: query.limit,\n    block: id\n  }; // TODO: need to check if SearchableText facet is not already in the query\n  // Ideally the searchtext functionality should be restructured as being just\n  // another facet\n\n  params.query = params.query.reduce( // Remove SearchableText from query\n  (acc, kvp) => kvp.i === 'SearchableText' ? acc : [...acc, kvp], []);\n\n  if (searchText) {\n    params.query.push({\n      i: 'SearchableText',\n      o: 'plone.app.querystring.operation.string.contains',\n      v: searchText\n    });\n  }\n\n  return params;\n}\n\nconst getSearchFields = searchData => {\n  return Object.assign({}, ...SEARCH_ENDPOINT_FIELDS.map(k => {\n    return searchData[k] ? {\n      [k]: searchData[k]\n    } : {};\n  }), searchData.query ? {\n    query: serializeQuery(searchData['query'])\n  } : {});\n};\n/**\n * A HOC that will mirror the search block state to a hash location\n */\n\n\nconst useHashState = () => {\n  const location = useLocation();\n  const history = useHistory();\n  const oldState = React.useMemo(() => {\n    return _objectSpread(_objectSpread({}, qs.parse(location.search)), qs.parse(location.hash));\n  }, [location.hash, location.search]); // This creates a shallow copy. Why is this needed?\n\n  const current = Object.assign({}, ...Array.from(Object.keys(oldState)).map(k => ({\n    [k]: oldState[k]\n  })));\n  const setSearchData = React.useCallback(searchData => {\n    const newParams = qs.parse(location.hash);\n    let changed = false;\n    Object.keys(searchData).sort().forEach(k => {\n      if (searchData[k]) {\n        newParams[k] = searchData[k];\n\n        if (oldState[k] !== searchData[k]) {\n          changed = true;\n        }\n      }\n    });\n\n    if (changed) {\n      history.push({\n        hash: qs.stringify(newParams)\n      });\n    }\n  }, [history, oldState, location.hash]);\n  return [current, setSearchData];\n};\n/**\n * A hook to make it possible to switch disable mirroring the search block\n * state to the window location. When using the internal state we \"start from\n * scratch\", as it's intended to be used in the edit page.\n */\n\n\nconst useSearchBlockState = (uniqueId, isEditMode) => {\n  const [hashState, setHashState] = useHashState();\n  const [internalState, setInternalState] = React.useState({});\n  return isEditMode ? [internalState, setInternalState] : [hashState, setHashState];\n}; // Simple compress/decompress the state in URL by replacing the lengthy string\n\n\nconst deserializeQuery = q => {\n  var _JSON$parse;\n\n  return (_JSON$parse = JSON.parse(q)) === null || _JSON$parse === void 0 ? void 0 : _JSON$parse.map(kvp => _objectSpread(_objectSpread({}, kvp), {}, {\n    o: kvp.o.replace(/^paqo/, PAQO)\n  }));\n};\n\nconst serializeQuery = q => {\n  return JSON.stringify(q === null || q === void 0 ? void 0 : q.map(kvp => _objectSpread(_objectSpread({}, kvp), {}, {\n    o: kvp.o.replace(PAQO, 'paqo')\n  })));\n};\n\nconst withSearch = options => WrappedComponent => {\n  const {\n    inputDelay = 1000\n  } = options || {};\n\n  function WithSearch(props) {\n    var _urlQuery$find, _data$facets, _data$facets2, _data$query6, _data$query7, _querystringResults$i, _querystringResults$i2, _querystringResults$i3;\n\n    const {\n      data,\n      id,\n      editable = false\n    } = props;\n    const [locationSearchData, setLocationSearchData] = useSearchBlockState(id, editable);\n    const urlQuery = locationSearchData.query ? deserializeQuery(locationSearchData.query) : [];\n    const urlSearchText = locationSearchData.SearchableText || ((_urlQuery$find = urlQuery.find(({\n      i\n    }) => i === 'SearchableText')) === null || _urlQuery$find === void 0 ? void 0 : _urlQuery$find.v) || ''; // TODO: refactor, should use only useLocationStateManager()!!!\n\n    const [searchText, setSearchText] = React.useState(urlSearchText);\n    const configuredFacets = ((_data$facets = data.facets) === null || _data$facets === void 0 ? void 0 : _data$facets.map(facet => {\n      var _facet$field;\n\n      return facet === null || facet === void 0 ? void 0 : (_facet$field = facet.field) === null || _facet$field === void 0 ? void 0 : _facet$field.value;\n    })) || [];\n    const multiFacets = (_data$facets2 = data.facets) === null || _data$facets2 === void 0 ? void 0 : _data$facets2.filter(facet => facet === null || facet === void 0 ? void 0 : facet.multiple).map(facet => {\n      var _facet$field2;\n\n      return facet === null || facet === void 0 ? void 0 : (_facet$field2 = facet.field) === null || _facet$field2 === void 0 ? void 0 : _facet$field2.value;\n    });\n    const [facets, setFacets] = React.useState(Object.assign({}, ...urlQuery.map(({\n      i,\n      v\n    }) => ({\n      [i]: v\n    })), // TODO: the 'o' should be kept. This would be a major refactoring of the facets\n    // support for simple filters like ?Subject=something\n    // TODO: since the move to hash params this is no longer working.\n    // We'd have to treat the location.search and manage it just like the\n    // hash, to support it. We can read it, but we'd have to reset it as\n    // well, so at that point what's the difference to the hash?\n    ...configuredFacets.map(f => locationSearchData[f] ? {\n      [f]: multiFacets.indexOf(f) > -1 ? [locationSearchData[f]] : locationSearchData[f]\n    } : {})));\n    const [sortOn, setSortOn] = React.useState(data === null || data === void 0 ? void 0 : (_data$query6 = data.query) === null || _data$query6 === void 0 ? void 0 : _data$query6.sort_on);\n    const [sortOrder, setSortOrder] = React.useState(data === null || data === void 0 ? void 0 : (_data$query7 = data.query) === null || _data$query7 === void 0 ? void 0 : _data$query7.sort_order);\n    const [searchData, setSearchData] = React.useState(getInitialState(data, facets, urlSearchText, id));\n    const timeoutRef = React.useRef();\n    const facetSettings = data === null || data === void 0 ? void 0 : data.facets;\n    const onTriggerSearch = React.useCallback((toSearchText, toSearchFacets, toSortOn, toSortOrder) => {\n      if (timeoutRef.current) clearTimeout(timeoutRef.current);\n      timeoutRef.current = setTimeout(() => {\n        const searchData = normalizeState({\n          id,\n          query: data.query || {},\n          facets: toSearchFacets || facets,\n          searchText: toSearchText,\n          sortOn: toSortOn || sortOn,\n          sortOrder: toSortOrder || sortOrder,\n          facetSettings\n        });\n        if (toSearchFacets) setFacets(toSearchFacets);\n        if (toSortOn) setSortOn(toSortOn);\n        if (toSortOrder) setSortOrder(toSortOrder);\n        setSearchData(searchData);\n        setLocationSearchData(getSearchFields(searchData));\n      }, toSearchFacets ? inputDelay / 3 : inputDelay);\n    }, [data.query, facets, id, setLocationSearchData, sortOn, sortOrder, facetSettings]);\n    const querystringResults = useSelector(state => state.querystringsearch.subrequests);\n    const totalItems = ((_querystringResults$i = querystringResults[id]) === null || _querystringResults$i === void 0 ? void 0 : _querystringResults$i.total) || ((_querystringResults$i2 = querystringResults[id]) === null || _querystringResults$i2 === void 0 ? void 0 : (_querystringResults$i3 = _querystringResults$i2.items) === null || _querystringResults$i3 === void 0 ? void 0 : _querystringResults$i3.length);\n    return __jsx(WrappedComponent, _extends({}, props, {\n      searchData: searchData,\n      facets: facets,\n      setFacets: setFacets,\n      setSortOn: setSortOn,\n      setSortOrder: setSortOrder,\n      sortOn: sortOn,\n      sortOrder: sortOrder,\n      searchedText: urlSearchText,\n      searchText: searchText,\n      setSearchText: setSearchText,\n      onTriggerSearch: onTriggerSearch,\n      totalItems: totalItems,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 322,\n        columnNumber: 7\n      }\n    }));\n  }\n\n  WithSearch.displayName = `WithSearch(${getDisplayName(WrappedComponent)})`;\n  return WithSearch;\n};\n\nexport default withSearch;","map":{"version":3,"names":["React","useSelector","qs","useLocation","useHistory","resolveExtension","config","getDisplayName","WrappedComponent","displayName","name","SEARCH_ENDPOINT_FIELDS","PAQO","getInitialState","data","facets","urlSearchText","id","types","facetWidgetTypes","blocks","blocksConfig","search","extensions","facetWidgets","facetSettings","query","map","facet","field","valueToQuery","value","filter","f","i","o","v","sort_on","sort_order","b_size","limit","block","normalizeState","searchText","sortOn","sortOrder","params","reduce","acc","kvp","push","getSearchFields","searchData","Object","assign","k","serializeQuery","useHashState","location","history","oldState","useMemo","parse","hash","current","Array","from","keys","setSearchData","useCallback","newParams","changed","sort","forEach","stringify","useSearchBlockState","uniqueId","isEditMode","hashState","setHashState","internalState","setInternalState","useState","deserializeQuery","q","JSON","replace","withSearch","options","inputDelay","WithSearch","props","editable","locationSearchData","setLocationSearchData","urlQuery","SearchableText","find","setSearchText","configuredFacets","multiFacets","multiple","setFacets","indexOf","setSortOn","setSortOrder","timeoutRef","useRef","onTriggerSearch","toSearchText","toSearchFacets","toSortOn","toSortOrder","clearTimeout","setTimeout","querystringResults","state","querystringsearch","subrequests","totalItems","total","items","length"],"sources":["/home/jakob/workspace/training-project/node_modules/@plone/volto/src/components/manage/Blocks/Search/hocs/withSearch.jsx"],"sourcesContent":["import React from 'react';\nimport { useSelector } from 'react-redux';\nimport qs from 'query-string';\nimport { useLocation, useHistory } from 'react-router-dom';\n\nimport { resolveExtension } from '@plone/volto/helpers/Extensions/withBlockExtensions';\nimport config from '@plone/volto/registry';\n\nfunction getDisplayName(WrappedComponent) {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\nconst SEARCH_ENDPOINT_FIELDS = [\n  'SearchableText',\n  'b_size',\n  'limit',\n  'sort_on',\n  'sort_order',\n];\n\nconst PAQO = 'plone.app.querystring.operation';\n\n/**\n * Based on URL state, gets an initial internal state for the search\n *\n * @function getInitialState\n *\n */\nfunction getInitialState(data, facets, urlSearchText, id) {\n  const {\n    types: facetWidgetTypes,\n  } = config.blocks.blocksConfig.search.extensions.facetWidgets;\n  const facetSettings = data?.facets || [];\n\n  return {\n    query: [\n      ...(data.query?.query || []),\n      ...(facetSettings || [])\n        .map((facet) => {\n          if (!facet?.field) return null;\n\n          const { valueToQuery } = resolveExtension(\n            'type',\n            facetWidgetTypes,\n            facet,\n          );\n\n          const name = facet.field.value;\n          const value = facets[name];\n\n          return valueToQuery({ value, facet });\n        })\n        .filter((f) => !!f),\n      ...(urlSearchText\n        ? [\n            {\n              i: 'SearchableText',\n              o: 'plone.app.querystring.operation.string.contains',\n              v: urlSearchText,\n            },\n          ]\n        : []),\n    ],\n    sort_on: data.query?.sort_on,\n    sort_order: data.query?.sort_order,\n    b_size: data.query?.b_size,\n    limit: data.query?.limit,\n    block: id,\n  };\n}\n\n/**\n * \"Normalizes\" the search state to something that's serializable\n * (for querying) and used to compute data for the ListingBody\n *\n * @function normalizeState\n *\n */\nfunction normalizeState({\n  query, // base query\n  facets, // facet values\n  id, // block id\n  searchText, // SearchableText\n  sortOn,\n  sortOrder,\n  facetSettings, // data.facets extracted from block data\n}) {\n  const {\n    types: facetWidgetTypes,\n  } = config.blocks.blocksConfig.search.extensions.facetWidgets;\n\n  const params = {\n    query: [\n      ...(query.query || []),\n      ...(facetSettings || []).map((facet) => {\n        if (!facet?.field) return null;\n\n        const { valueToQuery } = resolveExtension(\n          'type',\n          facetWidgetTypes,\n          facet,\n        );\n\n        const name = facet.field.value;\n        const value = facets[name];\n\n        return valueToQuery({ value, facet });\n      }),\n    ].filter((o) => !!o),\n    sort_on: sortOn || query.sort_on,\n    sort_order: sortOrder || query.sort_order,\n    b_size: query.b_size,\n    limit: query.limit,\n    block: id,\n  };\n\n  // TODO: need to check if SearchableText facet is not already in the query\n  // Ideally the searchtext functionality should be restructured as being just\n  // another facet\n  params.query = params.query.reduce(\n    // Remove SearchableText from query\n    (acc, kvp) => (kvp.i === 'SearchableText' ? acc : [...acc, kvp]),\n    [],\n  );\n  if (searchText) {\n    params.query.push({\n      i: 'SearchableText',\n      o: 'plone.app.querystring.operation.string.contains',\n      v: searchText,\n    });\n  }\n\n  return params;\n}\n\nconst getSearchFields = (searchData) => {\n  return Object.assign(\n    {},\n    ...SEARCH_ENDPOINT_FIELDS.map((k) => {\n      return searchData[k] ? { [k]: searchData[k] } : {};\n    }),\n    searchData.query ? { query: serializeQuery(searchData['query']) } : {},\n  );\n};\n\n/**\n * A HOC that will mirror the search block state to a hash location\n */\nconst useHashState = () => {\n  const location = useLocation();\n  const history = useHistory();\n\n  const oldState = React.useMemo(() => {\n    return {\n      ...qs.parse(location.search),\n      ...qs.parse(location.hash),\n    };\n  }, [location.hash, location.search]);\n\n  // This creates a shallow copy. Why is this needed?\n  const current = Object.assign(\n    {},\n    ...Array.from(Object.keys(oldState)).map((k) => ({ [k]: oldState[k] })),\n  );\n\n  const setSearchData = React.useCallback(\n    (searchData) => {\n      const newParams = qs.parse(location.hash);\n\n      let changed = false;\n\n      Object.keys(searchData)\n        .sort()\n        .forEach((k) => {\n          if (searchData[k]) {\n            newParams[k] = searchData[k];\n            if (oldState[k] !== searchData[k]) {\n              changed = true;\n            }\n          }\n        });\n\n      if (changed) {\n        history.push({\n          hash: qs.stringify(newParams),\n        });\n      }\n    },\n    [history, oldState, location.hash],\n  );\n\n  return [current, setSearchData];\n};\n\n/**\n * A hook to make it possible to switch disable mirroring the search block\n * state to the window location. When using the internal state we \"start from\n * scratch\", as it's intended to be used in the edit page.\n */\nconst useSearchBlockState = (uniqueId, isEditMode) => {\n  const [hashState, setHashState] = useHashState();\n  const [internalState, setInternalState] = React.useState({});\n\n  return isEditMode\n    ? [internalState, setInternalState]\n    : [hashState, setHashState];\n};\n\n// Simple compress/decompress the state in URL by replacing the lengthy string\nconst deserializeQuery = (q) => {\n  return JSON.parse(q)?.map((kvp) => ({\n    ...kvp,\n    o: kvp.o.replace(/^paqo/, PAQO),\n  }));\n};\nconst serializeQuery = (q) => {\n  return JSON.stringify(\n    q?.map((kvp) => ({ ...kvp, o: kvp.o.replace(PAQO, 'paqo') })),\n  );\n};\n\nconst withSearch = (options) => (WrappedComponent) => {\n  const { inputDelay = 1000 } = options || {};\n\n  function WithSearch(props) {\n    const { data, id, editable = false } = props;\n\n    const [locationSearchData, setLocationSearchData] = useSearchBlockState(\n      id,\n      editable,\n    );\n\n    const urlQuery = locationSearchData.query\n      ? deserializeQuery(locationSearchData.query)\n      : [];\n    const urlSearchText =\n      locationSearchData.SearchableText ||\n      urlQuery.find(({ i }) => i === 'SearchableText')?.v ||\n      '';\n\n    // TODO: refactor, should use only useLocationStateManager()!!!\n    const [searchText, setSearchText] = React.useState(urlSearchText);\n    const configuredFacets =\n      data.facets?.map((facet) => facet?.field?.value) || [];\n    const multiFacets = data.facets\n      ?.filter((facet) => facet?.multiple)\n      .map((facet) => facet?.field?.value);\n    const [facets, setFacets] = React.useState(\n      Object.assign(\n        {},\n        ...urlQuery.map(({ i, v }) => ({ [i]: v })), // TODO: the 'o' should be kept. This would be a major refactoring of the facets\n\n        // support for simple filters like ?Subject=something\n        // TODO: since the move to hash params this is no longer working.\n        // We'd have to treat the location.search and manage it just like the\n        // hash, to support it. We can read it, but we'd have to reset it as\n        // well, so at that point what's the difference to the hash?\n        ...configuredFacets.map((f) =>\n          locationSearchData[f]\n            ? {\n                [f]:\n                  multiFacets.indexOf(f) > -1\n                    ? [locationSearchData[f]]\n                    : locationSearchData[f],\n              }\n            : {},\n        ),\n      ),\n    );\n\n    const [sortOn, setSortOn] = React.useState(data?.query?.sort_on);\n    const [sortOrder, setSortOrder] = React.useState(data?.query?.sort_order);\n\n    const [searchData, setSearchData] = React.useState(\n      getInitialState(data, facets, urlSearchText, id),\n    );\n\n    const timeoutRef = React.useRef();\n    const facetSettings = data?.facets;\n\n    const onTriggerSearch = React.useCallback(\n      (toSearchText, toSearchFacets, toSortOn, toSortOrder) => {\n        if (timeoutRef.current) clearTimeout(timeoutRef.current);\n        timeoutRef.current = setTimeout(\n          () => {\n            const searchData = normalizeState({\n              id,\n              query: data.query || {},\n              facets: toSearchFacets || facets,\n              searchText: toSearchText,\n              sortOn: toSortOn || sortOn,\n              sortOrder: toSortOrder || sortOrder,\n              facetSettings,\n            });\n            if (toSearchFacets) setFacets(toSearchFacets);\n            if (toSortOn) setSortOn(toSortOn);\n            if (toSortOrder) setSortOrder(toSortOrder);\n            setSearchData(searchData);\n            setLocationSearchData(getSearchFields(searchData));\n          },\n          toSearchFacets ? inputDelay / 3 : inputDelay,\n        );\n      },\n      [\n        data.query,\n        facets,\n        id,\n        setLocationSearchData,\n        sortOn,\n        sortOrder,\n        facetSettings,\n      ],\n    );\n\n    const querystringResults = useSelector(\n      (state) => state.querystringsearch.subrequests,\n    );\n    const totalItems =\n      querystringResults[id]?.total || querystringResults[id]?.items?.length;\n\n    return (\n      <WrappedComponent\n        {...props}\n        searchData={searchData}\n        facets={facets}\n        setFacets={setFacets}\n        setSortOn={setSortOn}\n        setSortOrder={setSortOrder}\n        sortOn={sortOn}\n        sortOrder={sortOrder}\n        searchedText={urlSearchText}\n        searchText={searchText}\n        setSearchText={setSearchText}\n        onTriggerSearch={onTriggerSearch}\n        totalItems={totalItems}\n      />\n    );\n  }\n  WithSearch.displayName = `WithSearch(${getDisplayName(WrappedComponent)})`;\n\n  return WithSearch;\n};\n\nexport default withSearch;\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module"}