{"ast":null,"code":"import _isString from \"lodash/isString\";\nimport _isObject from \"lodash/isObject\";\nimport _isBoolean from \"lodash/isBoolean\";\nimport { getBoolean } from '@plone/volto/helpers';\nimport { defineMessages } from 'react-intl';\nconst messages = defineMessages({\n  no_value: {\n    \"id\": \"No value\",\n    \"defaultMessage\": \"No value\"\n  }\n});\n/**\n * Prepares a vocab endpoint query for tokens based on passed value.\n *\n * This can be used to facilitate querying a vocabulary endpoint for labels,\n * given some token values. This assumes that the value has already been\n * normalized by normalizeValue.\n */\n\nexport function convertValueToVocabQuery(value) {\n  var _value$value;\n\n  if (_isString(value) || _isBoolean(value)) return {\n    token: value.toString()\n  };\n  if (!value) return {};\n\n  if (Array.isArray(value)) {\n    return {\n      tokens: value.map(v => {\n        var _v$value;\n\n        return _isObject(v) ? (_v$value = v.value) !== null && _v$value !== void 0 ? _v$value : v.token : _isString(v) || _isBoolean(v) ? v : null;\n      }).filter(f => f !== null)\n    };\n  }\n\n  const token = (_value$value = value.value) !== null && _value$value !== void 0 ? _value$value : value.token;\n  return _isString(token) ? {\n    token\n  } : {};\n}\n/**\n * Normalizes provided value to a \"best representation\" value, as accepted by\n * react-select. In this case, it is an object of shape `{ label, value }`\n */\n\nexport function normalizeSingleSelectOption(value, intl) {\n  var _ref, _value$token, _ref2, _ref3, _ref4;\n\n  if (!value) return value;\n\n  if (Array.isArray(value)) {\n    // assuming [token, title] pair.\n    if (value.length === 2) return {\n      value: value[0],\n      label: value[1] || value[0]\n    };\n    throw new Error(`Unknown value type of select widget: ${value}`);\n  }\n\n  const token = (_ref = (_value$token = value.token) !== null && _value$token !== void 0 ? _value$token : value.value) !== null && _ref !== void 0 ? _ref : 'no-value';\n  const label = (_ref2 = (_ref3 = (_ref4 = value.title && value.title !== 'None' ? value.title : undefined) !== null && _ref4 !== void 0 ? _ref4 : value.label) !== null && _ref3 !== void 0 ? _ref3 : value.token) !== null && _ref2 !== void 0 ? _ref2 : intl.formatMessage(messages.no_value);\n  return {\n    value: token,\n    label\n  };\n}\nexport const normalizeChoices = (items, intl) => items.map(item => normalizeSingleSelectOption(item, intl));\n/**\n * Given the value from the API, it normalizes to a value valid to use in react-select.\n * This is necessary because of the inconsistencies in p.restapi vocabularies implementations as\n * they need to adapt to react-select public interface.\n * @function normalizeValue\n * @param {array} choices The choices\n * @param {string|object|boolean|array} value The value\n * @returns {Object} An object of shape {label: \"\", value: \"\"} (or an array)\n */\n\nexport function normalizeValue(choices, value, intl) {\n  choices = normalizeChoices(choices || [], intl);\n  const choiceMap = Object.assign({}, ...choices.map(_ref5 => {\n    let {\n      label,\n      value\n    } = _ref5;\n    return {\n      [value]: label\n    };\n  }));\n\n  if (!_isObject(value) && _isBoolean(value)) {\n    // We have a boolean value, which means we need to provide a \"No value\"\n    // option\n    const label = choiceMap[getBoolean(value)];\n    return label ? {\n      label,\n      value\n    } : {};\n  }\n\n  if (value === 'no-value') {\n    return {\n      label: intl.formatMessage(messages.no_value),\n      value: 'no-value'\n    };\n  }\n\n  if (value === undefined || !value || value.length === 0) return null;\n\n  if (Array.isArray(value)) {\n    // a list of values, like ['foo', 'bar'];\n    return value.map(v => normalizeValue(choices, v));\n  }\n\n  if (_isObject(value)) {\n    // an object like `{label, value}` or `{ title, value }`\n    return normalizeSingleSelectOption(value, intl);\n  } // fallback: treat value as a token and look it up in choices\n\n\n  return Object.keys(choiceMap).includes(value) ? {\n    label: choiceMap[value],\n    value\n  } : {\n    label: value,\n    value\n  };\n}","map":{"version":3,"names":["getBoolean","defineMessages","messages","no_value","convertValueToVocabQuery","value","token","toString","Array","isArray","tokens","map","v","filter","f","normalizeSingleSelectOption","intl","length","label","Error","title","undefined","formatMessage","normalizeChoices","items","item","normalizeValue","choices","choiceMap","Object","assign","keys","includes"],"sources":["/home/jakob/workspace/training-project/node_modules/@plone/volto/src/components/manage/Widgets/SelectUtils.js"],"sourcesContent":["import { isBoolean, isObject, isString } from 'lodash';\nimport { getBoolean } from '@plone/volto/helpers';\nimport { defineMessages } from 'react-intl';\n\nconst messages = defineMessages({\n  no_value: {\n    id: 'No value',\n    defaultMessage: 'No value',\n  },\n});\n\n/**\n * Prepares a vocab endpoint query for tokens based on passed value.\n *\n * This can be used to facilitate querying a vocabulary endpoint for labels,\n * given some token values. This assumes that the value has already been\n * normalized by normalizeValue.\n */\nexport function convertValueToVocabQuery(value) {\n  if (isString(value) || isBoolean(value)) return { token: value.toString() };\n\n  if (!value) return {};\n\n  if (Array.isArray(value)) {\n    return {\n      tokens: value\n        .map((v) =>\n          isObject(v)\n            ? v.value ?? v.token\n            : isString(v) || isBoolean(v)\n            ? v\n            : null,\n        )\n        .filter((f) => f !== null),\n    };\n  }\n\n  const token = value.value ?? value.token;\n  return isString(token) ? { token } : {};\n}\n\n/**\n * Normalizes provided value to a \"best representation\" value, as accepted by\n * react-select. In this case, it is an object of shape `{ label, value }`\n */\nexport function normalizeSingleSelectOption(value, intl) {\n  if (!value) return value;\n\n  if (Array.isArray(value)) {\n    // assuming [token, title] pair.\n    if (value.length === 2)\n      return { value: value[0], label: value[1] || value[0] };\n\n    throw new Error(`Unknown value type of select widget: ${value}`);\n  }\n\n  const token = value.token ?? value.value ?? 'no-value';\n  const label =\n    (value.title && value.title !== 'None' ? value.title : undefined) ??\n    value.label ??\n    value.token ??\n    intl.formatMessage(messages.no_value);\n\n  return {\n    value: token,\n    label,\n  };\n}\n\nexport const normalizeChoices = (items, intl) =>\n  items.map((item) => normalizeSingleSelectOption(item, intl));\n\n/**\n * Given the value from the API, it normalizes to a value valid to use in react-select.\n * This is necessary because of the inconsistencies in p.restapi vocabularies implementations as\n * they need to adapt to react-select public interface.\n * @function normalizeValue\n * @param {array} choices The choices\n * @param {string|object|boolean|array} value The value\n * @returns {Object} An object of shape {label: \"\", value: \"\"} (or an array)\n */\nexport function normalizeValue(choices, value, intl) {\n  choices = normalizeChoices(choices || [], intl);\n  const choiceMap = Object.assign(\n    {},\n    ...choices.map(({ label, value }) => ({\n      [value]: label,\n    })),\n  );\n\n  if (!isObject(value) && isBoolean(value)) {\n    // We have a boolean value, which means we need to provide a \"No value\"\n    // option\n    const label = choiceMap[getBoolean(value)];\n    return label\n      ? {\n          label,\n          value,\n        }\n      : {};\n  }\n  if (value === 'no-value') {\n    return {\n      label: intl.formatMessage(messages.no_value),\n      value: 'no-value',\n    };\n  }\n\n  if (value === undefined || !value || value.length === 0) return null;\n\n  if (Array.isArray(value)) {\n    // a list of values, like ['foo', 'bar'];\n    return value.map((v) => normalizeValue(choices, v));\n  }\n\n  if (isObject(value)) {\n    // an object like `{label, value}` or `{ title, value }`\n    return normalizeSingleSelectOption(value, intl);\n  }\n\n  // fallback: treat value as a token and look it up in choices\n  return Object.keys(choiceMap).includes(value)\n    ? { label: choiceMap[value], value }\n    : { label: value, value };\n}\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[{"id":"No value","defaultMessage":"No value"}]}},"sourceType":"module"}