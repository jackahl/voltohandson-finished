{"ast":null,"code":"import _castArray from \"lodash/castArray\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { Editor, Transforms, Range, Node } from 'slate';\nimport { ReactEditor } from 'slate-react';\nimport { isCursorInList } from '@plone/volto-slate/utils';\nimport { LI } from '@plone/volto-slate/constants';\nimport config from '@plone/volto/registry';\n/**\n * Get the nodes with a type included in `types` in the selection (from root to leaf).\n *\n * @param {} editor\n * @param {} types\n * @param {} options\n */\n\nexport function getSelectionNodesByType(editor, types, options = {}) {\n  types = _castArray(types);\n  return Editor.nodes(editor, _objectSpread({\n    match: n => {\n      return types.includes(n.type);\n    }\n  }, options));\n}\n/**\n * Is there a node with a type included in `types` in the selection (from root to leaf).\n */\n\nexport function isNodeInSelection(editor, types, options = {}) {\n  const [match] = getSelectionNodesByType(editor, types, options);\n  return !!match;\n}\n/**\n * getSelectionNodesArrayByType.\n *\n * @param {} editor\n * @param {} types\n * @param {} options\n */\n\nexport function getSelectionNodesArrayByType(editor, types, options = {}) {\n  return Array.from(getSelectionNodesByType(editor, types, options));\n}\n/**\n * getMaxRange.\n *\n * @param {} editor\n *\n * TODO: is [0] ok as a path?\n */\n\nexport function getMaxRange(editor) {\n  const maxRange = {\n    anchor: Editor.start(editor, [0]),\n    focus: Editor.end(editor, [0])\n  };\n  return maxRange;\n}\n/**\n * selectAll.\n *\n * @param {} editor\n */\n\nexport function selectAll(editor) {\n  Transforms.select(editor, getMaxRange(editor));\n} // In the isCursorAtBlockStart/End functions maybe use a part of these pieces of code:\n// Range.isCollapsed(editor.selection) &&\n// Point.equals(editor.selection.anchor, Editor.start(editor, []))\n\n/**\n * isCursorAtBlockStart.\n *\n * @param {} editor\n */\n\nexport function isCursorAtBlockStart(editor) {\n  // It does not work properly with lists\n  if (editor.selection && Range.isCollapsed(editor.selection)) {\n    const {\n      anchor\n    } = editor.selection;\n    return anchor.offset > 0 ? false : anchor.path.reduce((acc, x) => acc + x, 0) === 0; // anchor.path.length === 2 &&\n  }\n\n  return false;\n}\n/**\n * isCursorAtBlockEnd.\n *\n * @param {} editor\n */\n\nexport function isCursorAtBlockEnd(editor) {\n  // fixSelection(editor);\n  // if the selection is collapsed\n  if (editor.selection && Range.isCollapsed(editor.selection)) {\n    var _editor$selection;\n\n    const anchor = ((_editor$selection = editor.selection) === null || _editor$selection === void 0 ? void 0 : _editor$selection.anchor) || {}; // the last block node in the editor\n\n    const [node] = Node.last(editor, []);\n\n    if ( // if the node with the selection is the last block node\n    Node.get(editor, anchor.path) === node && // if the collapsed selection is at the end of the last block node\n    anchor.offset === node.text.length) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nconst defaultListItemValue = () => {\n  const {\n    slate\n  } = config.settings;\n  const dv = slate.defaultValue();\n  dv[0].type = LI;\n  return dv;\n};\n/**\n * getFragmentFromStartOfSelectionToEndOfEditor.\n *\n * @param {} editor\n */\n\n\nexport function getFragmentFromStartOfSelectionToEndOfEditor(editor, initialSelection) {\n  if (typeof initialSelection === 'undefined') {\n    initialSelection = editor.selection;\n  }\n\n  const {\n    slate\n  } = config.settings;\n  const range = Editor.range(editor, Range.isBackward(initialSelection) ? initialSelection.focus : initialSelection.anchor, Editor.end(editor, [])); // this is the case when the fragment is empty, and we must return\n  // empty fragment but without formatting\n\n  if (Range.isCollapsed(range)) {\n    if (isCursorInList(editor)) {\n      return defaultListItemValue();\n    } else {\n      return slate.defaultValue();\n    }\n  } // immer doesn't like editor.savedSelection\n\n\n  const newEditor = {\n    children: editor.children\n  };\n  return Editor.fragment(newEditor, range);\n}\n/**\n * getFragmentFromBeginningOfEditorToStartOfSelection.\n *\n * @param {} editor\n */\n\nexport function getFragmentFromBeginningOfEditorToStartOfSelection(editor, initialSelection) {\n  if (typeof initialSelection === 'undefined') {\n    initialSelection = editor.selection;\n  } // immer doesn't like editor.savedSelection\n  // TODO: there's a bug here related to splitting lists\n\n\n  const newEditor = {\n    children: editor.children\n  };\n  return Editor.fragment(newEditor, Editor.range(newEditor, [], Range.isBackward(initialSelection) ? initialSelection.focus : initialSelection.anchor));\n}\n/**\n * @returns {boolean} true if editor contains a range selection (active\n * selection or at least a saved selection)\n * @param {Editor} editor\n */\n\nexport function hasRangeSelection(editor, useSavedSelection = true) {\n  const {\n    selection\n  } = editor;\n  const savedSelection = editor.getSavedSelection();\n  const range = ReactEditor.isFocused(editor) ? selection || (useSavedSelection ? savedSelection : null) : savedSelection;\n\n  if (!range) {\n    // console.log('no range', editor);\n    return;\n  }\n\n  const res = Range.isExpanded(range); // console.log('call hasRange', res);\n\n  return res;\n}\nexport function parseDefaultSelection(editor, defaultSelection) {\n  if (defaultSelection) {\n    if (defaultSelection === 'start') {\n      const [, path] = Node.first(editor, []);\n      const newSel = {\n        anchor: {\n          path,\n          offset: 0\n        },\n        focus: {\n          path,\n          offset: 0\n        }\n      };\n      return newSel;\n    }\n\n    if (defaultSelection === 'end') {\n      const [leaf, path] = Node.last(editor, []);\n      const newSel = {\n        anchor: {\n          path,\n          offset: (leaf.text || '').length\n        },\n        focus: {\n          path,\n          offset: (leaf.text || '').length\n        }\n      };\n      return newSel;\n    }\n\n    return defaultSelection;\n  }\n}","map":{"version":3,"names":["Editor","Transforms","Range","Node","ReactEditor","isCursorInList","LI","config","getSelectionNodesByType","editor","types","options","nodes","match","n","includes","type","isNodeInSelection","getSelectionNodesArrayByType","Array","from","getMaxRange","maxRange","anchor","start","focus","end","selectAll","select","isCursorAtBlockStart","selection","isCollapsed","offset","path","reduce","acc","x","isCursorAtBlockEnd","node","last","get","text","length","defaultListItemValue","slate","settings","dv","defaultValue","getFragmentFromStartOfSelectionToEndOfEditor","initialSelection","range","isBackward","newEditor","children","fragment","getFragmentFromBeginningOfEditorToStartOfSelection","hasRangeSelection","useSavedSelection","savedSelection","getSavedSelection","isFocused","res","isExpanded","parseDefaultSelection","defaultSelection","first","newSel","leaf"],"sources":["/home/jakob/workspace/training-project/node_modules/@plone/volto/packages/volto-slate/src/utils/selection.js"],"sourcesContent":["import { castArray } from 'lodash';\nimport { Editor, Transforms, Range, Node } from 'slate';\nimport { ReactEditor } from 'slate-react';\nimport { isCursorInList } from '@plone/volto-slate/utils';\nimport { LI } from '@plone/volto-slate/constants';\nimport config from '@plone/volto/registry';\n\n/**\n * Get the nodes with a type included in `types` in the selection (from root to leaf).\n *\n * @param {} editor\n * @param {} types\n * @param {} options\n */\nexport function getSelectionNodesByType(editor, types, options = {}) {\n  types = castArray(types);\n\n  return Editor.nodes(editor, {\n    match: (n) => {\n      return types.includes(n.type);\n    },\n    ...options,\n  });\n}\n\n/**\n * Is there a node with a type included in `types` in the selection (from root to leaf).\n */\nexport function isNodeInSelection(editor, types, options = {}) {\n  const [match] = getSelectionNodesByType(editor, types, options);\n  return !!match;\n}\n\n/**\n * getSelectionNodesArrayByType.\n *\n * @param {} editor\n * @param {} types\n * @param {} options\n */\nexport function getSelectionNodesArrayByType(editor, types, options = {}) {\n  return Array.from(getSelectionNodesByType(editor, types, options));\n}\n\n/**\n * getMaxRange.\n *\n * @param {} editor\n *\n * TODO: is [0] ok as a path?\n */\nexport function getMaxRange(editor) {\n  const maxRange = {\n    anchor: Editor.start(editor, [0]),\n    focus: Editor.end(editor, [0]),\n  };\n  return maxRange;\n}\n\n/**\n * selectAll.\n *\n * @param {} editor\n */\nexport function selectAll(editor) {\n  Transforms.select(editor, getMaxRange(editor));\n}\n\n// In the isCursorAtBlockStart/End functions maybe use a part of these pieces of code:\n// Range.isCollapsed(editor.selection) &&\n// Point.equals(editor.selection.anchor, Editor.start(editor, []))\n\n/**\n * isCursorAtBlockStart.\n *\n * @param {} editor\n */\nexport function isCursorAtBlockStart(editor) {\n  // It does not work properly with lists\n\n  if (editor.selection && Range.isCollapsed(editor.selection)) {\n    const { anchor } = editor.selection;\n    return anchor.offset > 0\n      ? false\n      : anchor.path.reduce((acc, x) => acc + x, 0) === 0;\n    // anchor.path.length === 2 &&\n  }\n  return false;\n}\n\n/**\n * isCursorAtBlockEnd.\n *\n * @param {} editor\n */\nexport function isCursorAtBlockEnd(editor) {\n  // fixSelection(editor);\n\n  // if the selection is collapsed\n  if (editor.selection && Range.isCollapsed(editor.selection)) {\n    const anchor = editor.selection?.anchor || {};\n\n    // the last block node in the editor\n    const [node] = Node.last(editor, []);\n\n    if (\n      // if the node with the selection is the last block node\n      Node.get(editor, anchor.path) === node &&\n      // if the collapsed selection is at the end of the last block node\n      anchor.offset === node.text.length\n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n\nconst defaultListItemValue = () => {\n  const { slate } = config.settings;\n  const dv = slate.defaultValue();\n  dv[0].type = LI;\n  return dv;\n};\n\n/**\n * getFragmentFromStartOfSelectionToEndOfEditor.\n *\n * @param {} editor\n */\nexport function getFragmentFromStartOfSelectionToEndOfEditor(\n  editor,\n  initialSelection,\n) {\n  if (typeof initialSelection === 'undefined') {\n    initialSelection = editor.selection;\n  }\n\n  const { slate } = config.settings;\n  const range = Editor.range(\n    editor,\n    Range.isBackward(initialSelection)\n      ? initialSelection.focus\n      : initialSelection.anchor,\n    Editor.end(editor, []),\n  );\n\n  // this is the case when the fragment is empty, and we must return\n  // empty fragment but without formatting\n  if (Range.isCollapsed(range)) {\n    if (isCursorInList(editor)) {\n      return defaultListItemValue();\n    } else {\n      return slate.defaultValue();\n    }\n  }\n\n  // immer doesn't like editor.savedSelection\n  const newEditor = { children: editor.children };\n  return Editor.fragment(newEditor, range);\n}\n\n/**\n * getFragmentFromBeginningOfEditorToStartOfSelection.\n *\n * @param {} editor\n */\nexport function getFragmentFromBeginningOfEditorToStartOfSelection(\n  editor,\n  initialSelection,\n) {\n  if (typeof initialSelection === 'undefined') {\n    initialSelection = editor.selection;\n  }\n\n  // immer doesn't like editor.savedSelection\n  // TODO: there's a bug here related to splitting lists\n  const newEditor = { children: editor.children };\n  return Editor.fragment(\n    newEditor,\n    Editor.range(\n      newEditor,\n      [],\n      Range.isBackward(initialSelection)\n        ? initialSelection.focus\n        : initialSelection.anchor,\n    ),\n  );\n}\n\n/**\n * @returns {boolean} true if editor contains a range selection (active\n * selection or at least a saved selection)\n * @param {Editor} editor\n */\nexport function hasRangeSelection(editor, useSavedSelection = true) {\n  const { selection } = editor;\n  const savedSelection = editor.getSavedSelection();\n\n  const range = ReactEditor.isFocused(editor)\n    ? selection || (useSavedSelection ? savedSelection : null)\n    : savedSelection;\n\n  if (!range) {\n    // console.log('no range', editor);\n    return;\n  }\n\n  const res = Range.isExpanded(range);\n  // console.log('call hasRange', res);\n  return res;\n}\n\nexport function parseDefaultSelection(editor, defaultSelection) {\n  if (defaultSelection) {\n    if (defaultSelection === 'start') {\n      const [, path] = Node.first(editor, []);\n      const newSel = {\n        anchor: { path, offset: 0 },\n        focus: { path, offset: 0 },\n      };\n      return newSel;\n    }\n    if (defaultSelection === 'end') {\n      const [leaf, path] = Node.last(editor, []);\n      const newSel = {\n        anchor: { path, offset: (leaf.text || '').length },\n        focus: { path, offset: (leaf.text || '').length },\n      };\n      return newSel;\n    }\n    return defaultSelection;\n  }\n}\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module"}