{"ast":null,"code":"import ReactDOM from 'react-dom';\nimport { serializeNodesToText } from '@plone/volto-slate/editor/render';\nimport { Editor } from 'slate';\nimport { getPreviousVoltoBlock, getNextVoltoBlock, isCursorAtBlockStart, isCursorAtBlockEnd, mergeSlateWithBlockBackward, mergeSlateWithBlockForward } from '@plone/volto-slate/utils';\nimport { changeBlock, deleteBlock, getBlocksFieldname, getBlocksLayoutFieldname } from '@plone/volto/helpers';\n/**\n * Joins the current block (which has an active Slate Editor)\n * with the previous block, to make a single block.\n *\n * @param {Editor} editor\n * @param {KeyboardEvent} event\n */\n\nexport function joinWithPreviousBlock({\n  editor,\n  event\n}) {\n  if (!isCursorAtBlockStart(editor)) return;\n  const blockProps = editor.getBlockProps();\n  const {\n    block,\n    index,\n    saveSlateBlockSelection,\n    onSelectBlock,\n    data,\n    properties,\n    onChangeField\n  } = blockProps;\n  const blocksFieldname = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n  const prev = getPreviousVoltoBlock(index, properties);\n  if (!prev) return;\n  const [otherBlock = {}, otherBlockId] = prev; // Don't join with required blocks\n\n  if (data !== null && data !== void 0 && data.required || otherBlock !== null && otherBlock !== void 0 && otherBlock.required || otherBlock['@type'] !== 'slate') return;\n  event.stopPropagation();\n  event.preventDefault(); // If the Editor contains no characters TODO: clarify if this special case\n  // really needs to be handled or not. In `joinWithNextBlock` it is not\n  // handled.\n\n  const text = Editor.string(editor, []);\n\n  if (!text) {\n    const cursor = getBlockEndAsRange(otherBlock);\n    const newFormData = deleteBlock(properties, block);\n    ReactDOM.unstable_batchedUpdates(() => {\n      saveSlateBlockSelection(otherBlockId, cursor);\n      onChangeField(blocksFieldname, newFormData[blocksFieldname]);\n      onChangeField(blocksLayoutFieldname, newFormData[blocksLayoutFieldname]);\n      onSelectBlock(otherBlockId);\n    });\n    return true;\n  } // Else the editor contains characters, so we merge the current block's\n  // `editor` with the block before, `otherBlock`.\n\n\n  const cursor = mergeSlateWithBlockBackward(editor, otherBlock);\n  const combined = JSON.parse(JSON.stringify(editor.children)); // // TODO: don't remove undo history, etc Should probably save both undo\n  // // histories, so that the blocks are split, the undos can be restored??\n  // const cursor = getBlockEndAsRange(otherBlock);\n\n  const formData = changeBlock(properties, otherBlockId, {\n    '@type': 'slate',\n    // TODO: use a constant specified in src/constants.js instead of 'slate'\n    value: combined,\n    plaintext: serializeNodesToText(combined || [])\n  });\n  const newFormData = deleteBlock(formData, block);\n  ReactDOM.unstable_batchedUpdates(() => {\n    saveSlateBlockSelection(otherBlockId, cursor);\n    onChangeField(blocksFieldname, newFormData[blocksFieldname]);\n    onChangeField(blocksLayoutFieldname, newFormData[blocksLayoutFieldname]);\n    onSelectBlock(otherBlockId);\n  });\n  return true;\n}\n/**\n * Joins the current block (which has the cursor) with the next block to make a\n * single block.\n * @param {Editor} editor\n * @param {KeyboardEvent} event\n */\n\nexport function joinWithNextBlock({\n  editor,\n  event\n}) {\n  if (!isCursorAtBlockEnd(editor)) return;\n  const blockProps = editor.getBlockProps();\n  const {\n    block,\n    index,\n    // saveSlateBlockSelection,\n    onSelectBlock,\n    data\n  } = blockProps;\n  const {\n    properties,\n    onChangeField\n  } = editor.getBlockProps();\n  const [otherBlock = {}, otherBlockId] = getNextVoltoBlock(index, properties); // Don't join with required blocks\n\n  if (data !== null && data !== void 0 && data.required || otherBlock !== null && otherBlock !== void 0 && otherBlock.required || otherBlock['@type'] !== 'slate') return;\n  event.stopPropagation();\n  event.preventDefault();\n  mergeSlateWithBlockForward(editor, otherBlock); // const cursor = JSON.parse(JSON.stringify(editor.selection));\n\n  const combined = JSON.parse(JSON.stringify(editor.children)); // TODO: don't remove undo history, etc Should probably save both undo\n  // histories, so that the blocks are split, the undos can be restored??\n\n  const blocksFieldname = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n  const formData = changeBlock(properties, otherBlockId, {\n    // TODO: use a constant specified in src/constants.js instead of 'slate'\n    '@type': 'slate',\n    value: combined,\n    plaintext: serializeNodesToText(combined || [])\n  });\n  const newFormData = deleteBlock(formData, block);\n  ReactDOM.unstable_batchedUpdates(() => {\n    // saveSlateBlockSelection(otherBlockId, cursor);\n    onChangeField(blocksFieldname, newFormData[blocksFieldname]);\n    onChangeField(blocksLayoutFieldname, newFormData[blocksLayoutFieldname]);\n    onSelectBlock(otherBlockId);\n  });\n  return true;\n}\n/**\n * @param {object} block The Volto object representing the configuration and\n * contents of a Volto Block of type Slate Text.\n * @returns {Range} The collapsed Slate Range that represents the last position\n * the text cursor can take inside the given block.\n */\n\nfunction getBlockEndAsRange(block) {\n  const {\n    value\n  } = block;\n  const location = [value.length - 1]; // adress of root node\n\n  const editor = {\n    children: value\n  };\n  const path = Editor.last(editor, location)[1]; // last Node in the block\n  // The last Text node (leaf node) entry inside the path computed just above.\n\n  const [leaf, leafpath] = Editor.leaf(editor, path); // The offset of the Points in the collapsed Range computed below:\n\n  const offset = (leaf.text || '').length;\n  return {\n    anchor: {\n      path: leafpath,\n      offset\n    },\n    focus: {\n      path: leafpath,\n      offset\n    }\n  };\n}","map":{"version":3,"names":["ReactDOM","serializeNodesToText","Editor","getPreviousVoltoBlock","getNextVoltoBlock","isCursorAtBlockStart","isCursorAtBlockEnd","mergeSlateWithBlockBackward","mergeSlateWithBlockForward","changeBlock","deleteBlock","getBlocksFieldname","getBlocksLayoutFieldname","joinWithPreviousBlock","editor","event","blockProps","getBlockProps","block","index","saveSlateBlockSelection","onSelectBlock","data","properties","onChangeField","blocksFieldname","blocksLayoutFieldname","prev","otherBlock","otherBlockId","required","stopPropagation","preventDefault","text","string","cursor","getBlockEndAsRange","newFormData","unstable_batchedUpdates","combined","JSON","parse","stringify","children","formData","value","plaintext","joinWithNextBlock","location","length","path","last","leaf","leafpath","offset","anchor","focus"],"sources":["/home/jakob/workspace/training-project/node_modules/@plone/volto/packages/volto-slate/src/blocks/Text/keyboard/joinBlocks.js"],"sourcesContent":["import ReactDOM from 'react-dom';\nimport { serializeNodesToText } from '@plone/volto-slate/editor/render';\nimport { Editor } from 'slate';\nimport {\n  getPreviousVoltoBlock,\n  getNextVoltoBlock,\n  isCursorAtBlockStart,\n  isCursorAtBlockEnd,\n  mergeSlateWithBlockBackward,\n  mergeSlateWithBlockForward,\n} from '@plone/volto-slate/utils';\nimport {\n  changeBlock,\n  deleteBlock,\n  getBlocksFieldname,\n  getBlocksLayoutFieldname,\n} from '@plone/volto/helpers';\n\n/**\n * Joins the current block (which has an active Slate Editor)\n * with the previous block, to make a single block.\n *\n * @param {Editor} editor\n * @param {KeyboardEvent} event\n */\nexport function joinWithPreviousBlock({ editor, event }) {\n  if (!isCursorAtBlockStart(editor)) return;\n\n  const blockProps = editor.getBlockProps();\n  const {\n    block,\n    index,\n    saveSlateBlockSelection,\n    onSelectBlock,\n    data,\n    properties,\n    onChangeField,\n  } = blockProps;\n\n  const blocksFieldname = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n\n  const prev = getPreviousVoltoBlock(index, properties);\n  if (!prev) return;\n  const [otherBlock = {}, otherBlockId] = prev;\n\n  // Don't join with required blocks\n  if (data?.required || otherBlock?.required || otherBlock['@type'] !== 'slate')\n    return;\n\n  event.stopPropagation();\n  event.preventDefault();\n\n  // If the Editor contains no characters TODO: clarify if this special case\n  // really needs to be handled or not. In `joinWithNextBlock` it is not\n  // handled.\n  const text = Editor.string(editor, []);\n  if (!text) {\n    const cursor = getBlockEndAsRange(otherBlock);\n    const newFormData = deleteBlock(properties, block);\n\n    ReactDOM.unstable_batchedUpdates(() => {\n      saveSlateBlockSelection(otherBlockId, cursor);\n\n      onChangeField(blocksFieldname, newFormData[blocksFieldname]);\n      onChangeField(blocksLayoutFieldname, newFormData[blocksLayoutFieldname]);\n\n      onSelectBlock(otherBlockId);\n    });\n\n    return true;\n  }\n\n  // Else the editor contains characters, so we merge the current block's\n  // `editor` with the block before, `otherBlock`.\n  const cursor = mergeSlateWithBlockBackward(editor, otherBlock);\n\n  const combined = JSON.parse(JSON.stringify(editor.children));\n\n  // // TODO: don't remove undo history, etc Should probably save both undo\n  // // histories, so that the blocks are split, the undos can be restored??\n\n  // const cursor = getBlockEndAsRange(otherBlock);\n  const formData = changeBlock(properties, otherBlockId, {\n    '@type': 'slate', // TODO: use a constant specified in src/constants.js instead of 'slate'\n    value: combined,\n    plaintext: serializeNodesToText(combined || []),\n  });\n  const newFormData = deleteBlock(formData, block);\n\n  ReactDOM.unstable_batchedUpdates(() => {\n    saveSlateBlockSelection(otherBlockId, cursor);\n    onChangeField(blocksFieldname, newFormData[blocksFieldname]);\n    onChangeField(blocksLayoutFieldname, newFormData[blocksLayoutFieldname]);\n    onSelectBlock(otherBlockId);\n  });\n\n  return true;\n}\n\n/**\n * Joins the current block (which has the cursor) with the next block to make a\n * single block.\n * @param {Editor} editor\n * @param {KeyboardEvent} event\n */\nexport function joinWithNextBlock({ editor, event }) {\n  if (!isCursorAtBlockEnd(editor)) return;\n\n  const blockProps = editor.getBlockProps();\n  const {\n    block,\n    index,\n    // saveSlateBlockSelection,\n    onSelectBlock,\n    data,\n  } = blockProps;\n\n  const { properties, onChangeField } = editor.getBlockProps();\n  const [otherBlock = {}, otherBlockId] = getNextVoltoBlock(index, properties);\n\n  // Don't join with required blocks\n  if (data?.required || otherBlock?.required || otherBlock['@type'] !== 'slate')\n    return;\n\n  event.stopPropagation();\n  event.preventDefault();\n\n  mergeSlateWithBlockForward(editor, otherBlock);\n\n  // const cursor = JSON.parse(JSON.stringify(editor.selection));\n  const combined = JSON.parse(JSON.stringify(editor.children));\n\n  // TODO: don't remove undo history, etc Should probably save both undo\n  // histories, so that the blocks are split, the undos can be restored??\n\n  const blocksFieldname = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n\n  const formData = changeBlock(properties, otherBlockId, {\n    // TODO: use a constant specified in src/constants.js instead of 'slate'\n    '@type': 'slate',\n    value: combined,\n    plaintext: serializeNodesToText(combined || []),\n  });\n  const newFormData = deleteBlock(formData, block);\n\n  ReactDOM.unstable_batchedUpdates(() => {\n    // saveSlateBlockSelection(otherBlockId, cursor);\n    onChangeField(blocksFieldname, newFormData[blocksFieldname]);\n    onChangeField(blocksLayoutFieldname, newFormData[blocksLayoutFieldname]);\n    onSelectBlock(otherBlockId);\n  });\n  return true;\n}\n\n/**\n * @param {object} block The Volto object representing the configuration and\n * contents of a Volto Block of type Slate Text.\n * @returns {Range} The collapsed Slate Range that represents the last position\n * the text cursor can take inside the given block.\n */\nfunction getBlockEndAsRange(block) {\n  const { value } = block;\n  const location = [value.length - 1]; // adress of root node\n  const editor = { children: value };\n  const path = Editor.last(editor, location)[1]; // last Node in the block\n  // The last Text node (leaf node) entry inside the path computed just above.\n  const [leaf, leafpath] = Editor.leaf(editor, path);\n  // The offset of the Points in the collapsed Range computed below:\n  const offset = (leaf.text || '').length;\n\n  return {\n    anchor: { path: leafpath, offset },\n    focus: { path: leafpath, offset },\n  };\n}\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module"}